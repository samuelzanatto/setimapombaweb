
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Live
 * 
 */
export type Live = $Result.DefaultSelection<Prisma.$LivePayload>
/**
 * Model Leitura
 * 
 */
export type Leitura = $Result.DefaultSelection<Prisma.$LeituraPayload>
/**
 * Model PedidoOracao
 * 
 */
export type PedidoOracao = $Result.DefaultSelection<Prisma.$PedidoOracaoPayload>
/**
 * Model ViewerSession
 * 
 */
export type ViewerSession = $Result.DefaultSelection<Prisma.$ViewerSessionPayload>
/**
 * Model Cargo
 * 
 */
export type Cargo = $Result.DefaultSelection<Prisma.$CargoPayload>
/**
 * Model Local
 * 
 */
export type Local = $Result.DefaultSelection<Prisma.$LocalPayload>
/**
 * Model Culto
 * 
 */
export type Culto = $Result.DefaultSelection<Prisma.$CultoPayload>
/**
 * Model Reuniao
 * 
 */
export type Reuniao = $Result.DefaultSelection<Prisma.$ReuniaoPayload>
/**
 * Model Ensaio
 * 
 */
export type Ensaio = $Result.DefaultSelection<Prisma.$EnsaioPayload>
/**
 * Model Evento
 * 
 */
export type Evento = $Result.DefaultSelection<Prisma.$EventoPayload>
/**
 * Model Mensagem
 * 
 */
export type Mensagem = $Result.DefaultSelection<Prisma.$MensagemPayload>
/**
 * Model Hino
 * 
 */
export type Hino = $Result.DefaultSelection<Prisma.$HinoPayload>
/**
 * Model LeituraBiblica
 * 
 */
export type LeituraBiblica = $Result.DefaultSelection<Prisma.$LeituraBiblicaPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.live`: Exposes CRUD operations for the **Live** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lives
    * const lives = await prisma.live.findMany()
    * ```
    */
  get live(): Prisma.LiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leitura`: Exposes CRUD operations for the **Leitura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leituras
    * const leituras = await prisma.leitura.findMany()
    * ```
    */
  get leitura(): Prisma.LeituraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pedidoOracao`: Exposes CRUD operations for the **PedidoOracao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PedidoOracaos
    * const pedidoOracaos = await prisma.pedidoOracao.findMany()
    * ```
    */
  get pedidoOracao(): Prisma.PedidoOracaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viewerSession`: Exposes CRUD operations for the **ViewerSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewerSessions
    * const viewerSessions = await prisma.viewerSession.findMany()
    * ```
    */
  get viewerSession(): Prisma.ViewerSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cargo`: Exposes CRUD operations for the **Cargo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cargos
    * const cargos = await prisma.cargo.findMany()
    * ```
    */
  get cargo(): Prisma.CargoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.local`: Exposes CRUD operations for the **Local** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locals
    * const locals = await prisma.local.findMany()
    * ```
    */
  get local(): Prisma.LocalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.culto`: Exposes CRUD operations for the **Culto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cultos
    * const cultos = await prisma.culto.findMany()
    * ```
    */
  get culto(): Prisma.CultoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reuniao`: Exposes CRUD operations for the **Reuniao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reuniaos
    * const reuniaos = await prisma.reuniao.findMany()
    * ```
    */
  get reuniao(): Prisma.ReuniaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ensaio`: Exposes CRUD operations for the **Ensaio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ensaios
    * const ensaios = await prisma.ensaio.findMany()
    * ```
    */
  get ensaio(): Prisma.EnsaioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evento`: Exposes CRUD operations for the **Evento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eventos
    * const eventos = await prisma.evento.findMany()
    * ```
    */
  get evento(): Prisma.EventoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mensagem`: Exposes CRUD operations for the **Mensagem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mensagems
    * const mensagems = await prisma.mensagem.findMany()
    * ```
    */
  get mensagem(): Prisma.MensagemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hino`: Exposes CRUD operations for the **Hino** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hinos
    * const hinos = await prisma.hino.findMany()
    * ```
    */
  get hino(): Prisma.HinoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leituraBiblica`: Exposes CRUD operations for the **LeituraBiblica** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeituraBiblicas
    * const leituraBiblicas = await prisma.leituraBiblica.findMany()
    * ```
    */
  get leituraBiblica(): Prisma.LeituraBiblicaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Live: 'Live',
    Leitura: 'Leitura',
    PedidoOracao: 'PedidoOracao',
    ViewerSession: 'ViewerSession',
    Cargo: 'Cargo',
    Local: 'Local',
    Culto: 'Culto',
    Reuniao: 'Reuniao',
    Ensaio: 'Ensaio',
    Evento: 'Evento',
    Mensagem: 'Mensagem',
    Hino: 'Hino',
    LeituraBiblica: 'LeituraBiblica'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "live" | "leitura" | "pedidoOracao" | "viewerSession" | "cargo" | "local" | "culto" | "reuniao" | "ensaio" | "evento" | "mensagem" | "hino" | "leituraBiblica"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Live: {
        payload: Prisma.$LivePayload<ExtArgs>
        fields: Prisma.LiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload>
          }
          findFirst: {
            args: Prisma.LiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload>
          }
          findMany: {
            args: Prisma.LiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload>[]
          }
          create: {
            args: Prisma.LiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload>
          }
          createMany: {
            args: Prisma.LiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload>[]
          }
          delete: {
            args: Prisma.LiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload>
          }
          update: {
            args: Prisma.LiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload>
          }
          deleteMany: {
            args: Prisma.LiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload>[]
          }
          upsert: {
            args: Prisma.LiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivePayload>
          }
          aggregate: {
            args: Prisma.LiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLive>
          }
          groupBy: {
            args: Prisma.LiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiveCountArgs<ExtArgs>
            result: $Utils.Optional<LiveCountAggregateOutputType> | number
          }
        }
      }
      Leitura: {
        payload: Prisma.$LeituraPayload<ExtArgs>
        fields: Prisma.LeituraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeituraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeituraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload>
          }
          findFirst: {
            args: Prisma.LeituraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeituraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload>
          }
          findMany: {
            args: Prisma.LeituraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload>[]
          }
          create: {
            args: Prisma.LeituraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload>
          }
          createMany: {
            args: Prisma.LeituraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeituraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload>[]
          }
          delete: {
            args: Prisma.LeituraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload>
          }
          update: {
            args: Prisma.LeituraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload>
          }
          deleteMany: {
            args: Prisma.LeituraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeituraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeituraUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload>[]
          }
          upsert: {
            args: Prisma.LeituraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraPayload>
          }
          aggregate: {
            args: Prisma.LeituraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeitura>
          }
          groupBy: {
            args: Prisma.LeituraGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeituraGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeituraCountArgs<ExtArgs>
            result: $Utils.Optional<LeituraCountAggregateOutputType> | number
          }
        }
      }
      PedidoOracao: {
        payload: Prisma.$PedidoOracaoPayload<ExtArgs>
        fields: Prisma.PedidoOracaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PedidoOracaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PedidoOracaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload>
          }
          findFirst: {
            args: Prisma.PedidoOracaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PedidoOracaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload>
          }
          findMany: {
            args: Prisma.PedidoOracaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload>[]
          }
          create: {
            args: Prisma.PedidoOracaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload>
          }
          createMany: {
            args: Prisma.PedidoOracaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PedidoOracaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload>[]
          }
          delete: {
            args: Prisma.PedidoOracaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload>
          }
          update: {
            args: Prisma.PedidoOracaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload>
          }
          deleteMany: {
            args: Prisma.PedidoOracaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PedidoOracaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PedidoOracaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload>[]
          }
          upsert: {
            args: Prisma.PedidoOracaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PedidoOracaoPayload>
          }
          aggregate: {
            args: Prisma.PedidoOracaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePedidoOracao>
          }
          groupBy: {
            args: Prisma.PedidoOracaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PedidoOracaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PedidoOracaoCountArgs<ExtArgs>
            result: $Utils.Optional<PedidoOracaoCountAggregateOutputType> | number
          }
        }
      }
      ViewerSession: {
        payload: Prisma.$ViewerSessionPayload<ExtArgs>
        fields: Prisma.ViewerSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewerSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewerSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload>
          }
          findFirst: {
            args: Prisma.ViewerSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewerSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload>
          }
          findMany: {
            args: Prisma.ViewerSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload>[]
          }
          create: {
            args: Prisma.ViewerSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload>
          }
          createMany: {
            args: Prisma.ViewerSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewerSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload>[]
          }
          delete: {
            args: Prisma.ViewerSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload>
          }
          update: {
            args: Prisma.ViewerSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload>
          }
          deleteMany: {
            args: Prisma.ViewerSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewerSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViewerSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload>[]
          }
          upsert: {
            args: Prisma.ViewerSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewerSessionPayload>
          }
          aggregate: {
            args: Prisma.ViewerSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewerSession>
          }
          groupBy: {
            args: Prisma.ViewerSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewerSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewerSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ViewerSessionCountAggregateOutputType> | number
          }
        }
      }
      Cargo: {
        payload: Prisma.$CargoPayload<ExtArgs>
        fields: Prisma.CargoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CargoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CargoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          findFirst: {
            args: Prisma.CargoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CargoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          findMany: {
            args: Prisma.CargoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>[]
          }
          create: {
            args: Prisma.CargoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          createMany: {
            args: Prisma.CargoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CargoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>[]
          }
          delete: {
            args: Prisma.CargoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          update: {
            args: Prisma.CargoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          deleteMany: {
            args: Prisma.CargoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CargoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CargoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>[]
          }
          upsert: {
            args: Prisma.CargoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CargoPayload>
          }
          aggregate: {
            args: Prisma.CargoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCargo>
          }
          groupBy: {
            args: Prisma.CargoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CargoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CargoCountArgs<ExtArgs>
            result: $Utils.Optional<CargoCountAggregateOutputType> | number
          }
        }
      }
      Local: {
        payload: Prisma.$LocalPayload<ExtArgs>
        fields: Prisma.LocalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          findFirst: {
            args: Prisma.LocalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          findMany: {
            args: Prisma.LocalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>[]
          }
          create: {
            args: Prisma.LocalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          createMany: {
            args: Prisma.LocalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>[]
          }
          delete: {
            args: Prisma.LocalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          update: {
            args: Prisma.LocalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          deleteMany: {
            args: Prisma.LocalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>[]
          }
          upsert: {
            args: Prisma.LocalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalPayload>
          }
          aggregate: {
            args: Prisma.LocalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocal>
          }
          groupBy: {
            args: Prisma.LocalGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalCountArgs<ExtArgs>
            result: $Utils.Optional<LocalCountAggregateOutputType> | number
          }
        }
      }
      Culto: {
        payload: Prisma.$CultoPayload<ExtArgs>
        fields: Prisma.CultoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CultoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CultoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload>
          }
          findFirst: {
            args: Prisma.CultoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CultoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload>
          }
          findMany: {
            args: Prisma.CultoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload>[]
          }
          create: {
            args: Prisma.CultoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload>
          }
          createMany: {
            args: Prisma.CultoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CultoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload>[]
          }
          delete: {
            args: Prisma.CultoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload>
          }
          update: {
            args: Prisma.CultoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload>
          }
          deleteMany: {
            args: Prisma.CultoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CultoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CultoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload>[]
          }
          upsert: {
            args: Prisma.CultoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CultoPayload>
          }
          aggregate: {
            args: Prisma.CultoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCulto>
          }
          groupBy: {
            args: Prisma.CultoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CultoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CultoCountArgs<ExtArgs>
            result: $Utils.Optional<CultoCountAggregateOutputType> | number
          }
        }
      }
      Reuniao: {
        payload: Prisma.$ReuniaoPayload<ExtArgs>
        fields: Prisma.ReuniaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReuniaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReuniaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload>
          }
          findFirst: {
            args: Prisma.ReuniaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReuniaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload>
          }
          findMany: {
            args: Prisma.ReuniaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload>[]
          }
          create: {
            args: Prisma.ReuniaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload>
          }
          createMany: {
            args: Prisma.ReuniaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReuniaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload>[]
          }
          delete: {
            args: Prisma.ReuniaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload>
          }
          update: {
            args: Prisma.ReuniaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload>
          }
          deleteMany: {
            args: Prisma.ReuniaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReuniaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReuniaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload>[]
          }
          upsert: {
            args: Prisma.ReuniaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReuniaoPayload>
          }
          aggregate: {
            args: Prisma.ReuniaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReuniao>
          }
          groupBy: {
            args: Prisma.ReuniaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReuniaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReuniaoCountArgs<ExtArgs>
            result: $Utils.Optional<ReuniaoCountAggregateOutputType> | number
          }
        }
      }
      Ensaio: {
        payload: Prisma.$EnsaioPayload<ExtArgs>
        fields: Prisma.EnsaioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnsaioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnsaioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload>
          }
          findFirst: {
            args: Prisma.EnsaioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnsaioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload>
          }
          findMany: {
            args: Prisma.EnsaioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload>[]
          }
          create: {
            args: Prisma.EnsaioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload>
          }
          createMany: {
            args: Prisma.EnsaioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnsaioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload>[]
          }
          delete: {
            args: Prisma.EnsaioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload>
          }
          update: {
            args: Prisma.EnsaioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload>
          }
          deleteMany: {
            args: Prisma.EnsaioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnsaioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnsaioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload>[]
          }
          upsert: {
            args: Prisma.EnsaioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnsaioPayload>
          }
          aggregate: {
            args: Prisma.EnsaioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnsaio>
          }
          groupBy: {
            args: Prisma.EnsaioGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnsaioGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnsaioCountArgs<ExtArgs>
            result: $Utils.Optional<EnsaioCountAggregateOutputType> | number
          }
        }
      }
      Evento: {
        payload: Prisma.$EventoPayload<ExtArgs>
        fields: Prisma.EventoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          findFirst: {
            args: Prisma.EventoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          findMany: {
            args: Prisma.EventoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>[]
          }
          create: {
            args: Prisma.EventoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          createMany: {
            args: Prisma.EventoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>[]
          }
          delete: {
            args: Prisma.EventoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          update: {
            args: Prisma.EventoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          deleteMany: {
            args: Prisma.EventoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>[]
          }
          upsert: {
            args: Prisma.EventoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          aggregate: {
            args: Prisma.EventoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvento>
          }
          groupBy: {
            args: Prisma.EventoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventoCountArgs<ExtArgs>
            result: $Utils.Optional<EventoCountAggregateOutputType> | number
          }
        }
      }
      Mensagem: {
        payload: Prisma.$MensagemPayload<ExtArgs>
        fields: Prisma.MensagemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MensagemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MensagemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload>
          }
          findFirst: {
            args: Prisma.MensagemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MensagemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload>
          }
          findMany: {
            args: Prisma.MensagemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload>[]
          }
          create: {
            args: Prisma.MensagemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload>
          }
          createMany: {
            args: Prisma.MensagemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MensagemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload>[]
          }
          delete: {
            args: Prisma.MensagemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload>
          }
          update: {
            args: Prisma.MensagemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload>
          }
          deleteMany: {
            args: Prisma.MensagemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MensagemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MensagemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload>[]
          }
          upsert: {
            args: Prisma.MensagemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MensagemPayload>
          }
          aggregate: {
            args: Prisma.MensagemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMensagem>
          }
          groupBy: {
            args: Prisma.MensagemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MensagemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MensagemCountArgs<ExtArgs>
            result: $Utils.Optional<MensagemCountAggregateOutputType> | number
          }
        }
      }
      Hino: {
        payload: Prisma.$HinoPayload<ExtArgs>
        fields: Prisma.HinoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HinoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HinoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload>
          }
          findFirst: {
            args: Prisma.HinoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HinoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload>
          }
          findMany: {
            args: Prisma.HinoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload>[]
          }
          create: {
            args: Prisma.HinoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload>
          }
          createMany: {
            args: Prisma.HinoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HinoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload>[]
          }
          delete: {
            args: Prisma.HinoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload>
          }
          update: {
            args: Prisma.HinoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload>
          }
          deleteMany: {
            args: Prisma.HinoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HinoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HinoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload>[]
          }
          upsert: {
            args: Prisma.HinoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HinoPayload>
          }
          aggregate: {
            args: Prisma.HinoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHino>
          }
          groupBy: {
            args: Prisma.HinoGroupByArgs<ExtArgs>
            result: $Utils.Optional<HinoGroupByOutputType>[]
          }
          count: {
            args: Prisma.HinoCountArgs<ExtArgs>
            result: $Utils.Optional<HinoCountAggregateOutputType> | number
          }
        }
      }
      LeituraBiblica: {
        payload: Prisma.$LeituraBiblicaPayload<ExtArgs>
        fields: Prisma.LeituraBiblicaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeituraBiblicaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeituraBiblicaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload>
          }
          findFirst: {
            args: Prisma.LeituraBiblicaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeituraBiblicaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload>
          }
          findMany: {
            args: Prisma.LeituraBiblicaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload>[]
          }
          create: {
            args: Prisma.LeituraBiblicaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload>
          }
          createMany: {
            args: Prisma.LeituraBiblicaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeituraBiblicaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload>[]
          }
          delete: {
            args: Prisma.LeituraBiblicaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload>
          }
          update: {
            args: Prisma.LeituraBiblicaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload>
          }
          deleteMany: {
            args: Prisma.LeituraBiblicaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeituraBiblicaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeituraBiblicaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload>[]
          }
          upsert: {
            args: Prisma.LeituraBiblicaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeituraBiblicaPayload>
          }
          aggregate: {
            args: Prisma.LeituraBiblicaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeituraBiblica>
          }
          groupBy: {
            args: Prisma.LeituraBiblicaGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeituraBiblicaGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeituraBiblicaCountArgs<ExtArgs>
            result: $Utils.Optional<LeituraBiblicaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    live?: LiveOmit
    leitura?: LeituraOmit
    pedidoOracao?: PedidoOracaoOmit
    viewerSession?: ViewerSessionOmit
    cargo?: CargoOmit
    local?: LocalOmit
    culto?: CultoOmit
    reuniao?: ReuniaoOmit
    ensaio?: EnsaioOmit
    evento?: EventoOmit
    mensagem?: MensagemOmit
    hino?: HinoOmit
    leituraBiblica?: LeituraBiblicaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    cultosComoPastor: number
    cultosComoObreiro: number
    cultosComoAuxiliar: number
    cultosComoLiderCantico: number
    cultosComoVocal: number
    reunioesResponsavel: number
    ensaiosResponsavel: number
    participaEnsaios: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cultosComoPastor?: boolean | UserCountOutputTypeCountCultosComoPastorArgs
    cultosComoObreiro?: boolean | UserCountOutputTypeCountCultosComoObreiroArgs
    cultosComoAuxiliar?: boolean | UserCountOutputTypeCountCultosComoAuxiliarArgs
    cultosComoLiderCantico?: boolean | UserCountOutputTypeCountCultosComoLiderCanticoArgs
    cultosComoVocal?: boolean | UserCountOutputTypeCountCultosComoVocalArgs
    reunioesResponsavel?: boolean | UserCountOutputTypeCountReunioesResponsavelArgs
    ensaiosResponsavel?: boolean | UserCountOutputTypeCountEnsaiosResponsavelArgs
    participaEnsaios?: boolean | UserCountOutputTypeCountParticipaEnsaiosArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCultosComoPastorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCultosComoObreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCultosComoAuxiliarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCultosComoLiderCanticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCultosComoVocalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReunioesResponsavelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReuniaoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnsaiosResponsavelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnsaioWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParticipaEnsaiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnsaioWhereInput
  }


  /**
   * Count Type LiveCountOutputType
   */

  export type LiveCountOutputType = {
    leituras: number
    pedidosOracao: number
    viewerSessions: number
  }

  export type LiveCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leituras?: boolean | LiveCountOutputTypeCountLeiturasArgs
    pedidosOracao?: boolean | LiveCountOutputTypeCountPedidosOracaoArgs
    viewerSessions?: boolean | LiveCountOutputTypeCountViewerSessionsArgs
  }

  // Custom InputTypes
  /**
   * LiveCountOutputType without action
   */
  export type LiveCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveCountOutputType
     */
    select?: LiveCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LiveCountOutputType without action
   */
  export type LiveCountOutputTypeCountLeiturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeituraWhereInput
  }

  /**
   * LiveCountOutputType without action
   */
  export type LiveCountOutputTypeCountPedidosOracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoOracaoWhereInput
  }

  /**
   * LiveCountOutputType without action
   */
  export type LiveCountOutputTypeCountViewerSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewerSessionWhereInput
  }


  /**
   * Count Type CargoCountOutputType
   */

  export type CargoCountOutputType = {
    users: number
  }

  export type CargoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CargoCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * CargoCountOutputType without action
   */
  export type CargoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CargoCountOutputType
     */
    select?: CargoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CargoCountOutputType without action
   */
  export type CargoCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type LocalCountOutputType
   */

  export type LocalCountOutputType = {
    cultos: number
    reunioes: number
    ensaios: number
    eventos: number
  }

  export type LocalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cultos?: boolean | LocalCountOutputTypeCountCultosArgs
    reunioes?: boolean | LocalCountOutputTypeCountReunioesArgs
    ensaios?: boolean | LocalCountOutputTypeCountEnsaiosArgs
    eventos?: boolean | LocalCountOutputTypeCountEventosArgs
  }

  // Custom InputTypes
  /**
   * LocalCountOutputType without action
   */
  export type LocalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalCountOutputType
     */
    select?: LocalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocalCountOutputType without action
   */
  export type LocalCountOutputTypeCountCultosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultoWhereInput
  }

  /**
   * LocalCountOutputType without action
   */
  export type LocalCountOutputTypeCountReunioesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReuniaoWhereInput
  }

  /**
   * LocalCountOutputType without action
   */
  export type LocalCountOutputTypeCountEnsaiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnsaioWhereInput
  }

  /**
   * LocalCountOutputType without action
   */
  export type LocalCountOutputTypeCountEventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoWhereInput
  }


  /**
   * Count Type CultoCountOutputType
   */

  export type CultoCountOutputType = {
    auxiliares: number
    vocal: number
    hinos: number
    mensagens: number
    leituras: number
  }

  export type CultoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auxiliares?: boolean | CultoCountOutputTypeCountAuxiliaresArgs
    vocal?: boolean | CultoCountOutputTypeCountVocalArgs
    hinos?: boolean | CultoCountOutputTypeCountHinosArgs
    mensagens?: boolean | CultoCountOutputTypeCountMensagensArgs
    leituras?: boolean | CultoCountOutputTypeCountLeiturasArgs
  }

  // Custom InputTypes
  /**
   * CultoCountOutputType without action
   */
  export type CultoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CultoCountOutputType
     */
    select?: CultoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CultoCountOutputType without action
   */
  export type CultoCountOutputTypeCountAuxiliaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CultoCountOutputType without action
   */
  export type CultoCountOutputTypeCountVocalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CultoCountOutputType without action
   */
  export type CultoCountOutputTypeCountHinosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HinoWhereInput
  }

  /**
   * CultoCountOutputType without action
   */
  export type CultoCountOutputTypeCountMensagensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MensagemWhereInput
  }

  /**
   * CultoCountOutputType without action
   */
  export type CultoCountOutputTypeCountLeiturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeituraBiblicaWhereInput
  }


  /**
   * Count Type EnsaioCountOutputType
   */

  export type EnsaioCountOutputType = {
    participantes: number
    hinos: number
  }

  export type EnsaioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participantes?: boolean | EnsaioCountOutputTypeCountParticipantesArgs
    hinos?: boolean | EnsaioCountOutputTypeCountHinosArgs
  }

  // Custom InputTypes
  /**
   * EnsaioCountOutputType without action
   */
  export type EnsaioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnsaioCountOutputType
     */
    select?: EnsaioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnsaioCountOutputType without action
   */
  export type EnsaioCountOutputTypeCountParticipantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * EnsaioCountOutputType without action
   */
  export type EnsaioCountOutputTypeCountHinosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HinoWhereInput
  }


  /**
   * Count Type MensagemCountOutputType
   */

  export type MensagemCountOutputType = {
    cultos: number
  }

  export type MensagemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cultos?: boolean | MensagemCountOutputTypeCountCultosArgs
  }

  // Custom InputTypes
  /**
   * MensagemCountOutputType without action
   */
  export type MensagemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MensagemCountOutputType
     */
    select?: MensagemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MensagemCountOutputType without action
   */
  export type MensagemCountOutputTypeCountCultosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultoWhereInput
  }


  /**
   * Count Type HinoCountOutputType
   */

  export type HinoCountOutputType = {
    cultos: number
    ensaios: number
  }

  export type HinoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cultos?: boolean | HinoCountOutputTypeCountCultosArgs
    ensaios?: boolean | HinoCountOutputTypeCountEnsaiosArgs
  }

  // Custom InputTypes
  /**
   * HinoCountOutputType without action
   */
  export type HinoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HinoCountOutputType
     */
    select?: HinoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HinoCountOutputType without action
   */
  export type HinoCountOutputTypeCountCultosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultoWhereInput
  }

  /**
   * HinoCountOutputType without action
   */
  export type HinoCountOutputTypeCountEnsaiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnsaioWhereInput
  }


  /**
   * Count Type LeituraBiblicaCountOutputType
   */

  export type LeituraBiblicaCountOutputType = {
    cultos: number
  }

  export type LeituraBiblicaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cultos?: boolean | LeituraBiblicaCountOutputTypeCountCultosArgs
  }

  // Custom InputTypes
  /**
   * LeituraBiblicaCountOutputType without action
   */
  export type LeituraBiblicaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblicaCountOutputType
     */
    select?: LeituraBiblicaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeituraBiblicaCountOutputType without action
   */
  export type LeituraBiblicaCountOutputTypeCountCultosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    cargoId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    cargoId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    name: string | null
    email: string | null
    cargoId: number | null
    online: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    name: string | null
    email: string | null
    cargoId: number | null
    online: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    name: number
    email: number
    cargoId: number
    online: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    cargoId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    cargoId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    email?: true
    cargoId?: true
    online?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    email?: true
    cargoId?: true
    online?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    name?: true
    email?: true
    cargoId?: true
    online?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    name: string | null
    email: string | null
    cargoId: number | null
    online: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    cargoId?: boolean
    online?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cargo?: boolean | User$cargoArgs<ExtArgs>
    cultosComoPastor?: boolean | User$cultosComoPastorArgs<ExtArgs>
    cultosComoObreiro?: boolean | User$cultosComoObreiroArgs<ExtArgs>
    cultosComoAuxiliar?: boolean | User$cultosComoAuxiliarArgs<ExtArgs>
    cultosComoLiderCantico?: boolean | User$cultosComoLiderCanticoArgs<ExtArgs>
    cultosComoVocal?: boolean | User$cultosComoVocalArgs<ExtArgs>
    reunioesResponsavel?: boolean | User$reunioesResponsavelArgs<ExtArgs>
    ensaiosResponsavel?: boolean | User$ensaiosResponsavelArgs<ExtArgs>
    participaEnsaios?: boolean | User$participaEnsaiosArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    cargoId?: boolean
    online?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cargo?: boolean | User$cargoArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    cargoId?: boolean
    online?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cargo?: boolean | User$cargoArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    cargoId?: boolean
    online?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "name" | "email" | "cargoId" | "online" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cargo?: boolean | User$cargoArgs<ExtArgs>
    cultosComoPastor?: boolean | User$cultosComoPastorArgs<ExtArgs>
    cultosComoObreiro?: boolean | User$cultosComoObreiroArgs<ExtArgs>
    cultosComoAuxiliar?: boolean | User$cultosComoAuxiliarArgs<ExtArgs>
    cultosComoLiderCantico?: boolean | User$cultosComoLiderCanticoArgs<ExtArgs>
    cultosComoVocal?: boolean | User$cultosComoVocalArgs<ExtArgs>
    reunioesResponsavel?: boolean | User$reunioesResponsavelArgs<ExtArgs>
    ensaiosResponsavel?: boolean | User$ensaiosResponsavelArgs<ExtArgs>
    participaEnsaios?: boolean | User$participaEnsaiosArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cargo?: boolean | User$cargoArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cargo?: boolean | User$cargoArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      cargo: Prisma.$CargoPayload<ExtArgs> | null
      cultosComoPastor: Prisma.$CultoPayload<ExtArgs>[]
      cultosComoObreiro: Prisma.$CultoPayload<ExtArgs>[]
      cultosComoAuxiliar: Prisma.$CultoPayload<ExtArgs>[]
      cultosComoLiderCantico: Prisma.$CultoPayload<ExtArgs>[]
      cultosComoVocal: Prisma.$CultoPayload<ExtArgs>[]
      reunioesResponsavel: Prisma.$ReuniaoPayload<ExtArgs>[]
      ensaiosResponsavel: Prisma.$EnsaioPayload<ExtArgs>[]
      participaEnsaios: Prisma.$EnsaioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      name: string | null
      email: string | null
      cargoId: number | null
      online: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cargo<T extends User$cargoArgs<ExtArgs> = {}>(args?: Subset<T, User$cargoArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    cultosComoPastor<T extends User$cultosComoPastorArgs<ExtArgs> = {}>(args?: Subset<T, User$cultosComoPastorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    cultosComoObreiro<T extends User$cultosComoObreiroArgs<ExtArgs> = {}>(args?: Subset<T, User$cultosComoObreiroArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    cultosComoAuxiliar<T extends User$cultosComoAuxiliarArgs<ExtArgs> = {}>(args?: Subset<T, User$cultosComoAuxiliarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    cultosComoLiderCantico<T extends User$cultosComoLiderCanticoArgs<ExtArgs> = {}>(args?: Subset<T, User$cultosComoLiderCanticoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    cultosComoVocal<T extends User$cultosComoVocalArgs<ExtArgs> = {}>(args?: Subset<T, User$cultosComoVocalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    reunioesResponsavel<T extends User$reunioesResponsavelArgs<ExtArgs> = {}>(args?: Subset<T, User$reunioesResponsavelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ensaiosResponsavel<T extends User$ensaiosResponsavelArgs<ExtArgs> = {}>(args?: Subset<T, User$ensaiosResponsavelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    participaEnsaios<T extends User$participaEnsaiosArgs<ExtArgs> = {}>(args?: Subset<T, User$participaEnsaiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly cargoId: FieldRef<"User", 'Int'>
    readonly online: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.cargo
   */
  export type User$cargoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    where?: CargoWhereInput
  }

  /**
   * User.cultosComoPastor
   */
  export type User$cultosComoPastorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    where?: CultoWhereInput
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    cursor?: CultoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * User.cultosComoObreiro
   */
  export type User$cultosComoObreiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    where?: CultoWhereInput
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    cursor?: CultoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * User.cultosComoAuxiliar
   */
  export type User$cultosComoAuxiliarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    where?: CultoWhereInput
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    cursor?: CultoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * User.cultosComoLiderCantico
   */
  export type User$cultosComoLiderCanticoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    where?: CultoWhereInput
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    cursor?: CultoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * User.cultosComoVocal
   */
  export type User$cultosComoVocalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    where?: CultoWhereInput
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    cursor?: CultoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * User.reunioesResponsavel
   */
  export type User$reunioesResponsavelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    where?: ReuniaoWhereInput
    orderBy?: ReuniaoOrderByWithRelationInput | ReuniaoOrderByWithRelationInput[]
    cursor?: ReuniaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReuniaoScalarFieldEnum | ReuniaoScalarFieldEnum[]
  }

  /**
   * User.ensaiosResponsavel
   */
  export type User$ensaiosResponsavelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    where?: EnsaioWhereInput
    orderBy?: EnsaioOrderByWithRelationInput | EnsaioOrderByWithRelationInput[]
    cursor?: EnsaioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnsaioScalarFieldEnum | EnsaioScalarFieldEnum[]
  }

  /**
   * User.participaEnsaios
   */
  export type User$participaEnsaiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    where?: EnsaioWhereInput
    orderBy?: EnsaioOrderByWithRelationInput | EnsaioOrderByWithRelationInput[]
    cursor?: EnsaioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnsaioScalarFieldEnum | EnsaioScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Live
   */

  export type AggregateLive = {
    _count: LiveCountAggregateOutputType | null
    _avg: LiveAvgAggregateOutputType | null
    _sum: LiveSumAggregateOutputType | null
    _min: LiveMinAggregateOutputType | null
    _max: LiveMaxAggregateOutputType | null
  }

  export type LiveAvgAggregateOutputType = {
    id: number | null
    viewers: number | null
  }

  export type LiveSumAggregateOutputType = {
    id: number | null
    viewers: number | null
  }

  export type LiveMinAggregateOutputType = {
    id: number | null
    youtubeId: string | null
    title: string | null
    viewers: number | null
    isActive: boolean | null
    ofertaAtiva: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LiveMaxAggregateOutputType = {
    id: number | null
    youtubeId: string | null
    title: string | null
    viewers: number | null
    isActive: boolean | null
    ofertaAtiva: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LiveCountAggregateOutputType = {
    id: number
    youtubeId: number
    title: number
    viewers: number
    isActive: number
    ofertaAtiva: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LiveAvgAggregateInputType = {
    id?: true
    viewers?: true
  }

  export type LiveSumAggregateInputType = {
    id?: true
    viewers?: true
  }

  export type LiveMinAggregateInputType = {
    id?: true
    youtubeId?: true
    title?: true
    viewers?: true
    isActive?: true
    ofertaAtiva?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LiveMaxAggregateInputType = {
    id?: true
    youtubeId?: true
    title?: true
    viewers?: true
    isActive?: true
    ofertaAtiva?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LiveCountAggregateInputType = {
    id?: true
    youtubeId?: true
    title?: true
    viewers?: true
    isActive?: true
    ofertaAtiva?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Live to aggregate.
     */
    where?: LiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lives to fetch.
     */
    orderBy?: LiveOrderByWithRelationInput | LiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lives
    **/
    _count?: true | LiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiveMaxAggregateInputType
  }

  export type GetLiveAggregateType<T extends LiveAggregateArgs> = {
        [P in keyof T & keyof AggregateLive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLive[P]>
      : GetScalarType<T[P], AggregateLive[P]>
  }




  export type LiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiveWhereInput
    orderBy?: LiveOrderByWithAggregationInput | LiveOrderByWithAggregationInput[]
    by: LiveScalarFieldEnum[] | LiveScalarFieldEnum
    having?: LiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiveCountAggregateInputType | true
    _avg?: LiveAvgAggregateInputType
    _sum?: LiveSumAggregateInputType
    _min?: LiveMinAggregateInputType
    _max?: LiveMaxAggregateInputType
  }

  export type LiveGroupByOutputType = {
    id: number
    youtubeId: string
    title: string
    viewers: number
    isActive: boolean
    ofertaAtiva: boolean
    createdAt: Date
    updatedAt: Date
    _count: LiveCountAggregateOutputType | null
    _avg: LiveAvgAggregateOutputType | null
    _sum: LiveSumAggregateOutputType | null
    _min: LiveMinAggregateOutputType | null
    _max: LiveMaxAggregateOutputType | null
  }

  type GetLiveGroupByPayload<T extends LiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiveGroupByOutputType[P]>
            : GetScalarType<T[P], LiveGroupByOutputType[P]>
        }
      >
    >


  export type LiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    youtubeId?: boolean
    title?: boolean
    viewers?: boolean
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leituras?: boolean | Live$leiturasArgs<ExtArgs>
    pedidosOracao?: boolean | Live$pedidosOracaoArgs<ExtArgs>
    viewerSessions?: boolean | Live$viewerSessionsArgs<ExtArgs>
    _count?: boolean | LiveCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["live"]>

  export type LiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    youtubeId?: boolean
    title?: boolean
    viewers?: boolean
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["live"]>

  export type LiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    youtubeId?: boolean
    title?: boolean
    viewers?: boolean
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["live"]>

  export type LiveSelectScalar = {
    id?: boolean
    youtubeId?: boolean
    title?: boolean
    viewers?: boolean
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "youtubeId" | "title" | "viewers" | "isActive" | "ofertaAtiva" | "createdAt" | "updatedAt", ExtArgs["result"]["live"]>
  export type LiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leituras?: boolean | Live$leiturasArgs<ExtArgs>
    pedidosOracao?: boolean | Live$pedidosOracaoArgs<ExtArgs>
    viewerSessions?: boolean | Live$viewerSessionsArgs<ExtArgs>
    _count?: boolean | LiveCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Live"
    objects: {
      leituras: Prisma.$LeituraPayload<ExtArgs>[]
      pedidosOracao: Prisma.$PedidoOracaoPayload<ExtArgs>[]
      viewerSessions: Prisma.$ViewerSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      youtubeId: string
      title: string
      viewers: number
      isActive: boolean
      ofertaAtiva: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["live"]>
    composites: {}
  }

  type LiveGetPayload<S extends boolean | null | undefined | LiveDefaultArgs> = $Result.GetResult<Prisma.$LivePayload, S>

  type LiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiveCountAggregateInputType | true
    }

  export interface LiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Live'], meta: { name: 'Live' } }
    /**
     * Find zero or one Live that matches the filter.
     * @param {LiveFindUniqueArgs} args - Arguments to find a Live
     * @example
     * // Get one Live
     * const live = await prisma.live.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiveFindUniqueArgs>(args: SelectSubset<T, LiveFindUniqueArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Live that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiveFindUniqueOrThrowArgs} args - Arguments to find a Live
     * @example
     * // Get one Live
     * const live = await prisma.live.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiveFindUniqueOrThrowArgs>(args: SelectSubset<T, LiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Live that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveFindFirstArgs} args - Arguments to find a Live
     * @example
     * // Get one Live
     * const live = await prisma.live.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiveFindFirstArgs>(args?: SelectSubset<T, LiveFindFirstArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Live that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveFindFirstOrThrowArgs} args - Arguments to find a Live
     * @example
     * // Get one Live
     * const live = await prisma.live.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiveFindFirstOrThrowArgs>(args?: SelectSubset<T, LiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Lives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lives
     * const lives = await prisma.live.findMany()
     * 
     * // Get first 10 Lives
     * const lives = await prisma.live.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liveWithIdOnly = await prisma.live.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiveFindManyArgs>(args?: SelectSubset<T, LiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Live.
     * @param {LiveCreateArgs} args - Arguments to create a Live.
     * @example
     * // Create one Live
     * const Live = await prisma.live.create({
     *   data: {
     *     // ... data to create a Live
     *   }
     * })
     * 
     */
    create<T extends LiveCreateArgs>(args: SelectSubset<T, LiveCreateArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Lives.
     * @param {LiveCreateManyArgs} args - Arguments to create many Lives.
     * @example
     * // Create many Lives
     * const live = await prisma.live.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiveCreateManyArgs>(args?: SelectSubset<T, LiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lives and returns the data saved in the database.
     * @param {LiveCreateManyAndReturnArgs} args - Arguments to create many Lives.
     * @example
     * // Create many Lives
     * const live = await prisma.live.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lives and only return the `id`
     * const liveWithIdOnly = await prisma.live.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiveCreateManyAndReturnArgs>(args?: SelectSubset<T, LiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Live.
     * @param {LiveDeleteArgs} args - Arguments to delete one Live.
     * @example
     * // Delete one Live
     * const Live = await prisma.live.delete({
     *   where: {
     *     // ... filter to delete one Live
     *   }
     * })
     * 
     */
    delete<T extends LiveDeleteArgs>(args: SelectSubset<T, LiveDeleteArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Live.
     * @param {LiveUpdateArgs} args - Arguments to update one Live.
     * @example
     * // Update one Live
     * const live = await prisma.live.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiveUpdateArgs>(args: SelectSubset<T, LiveUpdateArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Lives.
     * @param {LiveDeleteManyArgs} args - Arguments to filter Lives to delete.
     * @example
     * // Delete a few Lives
     * const { count } = await prisma.live.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiveDeleteManyArgs>(args?: SelectSubset<T, LiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lives
     * const live = await prisma.live.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiveUpdateManyArgs>(args: SelectSubset<T, LiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lives and returns the data updated in the database.
     * @param {LiveUpdateManyAndReturnArgs} args - Arguments to update many Lives.
     * @example
     * // Update many Lives
     * const live = await prisma.live.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lives and only return the `id`
     * const liveWithIdOnly = await prisma.live.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LiveUpdateManyAndReturnArgs>(args: SelectSubset<T, LiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Live.
     * @param {LiveUpsertArgs} args - Arguments to update or create a Live.
     * @example
     * // Update or create a Live
     * const live = await prisma.live.upsert({
     *   create: {
     *     // ... data to create a Live
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Live we want to update
     *   }
     * })
     */
    upsert<T extends LiveUpsertArgs>(args: SelectSubset<T, LiveUpsertArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Lives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveCountArgs} args - Arguments to filter Lives to count.
     * @example
     * // Count the number of Lives
     * const count = await prisma.live.count({
     *   where: {
     *     // ... the filter for the Lives we want to count
     *   }
     * })
    **/
    count<T extends LiveCountArgs>(
      args?: Subset<T, LiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Live.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiveAggregateArgs>(args: Subset<T, LiveAggregateArgs>): Prisma.PrismaPromise<GetLiveAggregateType<T>>

    /**
     * Group by Live.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiveGroupByArgs['orderBy'] }
        : { orderBy?: LiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Live model
   */
  readonly fields: LiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Live.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    leituras<T extends Live$leiturasArgs<ExtArgs> = {}>(args?: Subset<T, Live$leiturasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    pedidosOracao<T extends Live$pedidosOracaoArgs<ExtArgs> = {}>(args?: Subset<T, Live$pedidosOracaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    viewerSessions<T extends Live$viewerSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Live$viewerSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Live model
   */ 
  interface LiveFieldRefs {
    readonly id: FieldRef<"Live", 'Int'>
    readonly youtubeId: FieldRef<"Live", 'String'>
    readonly title: FieldRef<"Live", 'String'>
    readonly viewers: FieldRef<"Live", 'Int'>
    readonly isActive: FieldRef<"Live", 'Boolean'>
    readonly ofertaAtiva: FieldRef<"Live", 'Boolean'>
    readonly createdAt: FieldRef<"Live", 'DateTime'>
    readonly updatedAt: FieldRef<"Live", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Live findUnique
   */
  export type LiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveInclude<ExtArgs> | null
    /**
     * Filter, which Live to fetch.
     */
    where: LiveWhereUniqueInput
  }

  /**
   * Live findUniqueOrThrow
   */
  export type LiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveInclude<ExtArgs> | null
    /**
     * Filter, which Live to fetch.
     */
    where: LiveWhereUniqueInput
  }

  /**
   * Live findFirst
   */
  export type LiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveInclude<ExtArgs> | null
    /**
     * Filter, which Live to fetch.
     */
    where?: LiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lives to fetch.
     */
    orderBy?: LiveOrderByWithRelationInput | LiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lives.
     */
    cursor?: LiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lives.
     */
    distinct?: LiveScalarFieldEnum | LiveScalarFieldEnum[]
  }

  /**
   * Live findFirstOrThrow
   */
  export type LiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveInclude<ExtArgs> | null
    /**
     * Filter, which Live to fetch.
     */
    where?: LiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lives to fetch.
     */
    orderBy?: LiveOrderByWithRelationInput | LiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lives.
     */
    cursor?: LiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lives.
     */
    distinct?: LiveScalarFieldEnum | LiveScalarFieldEnum[]
  }

  /**
   * Live findMany
   */
  export type LiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveInclude<ExtArgs> | null
    /**
     * Filter, which Lives to fetch.
     */
    where?: LiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lives to fetch.
     */
    orderBy?: LiveOrderByWithRelationInput | LiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lives.
     */
    cursor?: LiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lives.
     */
    skip?: number
    distinct?: LiveScalarFieldEnum | LiveScalarFieldEnum[]
  }

  /**
   * Live create
   */
  export type LiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveInclude<ExtArgs> | null
    /**
     * The data needed to create a Live.
     */
    data: XOR<LiveCreateInput, LiveUncheckedCreateInput>
  }

  /**
   * Live createMany
   */
  export type LiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lives.
     */
    data: LiveCreateManyInput | LiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Live createManyAndReturn
   */
  export type LiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * The data used to create many Lives.
     */
    data: LiveCreateManyInput | LiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Live update
   */
  export type LiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveInclude<ExtArgs> | null
    /**
     * The data needed to update a Live.
     */
    data: XOR<LiveUpdateInput, LiveUncheckedUpdateInput>
    /**
     * Choose, which Live to update.
     */
    where: LiveWhereUniqueInput
  }

  /**
   * Live updateMany
   */
  export type LiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lives.
     */
    data: XOR<LiveUpdateManyMutationInput, LiveUncheckedUpdateManyInput>
    /**
     * Filter which Lives to update
     */
    where?: LiveWhereInput
  }

  /**
   * Live updateManyAndReturn
   */
  export type LiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * The data used to update Lives.
     */
    data: XOR<LiveUpdateManyMutationInput, LiveUncheckedUpdateManyInput>
    /**
     * Filter which Lives to update
     */
    where?: LiveWhereInput
  }

  /**
   * Live upsert
   */
  export type LiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveInclude<ExtArgs> | null
    /**
     * The filter to search for the Live to update in case it exists.
     */
    where: LiveWhereUniqueInput
    /**
     * In case the Live found by the `where` argument doesn't exist, create a new Live with this data.
     */
    create: XOR<LiveCreateInput, LiveUncheckedCreateInput>
    /**
     * In case the Live was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiveUpdateInput, LiveUncheckedUpdateInput>
  }

  /**
   * Live delete
   */
  export type LiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveInclude<ExtArgs> | null
    /**
     * Filter which Live to delete.
     */
    where: LiveWhereUniqueInput
  }

  /**
   * Live deleteMany
   */
  export type LiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lives to delete
     */
    where?: LiveWhereInput
  }

  /**
   * Live.leituras
   */
  export type Live$leiturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
    where?: LeituraWhereInput
    orderBy?: LeituraOrderByWithRelationInput | LeituraOrderByWithRelationInput[]
    cursor?: LeituraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeituraScalarFieldEnum | LeituraScalarFieldEnum[]
  }

  /**
   * Live.pedidosOracao
   */
  export type Live$pedidosOracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
    where?: PedidoOracaoWhereInput
    orderBy?: PedidoOracaoOrderByWithRelationInput | PedidoOracaoOrderByWithRelationInput[]
    cursor?: PedidoOracaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PedidoOracaoScalarFieldEnum | PedidoOracaoScalarFieldEnum[]
  }

  /**
   * Live.viewerSessions
   */
  export type Live$viewerSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
    where?: ViewerSessionWhereInput
    orderBy?: ViewerSessionOrderByWithRelationInput | ViewerSessionOrderByWithRelationInput[]
    cursor?: ViewerSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewerSessionScalarFieldEnum | ViewerSessionScalarFieldEnum[]
  }

  /**
   * Live without action
   */
  export type LiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Live
     */
    select?: LiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Live
     */
    omit?: LiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveInclude<ExtArgs> | null
  }


  /**
   * Model Leitura
   */

  export type AggregateLeitura = {
    _count: LeituraCountAggregateOutputType | null
    _avg: LeituraAvgAggregateOutputType | null
    _sum: LeituraSumAggregateOutputType | null
    _min: LeituraMinAggregateOutputType | null
    _max: LeituraMaxAggregateOutputType | null
  }

  export type LeituraAvgAggregateOutputType = {
    id: number | null
    liveId: number | null
  }

  export type LeituraSumAggregateOutputType = {
    id: number | null
    liveId: number | null
  }

  export type LeituraMinAggregateOutputType = {
    id: number | null
    texto: string | null
    minuto: string | null
    liveId: number | null
    createdAt: Date | null
  }

  export type LeituraMaxAggregateOutputType = {
    id: number | null
    texto: string | null
    minuto: string | null
    liveId: number | null
    createdAt: Date | null
  }

  export type LeituraCountAggregateOutputType = {
    id: number
    texto: number
    minuto: number
    liveId: number
    createdAt: number
    _all: number
  }


  export type LeituraAvgAggregateInputType = {
    id?: true
    liveId?: true
  }

  export type LeituraSumAggregateInputType = {
    id?: true
    liveId?: true
  }

  export type LeituraMinAggregateInputType = {
    id?: true
    texto?: true
    minuto?: true
    liveId?: true
    createdAt?: true
  }

  export type LeituraMaxAggregateInputType = {
    id?: true
    texto?: true
    minuto?: true
    liveId?: true
    createdAt?: true
  }

  export type LeituraCountAggregateInputType = {
    id?: true
    texto?: true
    minuto?: true
    liveId?: true
    createdAt?: true
    _all?: true
  }

  export type LeituraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leitura to aggregate.
     */
    where?: LeituraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leituras to fetch.
     */
    orderBy?: LeituraOrderByWithRelationInput | LeituraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeituraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leituras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leituras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leituras
    **/
    _count?: true | LeituraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeituraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeituraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeituraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeituraMaxAggregateInputType
  }

  export type GetLeituraAggregateType<T extends LeituraAggregateArgs> = {
        [P in keyof T & keyof AggregateLeitura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeitura[P]>
      : GetScalarType<T[P], AggregateLeitura[P]>
  }




  export type LeituraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeituraWhereInput
    orderBy?: LeituraOrderByWithAggregationInput | LeituraOrderByWithAggregationInput[]
    by: LeituraScalarFieldEnum[] | LeituraScalarFieldEnum
    having?: LeituraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeituraCountAggregateInputType | true
    _avg?: LeituraAvgAggregateInputType
    _sum?: LeituraSumAggregateInputType
    _min?: LeituraMinAggregateInputType
    _max?: LeituraMaxAggregateInputType
  }

  export type LeituraGroupByOutputType = {
    id: number
    texto: string
    minuto: string
    liveId: number
    createdAt: Date
    _count: LeituraCountAggregateOutputType | null
    _avg: LeituraAvgAggregateOutputType | null
    _sum: LeituraSumAggregateOutputType | null
    _min: LeituraMinAggregateOutputType | null
    _max: LeituraMaxAggregateOutputType | null
  }

  type GetLeituraGroupByPayload<T extends LeituraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeituraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeituraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeituraGroupByOutputType[P]>
            : GetScalarType<T[P], LeituraGroupByOutputType[P]>
        }
      >
    >


  export type LeituraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    texto?: boolean
    minuto?: boolean
    liveId?: boolean
    createdAt?: boolean
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leitura"]>

  export type LeituraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    texto?: boolean
    minuto?: boolean
    liveId?: boolean
    createdAt?: boolean
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leitura"]>

  export type LeituraSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    texto?: boolean
    minuto?: boolean
    liveId?: boolean
    createdAt?: boolean
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leitura"]>

  export type LeituraSelectScalar = {
    id?: boolean
    texto?: boolean
    minuto?: boolean
    liveId?: boolean
    createdAt?: boolean
  }

  export type LeituraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "texto" | "minuto" | "liveId" | "createdAt", ExtArgs["result"]["leitura"]>
  export type LeituraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }
  export type LeituraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }
  export type LeituraIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }

  export type $LeituraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leitura"
    objects: {
      live: Prisma.$LivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      texto: string
      minuto: string
      liveId: number
      createdAt: Date
    }, ExtArgs["result"]["leitura"]>
    composites: {}
  }

  type LeituraGetPayload<S extends boolean | null | undefined | LeituraDefaultArgs> = $Result.GetResult<Prisma.$LeituraPayload, S>

  type LeituraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeituraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeituraCountAggregateInputType | true
    }

  export interface LeituraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leitura'], meta: { name: 'Leitura' } }
    /**
     * Find zero or one Leitura that matches the filter.
     * @param {LeituraFindUniqueArgs} args - Arguments to find a Leitura
     * @example
     * // Get one Leitura
     * const leitura = await prisma.leitura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeituraFindUniqueArgs>(args: SelectSubset<T, LeituraFindUniqueArgs<ExtArgs>>): Prisma__LeituraClient<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Leitura that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeituraFindUniqueOrThrowArgs} args - Arguments to find a Leitura
     * @example
     * // Get one Leitura
     * const leitura = await prisma.leitura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeituraFindUniqueOrThrowArgs>(args: SelectSubset<T, LeituraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeituraClient<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Leitura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraFindFirstArgs} args - Arguments to find a Leitura
     * @example
     * // Get one Leitura
     * const leitura = await prisma.leitura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeituraFindFirstArgs>(args?: SelectSubset<T, LeituraFindFirstArgs<ExtArgs>>): Prisma__LeituraClient<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Leitura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraFindFirstOrThrowArgs} args - Arguments to find a Leitura
     * @example
     * // Get one Leitura
     * const leitura = await prisma.leitura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeituraFindFirstOrThrowArgs>(args?: SelectSubset<T, LeituraFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeituraClient<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Leituras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leituras
     * const leituras = await prisma.leitura.findMany()
     * 
     * // Get first 10 Leituras
     * const leituras = await prisma.leitura.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leituraWithIdOnly = await prisma.leitura.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeituraFindManyArgs>(args?: SelectSubset<T, LeituraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Leitura.
     * @param {LeituraCreateArgs} args - Arguments to create a Leitura.
     * @example
     * // Create one Leitura
     * const Leitura = await prisma.leitura.create({
     *   data: {
     *     // ... data to create a Leitura
     *   }
     * })
     * 
     */
    create<T extends LeituraCreateArgs>(args: SelectSubset<T, LeituraCreateArgs<ExtArgs>>): Prisma__LeituraClient<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Leituras.
     * @param {LeituraCreateManyArgs} args - Arguments to create many Leituras.
     * @example
     * // Create many Leituras
     * const leitura = await prisma.leitura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeituraCreateManyArgs>(args?: SelectSubset<T, LeituraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leituras and returns the data saved in the database.
     * @param {LeituraCreateManyAndReturnArgs} args - Arguments to create many Leituras.
     * @example
     * // Create many Leituras
     * const leitura = await prisma.leitura.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leituras and only return the `id`
     * const leituraWithIdOnly = await prisma.leitura.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeituraCreateManyAndReturnArgs>(args?: SelectSubset<T, LeituraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Leitura.
     * @param {LeituraDeleteArgs} args - Arguments to delete one Leitura.
     * @example
     * // Delete one Leitura
     * const Leitura = await prisma.leitura.delete({
     *   where: {
     *     // ... filter to delete one Leitura
     *   }
     * })
     * 
     */
    delete<T extends LeituraDeleteArgs>(args: SelectSubset<T, LeituraDeleteArgs<ExtArgs>>): Prisma__LeituraClient<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Leitura.
     * @param {LeituraUpdateArgs} args - Arguments to update one Leitura.
     * @example
     * // Update one Leitura
     * const leitura = await prisma.leitura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeituraUpdateArgs>(args: SelectSubset<T, LeituraUpdateArgs<ExtArgs>>): Prisma__LeituraClient<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Leituras.
     * @param {LeituraDeleteManyArgs} args - Arguments to filter Leituras to delete.
     * @example
     * // Delete a few Leituras
     * const { count } = await prisma.leitura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeituraDeleteManyArgs>(args?: SelectSubset<T, LeituraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leituras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leituras
     * const leitura = await prisma.leitura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeituraUpdateManyArgs>(args: SelectSubset<T, LeituraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leituras and returns the data updated in the database.
     * @param {LeituraUpdateManyAndReturnArgs} args - Arguments to update many Leituras.
     * @example
     * // Update many Leituras
     * const leitura = await prisma.leitura.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leituras and only return the `id`
     * const leituraWithIdOnly = await prisma.leitura.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeituraUpdateManyAndReturnArgs>(args: SelectSubset<T, LeituraUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Leitura.
     * @param {LeituraUpsertArgs} args - Arguments to update or create a Leitura.
     * @example
     * // Update or create a Leitura
     * const leitura = await prisma.leitura.upsert({
     *   create: {
     *     // ... data to create a Leitura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leitura we want to update
     *   }
     * })
     */
    upsert<T extends LeituraUpsertArgs>(args: SelectSubset<T, LeituraUpsertArgs<ExtArgs>>): Prisma__LeituraClient<$Result.GetResult<Prisma.$LeituraPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Leituras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraCountArgs} args - Arguments to filter Leituras to count.
     * @example
     * // Count the number of Leituras
     * const count = await prisma.leitura.count({
     *   where: {
     *     // ... the filter for the Leituras we want to count
     *   }
     * })
    **/
    count<T extends LeituraCountArgs>(
      args?: Subset<T, LeituraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeituraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leitura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeituraAggregateArgs>(args: Subset<T, LeituraAggregateArgs>): Prisma.PrismaPromise<GetLeituraAggregateType<T>>

    /**
     * Group by Leitura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeituraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeituraGroupByArgs['orderBy'] }
        : { orderBy?: LeituraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeituraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeituraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leitura model
   */
  readonly fields: LeituraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leitura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeituraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    live<T extends LiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiveDefaultArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leitura model
   */ 
  interface LeituraFieldRefs {
    readonly id: FieldRef<"Leitura", 'Int'>
    readonly texto: FieldRef<"Leitura", 'String'>
    readonly minuto: FieldRef<"Leitura", 'String'>
    readonly liveId: FieldRef<"Leitura", 'Int'>
    readonly createdAt: FieldRef<"Leitura", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leitura findUnique
   */
  export type LeituraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
    /**
     * Filter, which Leitura to fetch.
     */
    where: LeituraWhereUniqueInput
  }

  /**
   * Leitura findUniqueOrThrow
   */
  export type LeituraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
    /**
     * Filter, which Leitura to fetch.
     */
    where: LeituraWhereUniqueInput
  }

  /**
   * Leitura findFirst
   */
  export type LeituraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
    /**
     * Filter, which Leitura to fetch.
     */
    where?: LeituraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leituras to fetch.
     */
    orderBy?: LeituraOrderByWithRelationInput | LeituraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leituras.
     */
    cursor?: LeituraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leituras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leituras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leituras.
     */
    distinct?: LeituraScalarFieldEnum | LeituraScalarFieldEnum[]
  }

  /**
   * Leitura findFirstOrThrow
   */
  export type LeituraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
    /**
     * Filter, which Leitura to fetch.
     */
    where?: LeituraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leituras to fetch.
     */
    orderBy?: LeituraOrderByWithRelationInput | LeituraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leituras.
     */
    cursor?: LeituraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leituras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leituras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leituras.
     */
    distinct?: LeituraScalarFieldEnum | LeituraScalarFieldEnum[]
  }

  /**
   * Leitura findMany
   */
  export type LeituraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
    /**
     * Filter, which Leituras to fetch.
     */
    where?: LeituraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leituras to fetch.
     */
    orderBy?: LeituraOrderByWithRelationInput | LeituraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leituras.
     */
    cursor?: LeituraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leituras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leituras.
     */
    skip?: number
    distinct?: LeituraScalarFieldEnum | LeituraScalarFieldEnum[]
  }

  /**
   * Leitura create
   */
  export type LeituraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
    /**
     * The data needed to create a Leitura.
     */
    data: XOR<LeituraCreateInput, LeituraUncheckedCreateInput>
  }

  /**
   * Leitura createMany
   */
  export type LeituraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leituras.
     */
    data: LeituraCreateManyInput | LeituraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leitura createManyAndReturn
   */
  export type LeituraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * The data used to create many Leituras.
     */
    data: LeituraCreateManyInput | LeituraCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leitura update
   */
  export type LeituraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
    /**
     * The data needed to update a Leitura.
     */
    data: XOR<LeituraUpdateInput, LeituraUncheckedUpdateInput>
    /**
     * Choose, which Leitura to update.
     */
    where: LeituraWhereUniqueInput
  }

  /**
   * Leitura updateMany
   */
  export type LeituraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leituras.
     */
    data: XOR<LeituraUpdateManyMutationInput, LeituraUncheckedUpdateManyInput>
    /**
     * Filter which Leituras to update
     */
    where?: LeituraWhereInput
  }

  /**
   * Leitura updateManyAndReturn
   */
  export type LeituraUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * The data used to update Leituras.
     */
    data: XOR<LeituraUpdateManyMutationInput, LeituraUncheckedUpdateManyInput>
    /**
     * Filter which Leituras to update
     */
    where?: LeituraWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leitura upsert
   */
  export type LeituraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
    /**
     * The filter to search for the Leitura to update in case it exists.
     */
    where: LeituraWhereUniqueInput
    /**
     * In case the Leitura found by the `where` argument doesn't exist, create a new Leitura with this data.
     */
    create: XOR<LeituraCreateInput, LeituraUncheckedCreateInput>
    /**
     * In case the Leitura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeituraUpdateInput, LeituraUncheckedUpdateInput>
  }

  /**
   * Leitura delete
   */
  export type LeituraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
    /**
     * Filter which Leitura to delete.
     */
    where: LeituraWhereUniqueInput
  }

  /**
   * Leitura deleteMany
   */
  export type LeituraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leituras to delete
     */
    where?: LeituraWhereInput
  }

  /**
   * Leitura without action
   */
  export type LeituraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leitura
     */
    select?: LeituraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leitura
     */
    omit?: LeituraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraInclude<ExtArgs> | null
  }


  /**
   * Model PedidoOracao
   */

  export type AggregatePedidoOracao = {
    _count: PedidoOracaoCountAggregateOutputType | null
    _avg: PedidoOracaoAvgAggregateOutputType | null
    _sum: PedidoOracaoSumAggregateOutputType | null
    _min: PedidoOracaoMinAggregateOutputType | null
    _max: PedidoOracaoMaxAggregateOutputType | null
  }

  export type PedidoOracaoAvgAggregateOutputType = {
    id: number | null
    liveId: number | null
  }

  export type PedidoOracaoSumAggregateOutputType = {
    id: number | null
    liveId: number | null
  }

  export type PedidoOracaoMinAggregateOutputType = {
    id: number | null
    para: string | null
    motivo: string | null
    liveId: number | null
    createdAt: Date | null
  }

  export type PedidoOracaoMaxAggregateOutputType = {
    id: number | null
    para: string | null
    motivo: string | null
    liveId: number | null
    createdAt: Date | null
  }

  export type PedidoOracaoCountAggregateOutputType = {
    id: number
    para: number
    motivo: number
    liveId: number
    createdAt: number
    _all: number
  }


  export type PedidoOracaoAvgAggregateInputType = {
    id?: true
    liveId?: true
  }

  export type PedidoOracaoSumAggregateInputType = {
    id?: true
    liveId?: true
  }

  export type PedidoOracaoMinAggregateInputType = {
    id?: true
    para?: true
    motivo?: true
    liveId?: true
    createdAt?: true
  }

  export type PedidoOracaoMaxAggregateInputType = {
    id?: true
    para?: true
    motivo?: true
    liveId?: true
    createdAt?: true
  }

  export type PedidoOracaoCountAggregateInputType = {
    id?: true
    para?: true
    motivo?: true
    liveId?: true
    createdAt?: true
    _all?: true
  }

  export type PedidoOracaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoOracao to aggregate.
     */
    where?: PedidoOracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoOracaos to fetch.
     */
    orderBy?: PedidoOracaoOrderByWithRelationInput | PedidoOracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PedidoOracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoOracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoOracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PedidoOracaos
    **/
    _count?: true | PedidoOracaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PedidoOracaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PedidoOracaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PedidoOracaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PedidoOracaoMaxAggregateInputType
  }

  export type GetPedidoOracaoAggregateType<T extends PedidoOracaoAggregateArgs> = {
        [P in keyof T & keyof AggregatePedidoOracao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePedidoOracao[P]>
      : GetScalarType<T[P], AggregatePedidoOracao[P]>
  }




  export type PedidoOracaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PedidoOracaoWhereInput
    orderBy?: PedidoOracaoOrderByWithAggregationInput | PedidoOracaoOrderByWithAggregationInput[]
    by: PedidoOracaoScalarFieldEnum[] | PedidoOracaoScalarFieldEnum
    having?: PedidoOracaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PedidoOracaoCountAggregateInputType | true
    _avg?: PedidoOracaoAvgAggregateInputType
    _sum?: PedidoOracaoSumAggregateInputType
    _min?: PedidoOracaoMinAggregateInputType
    _max?: PedidoOracaoMaxAggregateInputType
  }

  export type PedidoOracaoGroupByOutputType = {
    id: number
    para: string
    motivo: string
    liveId: number
    createdAt: Date
    _count: PedidoOracaoCountAggregateOutputType | null
    _avg: PedidoOracaoAvgAggregateOutputType | null
    _sum: PedidoOracaoSumAggregateOutputType | null
    _min: PedidoOracaoMinAggregateOutputType | null
    _max: PedidoOracaoMaxAggregateOutputType | null
  }

  type GetPedidoOracaoGroupByPayload<T extends PedidoOracaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PedidoOracaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PedidoOracaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PedidoOracaoGroupByOutputType[P]>
            : GetScalarType<T[P], PedidoOracaoGroupByOutputType[P]>
        }
      >
    >


  export type PedidoOracaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    para?: boolean
    motivo?: boolean
    liveId?: boolean
    createdAt?: boolean
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoOracao"]>

  export type PedidoOracaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    para?: boolean
    motivo?: boolean
    liveId?: boolean
    createdAt?: boolean
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoOracao"]>

  export type PedidoOracaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    para?: boolean
    motivo?: boolean
    liveId?: boolean
    createdAt?: boolean
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pedidoOracao"]>

  export type PedidoOracaoSelectScalar = {
    id?: boolean
    para?: boolean
    motivo?: boolean
    liveId?: boolean
    createdAt?: boolean
  }

  export type PedidoOracaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "para" | "motivo" | "liveId" | "createdAt", ExtArgs["result"]["pedidoOracao"]>
  export type PedidoOracaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }
  export type PedidoOracaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }
  export type PedidoOracaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }

  export type $PedidoOracaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PedidoOracao"
    objects: {
      live: Prisma.$LivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      para: string
      motivo: string
      liveId: number
      createdAt: Date
    }, ExtArgs["result"]["pedidoOracao"]>
    composites: {}
  }

  type PedidoOracaoGetPayload<S extends boolean | null | undefined | PedidoOracaoDefaultArgs> = $Result.GetResult<Prisma.$PedidoOracaoPayload, S>

  type PedidoOracaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PedidoOracaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PedidoOracaoCountAggregateInputType | true
    }

  export interface PedidoOracaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PedidoOracao'], meta: { name: 'PedidoOracao' } }
    /**
     * Find zero or one PedidoOracao that matches the filter.
     * @param {PedidoOracaoFindUniqueArgs} args - Arguments to find a PedidoOracao
     * @example
     * // Get one PedidoOracao
     * const pedidoOracao = await prisma.pedidoOracao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PedidoOracaoFindUniqueArgs>(args: SelectSubset<T, PedidoOracaoFindUniqueArgs<ExtArgs>>): Prisma__PedidoOracaoClient<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PedidoOracao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PedidoOracaoFindUniqueOrThrowArgs} args - Arguments to find a PedidoOracao
     * @example
     * // Get one PedidoOracao
     * const pedidoOracao = await prisma.pedidoOracao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PedidoOracaoFindUniqueOrThrowArgs>(args: SelectSubset<T, PedidoOracaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PedidoOracaoClient<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PedidoOracao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoOracaoFindFirstArgs} args - Arguments to find a PedidoOracao
     * @example
     * // Get one PedidoOracao
     * const pedidoOracao = await prisma.pedidoOracao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PedidoOracaoFindFirstArgs>(args?: SelectSubset<T, PedidoOracaoFindFirstArgs<ExtArgs>>): Prisma__PedidoOracaoClient<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PedidoOracao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoOracaoFindFirstOrThrowArgs} args - Arguments to find a PedidoOracao
     * @example
     * // Get one PedidoOracao
     * const pedidoOracao = await prisma.pedidoOracao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PedidoOracaoFindFirstOrThrowArgs>(args?: SelectSubset<T, PedidoOracaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PedidoOracaoClient<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PedidoOracaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoOracaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PedidoOracaos
     * const pedidoOracaos = await prisma.pedidoOracao.findMany()
     * 
     * // Get first 10 PedidoOracaos
     * const pedidoOracaos = await prisma.pedidoOracao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pedidoOracaoWithIdOnly = await prisma.pedidoOracao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PedidoOracaoFindManyArgs>(args?: SelectSubset<T, PedidoOracaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PedidoOracao.
     * @param {PedidoOracaoCreateArgs} args - Arguments to create a PedidoOracao.
     * @example
     * // Create one PedidoOracao
     * const PedidoOracao = await prisma.pedidoOracao.create({
     *   data: {
     *     // ... data to create a PedidoOracao
     *   }
     * })
     * 
     */
    create<T extends PedidoOracaoCreateArgs>(args: SelectSubset<T, PedidoOracaoCreateArgs<ExtArgs>>): Prisma__PedidoOracaoClient<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PedidoOracaos.
     * @param {PedidoOracaoCreateManyArgs} args - Arguments to create many PedidoOracaos.
     * @example
     * // Create many PedidoOracaos
     * const pedidoOracao = await prisma.pedidoOracao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PedidoOracaoCreateManyArgs>(args?: SelectSubset<T, PedidoOracaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PedidoOracaos and returns the data saved in the database.
     * @param {PedidoOracaoCreateManyAndReturnArgs} args - Arguments to create many PedidoOracaos.
     * @example
     * // Create many PedidoOracaos
     * const pedidoOracao = await prisma.pedidoOracao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PedidoOracaos and only return the `id`
     * const pedidoOracaoWithIdOnly = await prisma.pedidoOracao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PedidoOracaoCreateManyAndReturnArgs>(args?: SelectSubset<T, PedidoOracaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PedidoOracao.
     * @param {PedidoOracaoDeleteArgs} args - Arguments to delete one PedidoOracao.
     * @example
     * // Delete one PedidoOracao
     * const PedidoOracao = await prisma.pedidoOracao.delete({
     *   where: {
     *     // ... filter to delete one PedidoOracao
     *   }
     * })
     * 
     */
    delete<T extends PedidoOracaoDeleteArgs>(args: SelectSubset<T, PedidoOracaoDeleteArgs<ExtArgs>>): Prisma__PedidoOracaoClient<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PedidoOracao.
     * @param {PedidoOracaoUpdateArgs} args - Arguments to update one PedidoOracao.
     * @example
     * // Update one PedidoOracao
     * const pedidoOracao = await prisma.pedidoOracao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PedidoOracaoUpdateArgs>(args: SelectSubset<T, PedidoOracaoUpdateArgs<ExtArgs>>): Prisma__PedidoOracaoClient<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PedidoOracaos.
     * @param {PedidoOracaoDeleteManyArgs} args - Arguments to filter PedidoOracaos to delete.
     * @example
     * // Delete a few PedidoOracaos
     * const { count } = await prisma.pedidoOracao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PedidoOracaoDeleteManyArgs>(args?: SelectSubset<T, PedidoOracaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PedidoOracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoOracaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PedidoOracaos
     * const pedidoOracao = await prisma.pedidoOracao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PedidoOracaoUpdateManyArgs>(args: SelectSubset<T, PedidoOracaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PedidoOracaos and returns the data updated in the database.
     * @param {PedidoOracaoUpdateManyAndReturnArgs} args - Arguments to update many PedidoOracaos.
     * @example
     * // Update many PedidoOracaos
     * const pedidoOracao = await prisma.pedidoOracao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PedidoOracaos and only return the `id`
     * const pedidoOracaoWithIdOnly = await prisma.pedidoOracao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PedidoOracaoUpdateManyAndReturnArgs>(args: SelectSubset<T, PedidoOracaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PedidoOracao.
     * @param {PedidoOracaoUpsertArgs} args - Arguments to update or create a PedidoOracao.
     * @example
     * // Update or create a PedidoOracao
     * const pedidoOracao = await prisma.pedidoOracao.upsert({
     *   create: {
     *     // ... data to create a PedidoOracao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PedidoOracao we want to update
     *   }
     * })
     */
    upsert<T extends PedidoOracaoUpsertArgs>(args: SelectSubset<T, PedidoOracaoUpsertArgs<ExtArgs>>): Prisma__PedidoOracaoClient<$Result.GetResult<Prisma.$PedidoOracaoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PedidoOracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoOracaoCountArgs} args - Arguments to filter PedidoOracaos to count.
     * @example
     * // Count the number of PedidoOracaos
     * const count = await prisma.pedidoOracao.count({
     *   where: {
     *     // ... the filter for the PedidoOracaos we want to count
     *   }
     * })
    **/
    count<T extends PedidoOracaoCountArgs>(
      args?: Subset<T, PedidoOracaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PedidoOracaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PedidoOracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoOracaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PedidoOracaoAggregateArgs>(args: Subset<T, PedidoOracaoAggregateArgs>): Prisma.PrismaPromise<GetPedidoOracaoAggregateType<T>>

    /**
     * Group by PedidoOracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PedidoOracaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PedidoOracaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PedidoOracaoGroupByArgs['orderBy'] }
        : { orderBy?: PedidoOracaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PedidoOracaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPedidoOracaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PedidoOracao model
   */
  readonly fields: PedidoOracaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PedidoOracao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PedidoOracaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    live<T extends LiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiveDefaultArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PedidoOracao model
   */ 
  interface PedidoOracaoFieldRefs {
    readonly id: FieldRef<"PedidoOracao", 'Int'>
    readonly para: FieldRef<"PedidoOracao", 'String'>
    readonly motivo: FieldRef<"PedidoOracao", 'String'>
    readonly liveId: FieldRef<"PedidoOracao", 'Int'>
    readonly createdAt: FieldRef<"PedidoOracao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PedidoOracao findUnique
   */
  export type PedidoOracaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
    /**
     * Filter, which PedidoOracao to fetch.
     */
    where: PedidoOracaoWhereUniqueInput
  }

  /**
   * PedidoOracao findUniqueOrThrow
   */
  export type PedidoOracaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
    /**
     * Filter, which PedidoOracao to fetch.
     */
    where: PedidoOracaoWhereUniqueInput
  }

  /**
   * PedidoOracao findFirst
   */
  export type PedidoOracaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
    /**
     * Filter, which PedidoOracao to fetch.
     */
    where?: PedidoOracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoOracaos to fetch.
     */
    orderBy?: PedidoOracaoOrderByWithRelationInput | PedidoOracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoOracaos.
     */
    cursor?: PedidoOracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoOracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoOracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoOracaos.
     */
    distinct?: PedidoOracaoScalarFieldEnum | PedidoOracaoScalarFieldEnum[]
  }

  /**
   * PedidoOracao findFirstOrThrow
   */
  export type PedidoOracaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
    /**
     * Filter, which PedidoOracao to fetch.
     */
    where?: PedidoOracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoOracaos to fetch.
     */
    orderBy?: PedidoOracaoOrderByWithRelationInput | PedidoOracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PedidoOracaos.
     */
    cursor?: PedidoOracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoOracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoOracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PedidoOracaos.
     */
    distinct?: PedidoOracaoScalarFieldEnum | PedidoOracaoScalarFieldEnum[]
  }

  /**
   * PedidoOracao findMany
   */
  export type PedidoOracaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
    /**
     * Filter, which PedidoOracaos to fetch.
     */
    where?: PedidoOracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PedidoOracaos to fetch.
     */
    orderBy?: PedidoOracaoOrderByWithRelationInput | PedidoOracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PedidoOracaos.
     */
    cursor?: PedidoOracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PedidoOracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PedidoOracaos.
     */
    skip?: number
    distinct?: PedidoOracaoScalarFieldEnum | PedidoOracaoScalarFieldEnum[]
  }

  /**
   * PedidoOracao create
   */
  export type PedidoOracaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
    /**
     * The data needed to create a PedidoOracao.
     */
    data: XOR<PedidoOracaoCreateInput, PedidoOracaoUncheckedCreateInput>
  }

  /**
   * PedidoOracao createMany
   */
  export type PedidoOracaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PedidoOracaos.
     */
    data: PedidoOracaoCreateManyInput | PedidoOracaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PedidoOracao createManyAndReturn
   */
  export type PedidoOracaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * The data used to create many PedidoOracaos.
     */
    data: PedidoOracaoCreateManyInput | PedidoOracaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PedidoOracao update
   */
  export type PedidoOracaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
    /**
     * The data needed to update a PedidoOracao.
     */
    data: XOR<PedidoOracaoUpdateInput, PedidoOracaoUncheckedUpdateInput>
    /**
     * Choose, which PedidoOracao to update.
     */
    where: PedidoOracaoWhereUniqueInput
  }

  /**
   * PedidoOracao updateMany
   */
  export type PedidoOracaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PedidoOracaos.
     */
    data: XOR<PedidoOracaoUpdateManyMutationInput, PedidoOracaoUncheckedUpdateManyInput>
    /**
     * Filter which PedidoOracaos to update
     */
    where?: PedidoOracaoWhereInput
  }

  /**
   * PedidoOracao updateManyAndReturn
   */
  export type PedidoOracaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * The data used to update PedidoOracaos.
     */
    data: XOR<PedidoOracaoUpdateManyMutationInput, PedidoOracaoUncheckedUpdateManyInput>
    /**
     * Filter which PedidoOracaos to update
     */
    where?: PedidoOracaoWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PedidoOracao upsert
   */
  export type PedidoOracaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
    /**
     * The filter to search for the PedidoOracao to update in case it exists.
     */
    where: PedidoOracaoWhereUniqueInput
    /**
     * In case the PedidoOracao found by the `where` argument doesn't exist, create a new PedidoOracao with this data.
     */
    create: XOR<PedidoOracaoCreateInput, PedidoOracaoUncheckedCreateInput>
    /**
     * In case the PedidoOracao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PedidoOracaoUpdateInput, PedidoOracaoUncheckedUpdateInput>
  }

  /**
   * PedidoOracao delete
   */
  export type PedidoOracaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
    /**
     * Filter which PedidoOracao to delete.
     */
    where: PedidoOracaoWhereUniqueInput
  }

  /**
   * PedidoOracao deleteMany
   */
  export type PedidoOracaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PedidoOracaos to delete
     */
    where?: PedidoOracaoWhereInput
  }

  /**
   * PedidoOracao without action
   */
  export type PedidoOracaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PedidoOracao
     */
    select?: PedidoOracaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PedidoOracao
     */
    omit?: PedidoOracaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PedidoOracaoInclude<ExtArgs> | null
  }


  /**
   * Model ViewerSession
   */

  export type AggregateViewerSession = {
    _count: ViewerSessionCountAggregateOutputType | null
    _avg: ViewerSessionAvgAggregateOutputType | null
    _sum: ViewerSessionSumAggregateOutputType | null
    _min: ViewerSessionMinAggregateOutputType | null
    _max: ViewerSessionMaxAggregateOutputType | null
  }

  export type ViewerSessionAvgAggregateOutputType = {
    id: number | null
    liveId: number | null
  }

  export type ViewerSessionSumAggregateOutputType = {
    id: number | null
    liveId: number | null
  }

  export type ViewerSessionMinAggregateOutputType = {
    id: number | null
    sessionId: string | null
    userName: string | null
    userImage: string | null
    liveId: number | null
    createdAt: Date | null
    endedAt: Date | null
  }

  export type ViewerSessionMaxAggregateOutputType = {
    id: number | null
    sessionId: string | null
    userName: string | null
    userImage: string | null
    liveId: number | null
    createdAt: Date | null
    endedAt: Date | null
  }

  export type ViewerSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    userName: number
    userImage: number
    liveId: number
    createdAt: number
    endedAt: number
    _all: number
  }


  export type ViewerSessionAvgAggregateInputType = {
    id?: true
    liveId?: true
  }

  export type ViewerSessionSumAggregateInputType = {
    id?: true
    liveId?: true
  }

  export type ViewerSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    userName?: true
    userImage?: true
    liveId?: true
    createdAt?: true
    endedAt?: true
  }

  export type ViewerSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userName?: true
    userImage?: true
    liveId?: true
    createdAt?: true
    endedAt?: true
  }

  export type ViewerSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    userName?: true
    userImage?: true
    liveId?: true
    createdAt?: true
    endedAt?: true
    _all?: true
  }

  export type ViewerSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewerSession to aggregate.
     */
    where?: ViewerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewerSessions to fetch.
     */
    orderBy?: ViewerSessionOrderByWithRelationInput | ViewerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewerSessions
    **/
    _count?: true | ViewerSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViewerSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViewerSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewerSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewerSessionMaxAggregateInputType
  }

  export type GetViewerSessionAggregateType<T extends ViewerSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateViewerSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewerSession[P]>
      : GetScalarType<T[P], AggregateViewerSession[P]>
  }




  export type ViewerSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewerSessionWhereInput
    orderBy?: ViewerSessionOrderByWithAggregationInput | ViewerSessionOrderByWithAggregationInput[]
    by: ViewerSessionScalarFieldEnum[] | ViewerSessionScalarFieldEnum
    having?: ViewerSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewerSessionCountAggregateInputType | true
    _avg?: ViewerSessionAvgAggregateInputType
    _sum?: ViewerSessionSumAggregateInputType
    _min?: ViewerSessionMinAggregateInputType
    _max?: ViewerSessionMaxAggregateInputType
  }

  export type ViewerSessionGroupByOutputType = {
    id: number
    sessionId: string
    userName: string | null
    userImage: string | null
    liveId: number
    createdAt: Date
    endedAt: Date | null
    _count: ViewerSessionCountAggregateOutputType | null
    _avg: ViewerSessionAvgAggregateOutputType | null
    _sum: ViewerSessionSumAggregateOutputType | null
    _min: ViewerSessionMinAggregateOutputType | null
    _max: ViewerSessionMaxAggregateOutputType | null
  }

  type GetViewerSessionGroupByPayload<T extends ViewerSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewerSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewerSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewerSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ViewerSessionGroupByOutputType[P]>
        }
      >
    >


  export type ViewerSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userName?: boolean
    userImage?: boolean
    liveId?: boolean
    createdAt?: boolean
    endedAt?: boolean
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewerSession"]>

  export type ViewerSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userName?: boolean
    userImage?: boolean
    liveId?: boolean
    createdAt?: boolean
    endedAt?: boolean
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewerSession"]>

  export type ViewerSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userName?: boolean
    userImage?: boolean
    liveId?: boolean
    createdAt?: boolean
    endedAt?: boolean
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewerSession"]>

  export type ViewerSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userName?: boolean
    userImage?: boolean
    liveId?: boolean
    createdAt?: boolean
    endedAt?: boolean
  }

  export type ViewerSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userName" | "userImage" | "liveId" | "createdAt" | "endedAt", ExtArgs["result"]["viewerSession"]>
  export type ViewerSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }
  export type ViewerSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }
  export type ViewerSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    live?: boolean | LiveDefaultArgs<ExtArgs>
  }

  export type $ViewerSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewerSession"
    objects: {
      live: Prisma.$LivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: string
      userName: string | null
      userImage: string | null
      liveId: number
      createdAt: Date
      endedAt: Date | null
    }, ExtArgs["result"]["viewerSession"]>
    composites: {}
  }

  type ViewerSessionGetPayload<S extends boolean | null | undefined | ViewerSessionDefaultArgs> = $Result.GetResult<Prisma.$ViewerSessionPayload, S>

  type ViewerSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViewerSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViewerSessionCountAggregateInputType | true
    }

  export interface ViewerSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewerSession'], meta: { name: 'ViewerSession' } }
    /**
     * Find zero or one ViewerSession that matches the filter.
     * @param {ViewerSessionFindUniqueArgs} args - Arguments to find a ViewerSession
     * @example
     * // Get one ViewerSession
     * const viewerSession = await prisma.viewerSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewerSessionFindUniqueArgs>(args: SelectSubset<T, ViewerSessionFindUniqueArgs<ExtArgs>>): Prisma__ViewerSessionClient<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ViewerSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViewerSessionFindUniqueOrThrowArgs} args - Arguments to find a ViewerSession
     * @example
     * // Get one ViewerSession
     * const viewerSession = await prisma.viewerSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewerSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewerSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewerSessionClient<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ViewerSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerSessionFindFirstArgs} args - Arguments to find a ViewerSession
     * @example
     * // Get one ViewerSession
     * const viewerSession = await prisma.viewerSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewerSessionFindFirstArgs>(args?: SelectSubset<T, ViewerSessionFindFirstArgs<ExtArgs>>): Prisma__ViewerSessionClient<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ViewerSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerSessionFindFirstOrThrowArgs} args - Arguments to find a ViewerSession
     * @example
     * // Get one ViewerSession
     * const viewerSession = await prisma.viewerSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewerSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewerSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewerSessionClient<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ViewerSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewerSessions
     * const viewerSessions = await prisma.viewerSession.findMany()
     * 
     * // Get first 10 ViewerSessions
     * const viewerSessions = await prisma.viewerSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viewerSessionWithIdOnly = await prisma.viewerSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViewerSessionFindManyArgs>(args?: SelectSubset<T, ViewerSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ViewerSession.
     * @param {ViewerSessionCreateArgs} args - Arguments to create a ViewerSession.
     * @example
     * // Create one ViewerSession
     * const ViewerSession = await prisma.viewerSession.create({
     *   data: {
     *     // ... data to create a ViewerSession
     *   }
     * })
     * 
     */
    create<T extends ViewerSessionCreateArgs>(args: SelectSubset<T, ViewerSessionCreateArgs<ExtArgs>>): Prisma__ViewerSessionClient<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ViewerSessions.
     * @param {ViewerSessionCreateManyArgs} args - Arguments to create many ViewerSessions.
     * @example
     * // Create many ViewerSessions
     * const viewerSession = await prisma.viewerSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewerSessionCreateManyArgs>(args?: SelectSubset<T, ViewerSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewerSessions and returns the data saved in the database.
     * @param {ViewerSessionCreateManyAndReturnArgs} args - Arguments to create many ViewerSessions.
     * @example
     * // Create many ViewerSessions
     * const viewerSession = await prisma.viewerSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewerSessions and only return the `id`
     * const viewerSessionWithIdOnly = await prisma.viewerSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewerSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewerSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ViewerSession.
     * @param {ViewerSessionDeleteArgs} args - Arguments to delete one ViewerSession.
     * @example
     * // Delete one ViewerSession
     * const ViewerSession = await prisma.viewerSession.delete({
     *   where: {
     *     // ... filter to delete one ViewerSession
     *   }
     * })
     * 
     */
    delete<T extends ViewerSessionDeleteArgs>(args: SelectSubset<T, ViewerSessionDeleteArgs<ExtArgs>>): Prisma__ViewerSessionClient<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ViewerSession.
     * @param {ViewerSessionUpdateArgs} args - Arguments to update one ViewerSession.
     * @example
     * // Update one ViewerSession
     * const viewerSession = await prisma.viewerSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewerSessionUpdateArgs>(args: SelectSubset<T, ViewerSessionUpdateArgs<ExtArgs>>): Prisma__ViewerSessionClient<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ViewerSessions.
     * @param {ViewerSessionDeleteManyArgs} args - Arguments to filter ViewerSessions to delete.
     * @example
     * // Delete a few ViewerSessions
     * const { count } = await prisma.viewerSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewerSessionDeleteManyArgs>(args?: SelectSubset<T, ViewerSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewerSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewerSessions
     * const viewerSession = await prisma.viewerSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewerSessionUpdateManyArgs>(args: SelectSubset<T, ViewerSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewerSessions and returns the data updated in the database.
     * @param {ViewerSessionUpdateManyAndReturnArgs} args - Arguments to update many ViewerSessions.
     * @example
     * // Update many ViewerSessions
     * const viewerSession = await prisma.viewerSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViewerSessions and only return the `id`
     * const viewerSessionWithIdOnly = await prisma.viewerSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViewerSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, ViewerSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ViewerSession.
     * @param {ViewerSessionUpsertArgs} args - Arguments to update or create a ViewerSession.
     * @example
     * // Update or create a ViewerSession
     * const viewerSession = await prisma.viewerSession.upsert({
     *   create: {
     *     // ... data to create a ViewerSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewerSession we want to update
     *   }
     * })
     */
    upsert<T extends ViewerSessionUpsertArgs>(args: SelectSubset<T, ViewerSessionUpsertArgs<ExtArgs>>): Prisma__ViewerSessionClient<$Result.GetResult<Prisma.$ViewerSessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ViewerSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerSessionCountArgs} args - Arguments to filter ViewerSessions to count.
     * @example
     * // Count the number of ViewerSessions
     * const count = await prisma.viewerSession.count({
     *   where: {
     *     // ... the filter for the ViewerSessions we want to count
     *   }
     * })
    **/
    count<T extends ViewerSessionCountArgs>(
      args?: Subset<T, ViewerSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewerSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewerSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewerSessionAggregateArgs>(args: Subset<T, ViewerSessionAggregateArgs>): Prisma.PrismaPromise<GetViewerSessionAggregateType<T>>

    /**
     * Group by ViewerSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewerSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewerSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewerSessionGroupByArgs['orderBy'] }
        : { orderBy?: ViewerSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewerSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewerSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewerSession model
   */
  readonly fields: ViewerSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewerSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewerSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    live<T extends LiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LiveDefaultArgs<ExtArgs>>): Prisma__LiveClient<$Result.GetResult<Prisma.$LivePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViewerSession model
   */ 
  interface ViewerSessionFieldRefs {
    readonly id: FieldRef<"ViewerSession", 'Int'>
    readonly sessionId: FieldRef<"ViewerSession", 'String'>
    readonly userName: FieldRef<"ViewerSession", 'String'>
    readonly userImage: FieldRef<"ViewerSession", 'String'>
    readonly liveId: FieldRef<"ViewerSession", 'Int'>
    readonly createdAt: FieldRef<"ViewerSession", 'DateTime'>
    readonly endedAt: FieldRef<"ViewerSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ViewerSession findUnique
   */
  export type ViewerSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViewerSession to fetch.
     */
    where: ViewerSessionWhereUniqueInput
  }

  /**
   * ViewerSession findUniqueOrThrow
   */
  export type ViewerSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViewerSession to fetch.
     */
    where: ViewerSessionWhereUniqueInput
  }

  /**
   * ViewerSession findFirst
   */
  export type ViewerSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViewerSession to fetch.
     */
    where?: ViewerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewerSessions to fetch.
     */
    orderBy?: ViewerSessionOrderByWithRelationInput | ViewerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewerSessions.
     */
    cursor?: ViewerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewerSessions.
     */
    distinct?: ViewerSessionScalarFieldEnum | ViewerSessionScalarFieldEnum[]
  }

  /**
   * ViewerSession findFirstOrThrow
   */
  export type ViewerSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViewerSession to fetch.
     */
    where?: ViewerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewerSessions to fetch.
     */
    orderBy?: ViewerSessionOrderByWithRelationInput | ViewerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewerSessions.
     */
    cursor?: ViewerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewerSessions.
     */
    distinct?: ViewerSessionScalarFieldEnum | ViewerSessionScalarFieldEnum[]
  }

  /**
   * ViewerSession findMany
   */
  export type ViewerSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
    /**
     * Filter, which ViewerSessions to fetch.
     */
    where?: ViewerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewerSessions to fetch.
     */
    orderBy?: ViewerSessionOrderByWithRelationInput | ViewerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewerSessions.
     */
    cursor?: ViewerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewerSessions.
     */
    skip?: number
    distinct?: ViewerSessionScalarFieldEnum | ViewerSessionScalarFieldEnum[]
  }

  /**
   * ViewerSession create
   */
  export type ViewerSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ViewerSession.
     */
    data: XOR<ViewerSessionCreateInput, ViewerSessionUncheckedCreateInput>
  }

  /**
   * ViewerSession createMany
   */
  export type ViewerSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewerSessions.
     */
    data: ViewerSessionCreateManyInput | ViewerSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewerSession createManyAndReturn
   */
  export type ViewerSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * The data used to create many ViewerSessions.
     */
    data: ViewerSessionCreateManyInput | ViewerSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViewerSession update
   */
  export type ViewerSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ViewerSession.
     */
    data: XOR<ViewerSessionUpdateInput, ViewerSessionUncheckedUpdateInput>
    /**
     * Choose, which ViewerSession to update.
     */
    where: ViewerSessionWhereUniqueInput
  }

  /**
   * ViewerSession updateMany
   */
  export type ViewerSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewerSessions.
     */
    data: XOR<ViewerSessionUpdateManyMutationInput, ViewerSessionUncheckedUpdateManyInput>
    /**
     * Filter which ViewerSessions to update
     */
    where?: ViewerSessionWhereInput
  }

  /**
   * ViewerSession updateManyAndReturn
   */
  export type ViewerSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * The data used to update ViewerSessions.
     */
    data: XOR<ViewerSessionUpdateManyMutationInput, ViewerSessionUncheckedUpdateManyInput>
    /**
     * Filter which ViewerSessions to update
     */
    where?: ViewerSessionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViewerSession upsert
   */
  export type ViewerSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ViewerSession to update in case it exists.
     */
    where: ViewerSessionWhereUniqueInput
    /**
     * In case the ViewerSession found by the `where` argument doesn't exist, create a new ViewerSession with this data.
     */
    create: XOR<ViewerSessionCreateInput, ViewerSessionUncheckedCreateInput>
    /**
     * In case the ViewerSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewerSessionUpdateInput, ViewerSessionUncheckedUpdateInput>
  }

  /**
   * ViewerSession delete
   */
  export type ViewerSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
    /**
     * Filter which ViewerSession to delete.
     */
    where: ViewerSessionWhereUniqueInput
  }

  /**
   * ViewerSession deleteMany
   */
  export type ViewerSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewerSessions to delete
     */
    where?: ViewerSessionWhereInput
  }

  /**
   * ViewerSession without action
   */
  export type ViewerSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewerSession
     */
    select?: ViewerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewerSession
     */
    omit?: ViewerSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewerSessionInclude<ExtArgs> | null
  }


  /**
   * Model Cargo
   */

  export type AggregateCargo = {
    _count: CargoCountAggregateOutputType | null
    _avg: CargoAvgAggregateOutputType | null
    _sum: CargoSumAggregateOutputType | null
    _min: CargoMinAggregateOutputType | null
    _max: CargoMaxAggregateOutputType | null
  }

  export type CargoAvgAggregateOutputType = {
    id: number | null
  }

  export type CargoSumAggregateOutputType = {
    id: number | null
  }

  export type CargoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type CargoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type CargoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type CargoAvgAggregateInputType = {
    id?: true
  }

  export type CargoSumAggregateInputType = {
    id?: true
  }

  export type CargoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type CargoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type CargoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type CargoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cargo to aggregate.
     */
    where?: CargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cargos to fetch.
     */
    orderBy?: CargoOrderByWithRelationInput | CargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cargos
    **/
    _count?: true | CargoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CargoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CargoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CargoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CargoMaxAggregateInputType
  }

  export type GetCargoAggregateType<T extends CargoAggregateArgs> = {
        [P in keyof T & keyof AggregateCargo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCargo[P]>
      : GetScalarType<T[P], AggregateCargo[P]>
  }




  export type CargoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CargoWhereInput
    orderBy?: CargoOrderByWithAggregationInput | CargoOrderByWithAggregationInput[]
    by: CargoScalarFieldEnum[] | CargoScalarFieldEnum
    having?: CargoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CargoCountAggregateInputType | true
    _avg?: CargoAvgAggregateInputType
    _sum?: CargoSumAggregateInputType
    _min?: CargoMinAggregateInputType
    _max?: CargoMaxAggregateInputType
  }

  export type CargoGroupByOutputType = {
    id: number
    nome: string
    _count: CargoCountAggregateOutputType | null
    _avg: CargoAvgAggregateOutputType | null
    _sum: CargoSumAggregateOutputType | null
    _min: CargoMinAggregateOutputType | null
    _max: CargoMaxAggregateOutputType | null
  }

  type GetCargoGroupByPayload<T extends CargoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CargoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CargoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CargoGroupByOutputType[P]>
            : GetScalarType<T[P], CargoGroupByOutputType[P]>
        }
      >
    >


  export type CargoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    users?: boolean | Cargo$usersArgs<ExtArgs>
    _count?: boolean | CargoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cargo"]>

  export type CargoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["cargo"]>

  export type CargoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
  }, ExtArgs["result"]["cargo"]>

  export type CargoSelectScalar = {
    id?: boolean
    nome?: boolean
  }

  export type CargoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome", ExtArgs["result"]["cargo"]>
  export type CargoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Cargo$usersArgs<ExtArgs>
    _count?: boolean | CargoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CargoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CargoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CargoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cargo"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
    }, ExtArgs["result"]["cargo"]>
    composites: {}
  }

  type CargoGetPayload<S extends boolean | null | undefined | CargoDefaultArgs> = $Result.GetResult<Prisma.$CargoPayload, S>

  type CargoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CargoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CargoCountAggregateInputType | true
    }

  export interface CargoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cargo'], meta: { name: 'Cargo' } }
    /**
     * Find zero or one Cargo that matches the filter.
     * @param {CargoFindUniqueArgs} args - Arguments to find a Cargo
     * @example
     * // Get one Cargo
     * const cargo = await prisma.cargo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CargoFindUniqueArgs>(args: SelectSubset<T, CargoFindUniqueArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Cargo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CargoFindUniqueOrThrowArgs} args - Arguments to find a Cargo
     * @example
     * // Get one Cargo
     * const cargo = await prisma.cargo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CargoFindUniqueOrThrowArgs>(args: SelectSubset<T, CargoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Cargo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoFindFirstArgs} args - Arguments to find a Cargo
     * @example
     * // Get one Cargo
     * const cargo = await prisma.cargo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CargoFindFirstArgs>(args?: SelectSubset<T, CargoFindFirstArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Cargo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoFindFirstOrThrowArgs} args - Arguments to find a Cargo
     * @example
     * // Get one Cargo
     * const cargo = await prisma.cargo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CargoFindFirstOrThrowArgs>(args?: SelectSubset<T, CargoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Cargos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cargos
     * const cargos = await prisma.cargo.findMany()
     * 
     * // Get first 10 Cargos
     * const cargos = await prisma.cargo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cargoWithIdOnly = await prisma.cargo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CargoFindManyArgs>(args?: SelectSubset<T, CargoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Cargo.
     * @param {CargoCreateArgs} args - Arguments to create a Cargo.
     * @example
     * // Create one Cargo
     * const Cargo = await prisma.cargo.create({
     *   data: {
     *     // ... data to create a Cargo
     *   }
     * })
     * 
     */
    create<T extends CargoCreateArgs>(args: SelectSubset<T, CargoCreateArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Cargos.
     * @param {CargoCreateManyArgs} args - Arguments to create many Cargos.
     * @example
     * // Create many Cargos
     * const cargo = await prisma.cargo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CargoCreateManyArgs>(args?: SelectSubset<T, CargoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cargos and returns the data saved in the database.
     * @param {CargoCreateManyAndReturnArgs} args - Arguments to create many Cargos.
     * @example
     * // Create many Cargos
     * const cargo = await prisma.cargo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cargos and only return the `id`
     * const cargoWithIdOnly = await prisma.cargo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CargoCreateManyAndReturnArgs>(args?: SelectSubset<T, CargoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Cargo.
     * @param {CargoDeleteArgs} args - Arguments to delete one Cargo.
     * @example
     * // Delete one Cargo
     * const Cargo = await prisma.cargo.delete({
     *   where: {
     *     // ... filter to delete one Cargo
     *   }
     * })
     * 
     */
    delete<T extends CargoDeleteArgs>(args: SelectSubset<T, CargoDeleteArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Cargo.
     * @param {CargoUpdateArgs} args - Arguments to update one Cargo.
     * @example
     * // Update one Cargo
     * const cargo = await prisma.cargo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CargoUpdateArgs>(args: SelectSubset<T, CargoUpdateArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Cargos.
     * @param {CargoDeleteManyArgs} args - Arguments to filter Cargos to delete.
     * @example
     * // Delete a few Cargos
     * const { count } = await prisma.cargo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CargoDeleteManyArgs>(args?: SelectSubset<T, CargoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cargos
     * const cargo = await prisma.cargo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CargoUpdateManyArgs>(args: SelectSubset<T, CargoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cargos and returns the data updated in the database.
     * @param {CargoUpdateManyAndReturnArgs} args - Arguments to update many Cargos.
     * @example
     * // Update many Cargos
     * const cargo = await prisma.cargo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cargos and only return the `id`
     * const cargoWithIdOnly = await prisma.cargo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CargoUpdateManyAndReturnArgs>(args: SelectSubset<T, CargoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Cargo.
     * @param {CargoUpsertArgs} args - Arguments to update or create a Cargo.
     * @example
     * // Update or create a Cargo
     * const cargo = await prisma.cargo.upsert({
     *   create: {
     *     // ... data to create a Cargo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cargo we want to update
     *   }
     * })
     */
    upsert<T extends CargoUpsertArgs>(args: SelectSubset<T, CargoUpsertArgs<ExtArgs>>): Prisma__CargoClient<$Result.GetResult<Prisma.$CargoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Cargos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoCountArgs} args - Arguments to filter Cargos to count.
     * @example
     * // Count the number of Cargos
     * const count = await prisma.cargo.count({
     *   where: {
     *     // ... the filter for the Cargos we want to count
     *   }
     * })
    **/
    count<T extends CargoCountArgs>(
      args?: Subset<T, CargoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CargoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CargoAggregateArgs>(args: Subset<T, CargoAggregateArgs>): Prisma.PrismaPromise<GetCargoAggregateType<T>>

    /**
     * Group by Cargo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CargoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CargoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CargoGroupByArgs['orderBy'] }
        : { orderBy?: CargoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CargoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCargoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cargo model
   */
  readonly fields: CargoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cargo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CargoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Cargo$usersArgs<ExtArgs> = {}>(args?: Subset<T, Cargo$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cargo model
   */ 
  interface CargoFieldRefs {
    readonly id: FieldRef<"Cargo", 'Int'>
    readonly nome: FieldRef<"Cargo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cargo findUnique
   */
  export type CargoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter, which Cargo to fetch.
     */
    where: CargoWhereUniqueInput
  }

  /**
   * Cargo findUniqueOrThrow
   */
  export type CargoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter, which Cargo to fetch.
     */
    where: CargoWhereUniqueInput
  }

  /**
   * Cargo findFirst
   */
  export type CargoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter, which Cargo to fetch.
     */
    where?: CargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cargos to fetch.
     */
    orderBy?: CargoOrderByWithRelationInput | CargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cargos.
     */
    cursor?: CargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cargos.
     */
    distinct?: CargoScalarFieldEnum | CargoScalarFieldEnum[]
  }

  /**
   * Cargo findFirstOrThrow
   */
  export type CargoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter, which Cargo to fetch.
     */
    where?: CargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cargos to fetch.
     */
    orderBy?: CargoOrderByWithRelationInput | CargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cargos.
     */
    cursor?: CargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cargos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cargos.
     */
    distinct?: CargoScalarFieldEnum | CargoScalarFieldEnum[]
  }

  /**
   * Cargo findMany
   */
  export type CargoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter, which Cargos to fetch.
     */
    where?: CargoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cargos to fetch.
     */
    orderBy?: CargoOrderByWithRelationInput | CargoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cargos.
     */
    cursor?: CargoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cargos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cargos.
     */
    skip?: number
    distinct?: CargoScalarFieldEnum | CargoScalarFieldEnum[]
  }

  /**
   * Cargo create
   */
  export type CargoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * The data needed to create a Cargo.
     */
    data: XOR<CargoCreateInput, CargoUncheckedCreateInput>
  }

  /**
   * Cargo createMany
   */
  export type CargoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cargos.
     */
    data: CargoCreateManyInput | CargoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cargo createManyAndReturn
   */
  export type CargoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * The data used to create many Cargos.
     */
    data: CargoCreateManyInput | CargoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cargo update
   */
  export type CargoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * The data needed to update a Cargo.
     */
    data: XOR<CargoUpdateInput, CargoUncheckedUpdateInput>
    /**
     * Choose, which Cargo to update.
     */
    where: CargoWhereUniqueInput
  }

  /**
   * Cargo updateMany
   */
  export type CargoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cargos.
     */
    data: XOR<CargoUpdateManyMutationInput, CargoUncheckedUpdateManyInput>
    /**
     * Filter which Cargos to update
     */
    where?: CargoWhereInput
  }

  /**
   * Cargo updateManyAndReturn
   */
  export type CargoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * The data used to update Cargos.
     */
    data: XOR<CargoUpdateManyMutationInput, CargoUncheckedUpdateManyInput>
    /**
     * Filter which Cargos to update
     */
    where?: CargoWhereInput
  }

  /**
   * Cargo upsert
   */
  export type CargoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * The filter to search for the Cargo to update in case it exists.
     */
    where: CargoWhereUniqueInput
    /**
     * In case the Cargo found by the `where` argument doesn't exist, create a new Cargo with this data.
     */
    create: XOR<CargoCreateInput, CargoUncheckedCreateInput>
    /**
     * In case the Cargo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CargoUpdateInput, CargoUncheckedUpdateInput>
  }

  /**
   * Cargo delete
   */
  export type CargoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
    /**
     * Filter which Cargo to delete.
     */
    where: CargoWhereUniqueInput
  }

  /**
   * Cargo deleteMany
   */
  export type CargoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cargos to delete
     */
    where?: CargoWhereInput
  }

  /**
   * Cargo.users
   */
  export type Cargo$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Cargo without action
   */
  export type CargoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cargo
     */
    select?: CargoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cargo
     */
    omit?: CargoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CargoInclude<ExtArgs> | null
  }


  /**
   * Model Local
   */

  export type AggregateLocal = {
    _count: LocalCountAggregateOutputType | null
    _avg: LocalAvgAggregateOutputType | null
    _sum: LocalSumAggregateOutputType | null
    _min: LocalMinAggregateOutputType | null
    _max: LocalMaxAggregateOutputType | null
  }

  export type LocalAvgAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LocalSumAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LocalMinAggregateOutputType = {
    id: number | null
    nome: string | null
    latitude: number | null
    longitude: number | null
  }

  export type LocalMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    latitude: number | null
    longitude: number | null
  }

  export type LocalCountAggregateOutputType = {
    id: number
    nome: number
    latitude: number
    longitude: number
    _all: number
  }


  export type LocalAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type LocalSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type LocalMinAggregateInputType = {
    id?: true
    nome?: true
    latitude?: true
    longitude?: true
  }

  export type LocalMaxAggregateInputType = {
    id?: true
    nome?: true
    latitude?: true
    longitude?: true
  }

  export type LocalCountAggregateInputType = {
    id?: true
    nome?: true
    latitude?: true
    longitude?: true
    _all?: true
  }

  export type LocalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Local to aggregate.
     */
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     */
    orderBy?: LocalOrderByWithRelationInput | LocalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locals
    **/
    _count?: true | LocalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalMaxAggregateInputType
  }

  export type GetLocalAggregateType<T extends LocalAggregateArgs> = {
        [P in keyof T & keyof AggregateLocal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocal[P]>
      : GetScalarType<T[P], AggregateLocal[P]>
  }




  export type LocalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalWhereInput
    orderBy?: LocalOrderByWithAggregationInput | LocalOrderByWithAggregationInput[]
    by: LocalScalarFieldEnum[] | LocalScalarFieldEnum
    having?: LocalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalCountAggregateInputType | true
    _avg?: LocalAvgAggregateInputType
    _sum?: LocalSumAggregateInputType
    _min?: LocalMinAggregateInputType
    _max?: LocalMaxAggregateInputType
  }

  export type LocalGroupByOutputType = {
    id: number
    nome: string
    latitude: number
    longitude: number
    _count: LocalCountAggregateOutputType | null
    _avg: LocalAvgAggregateOutputType | null
    _sum: LocalSumAggregateOutputType | null
    _min: LocalMinAggregateOutputType | null
    _max: LocalMaxAggregateOutputType | null
  }

  type GetLocalGroupByPayload<T extends LocalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalGroupByOutputType[P]>
            : GetScalarType<T[P], LocalGroupByOutputType[P]>
        }
      >
    >


  export type LocalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    latitude?: boolean
    longitude?: boolean
    cultos?: boolean | Local$cultosArgs<ExtArgs>
    reunioes?: boolean | Local$reunioesArgs<ExtArgs>
    ensaios?: boolean | Local$ensaiosArgs<ExtArgs>
    eventos?: boolean | Local$eventosArgs<ExtArgs>
    _count?: boolean | LocalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["local"]>

  export type LocalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    latitude?: boolean
    longitude?: boolean
  }, ExtArgs["result"]["local"]>

  export type LocalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    latitude?: boolean
    longitude?: boolean
  }, ExtArgs["result"]["local"]>

  export type LocalSelectScalar = {
    id?: boolean
    nome?: boolean
    latitude?: boolean
    longitude?: boolean
  }

  export type LocalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "latitude" | "longitude", ExtArgs["result"]["local"]>
  export type LocalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cultos?: boolean | Local$cultosArgs<ExtArgs>
    reunioes?: boolean | Local$reunioesArgs<ExtArgs>
    ensaios?: boolean | Local$ensaiosArgs<ExtArgs>
    eventos?: boolean | Local$eventosArgs<ExtArgs>
    _count?: boolean | LocalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Local"
    objects: {
      cultos: Prisma.$CultoPayload<ExtArgs>[]
      reunioes: Prisma.$ReuniaoPayload<ExtArgs>[]
      ensaios: Prisma.$EnsaioPayload<ExtArgs>[]
      eventos: Prisma.$EventoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      latitude: number
      longitude: number
    }, ExtArgs["result"]["local"]>
    composites: {}
  }

  type LocalGetPayload<S extends boolean | null | undefined | LocalDefaultArgs> = $Result.GetResult<Prisma.$LocalPayload, S>

  type LocalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocalCountAggregateInputType | true
    }

  export interface LocalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Local'], meta: { name: 'Local' } }
    /**
     * Find zero or one Local that matches the filter.
     * @param {LocalFindUniqueArgs} args - Arguments to find a Local
     * @example
     * // Get one Local
     * const local = await prisma.local.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalFindUniqueArgs>(args: SelectSubset<T, LocalFindUniqueArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Local that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocalFindUniqueOrThrowArgs} args - Arguments to find a Local
     * @example
     * // Get one Local
     * const local = await prisma.local.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Local that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalFindFirstArgs} args - Arguments to find a Local
     * @example
     * // Get one Local
     * const local = await prisma.local.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalFindFirstArgs>(args?: SelectSubset<T, LocalFindFirstArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Local that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalFindFirstOrThrowArgs} args - Arguments to find a Local
     * @example
     * // Get one Local
     * const local = await prisma.local.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Locals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locals
     * const locals = await prisma.local.findMany()
     * 
     * // Get first 10 Locals
     * const locals = await prisma.local.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localWithIdOnly = await prisma.local.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalFindManyArgs>(args?: SelectSubset<T, LocalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Local.
     * @param {LocalCreateArgs} args - Arguments to create a Local.
     * @example
     * // Create one Local
     * const Local = await prisma.local.create({
     *   data: {
     *     // ... data to create a Local
     *   }
     * })
     * 
     */
    create<T extends LocalCreateArgs>(args: SelectSubset<T, LocalCreateArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Locals.
     * @param {LocalCreateManyArgs} args - Arguments to create many Locals.
     * @example
     * // Create many Locals
     * const local = await prisma.local.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalCreateManyArgs>(args?: SelectSubset<T, LocalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locals and returns the data saved in the database.
     * @param {LocalCreateManyAndReturnArgs} args - Arguments to create many Locals.
     * @example
     * // Create many Locals
     * const local = await prisma.local.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locals and only return the `id`
     * const localWithIdOnly = await prisma.local.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocalCreateManyAndReturnArgs>(args?: SelectSubset<T, LocalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Local.
     * @param {LocalDeleteArgs} args - Arguments to delete one Local.
     * @example
     * // Delete one Local
     * const Local = await prisma.local.delete({
     *   where: {
     *     // ... filter to delete one Local
     *   }
     * })
     * 
     */
    delete<T extends LocalDeleteArgs>(args: SelectSubset<T, LocalDeleteArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Local.
     * @param {LocalUpdateArgs} args - Arguments to update one Local.
     * @example
     * // Update one Local
     * const local = await prisma.local.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalUpdateArgs>(args: SelectSubset<T, LocalUpdateArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Locals.
     * @param {LocalDeleteManyArgs} args - Arguments to filter Locals to delete.
     * @example
     * // Delete a few Locals
     * const { count } = await prisma.local.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalDeleteManyArgs>(args?: SelectSubset<T, LocalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locals
     * const local = await prisma.local.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalUpdateManyArgs>(args: SelectSubset<T, LocalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locals and returns the data updated in the database.
     * @param {LocalUpdateManyAndReturnArgs} args - Arguments to update many Locals.
     * @example
     * // Update many Locals
     * const local = await prisma.local.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locals and only return the `id`
     * const localWithIdOnly = await prisma.local.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocalUpdateManyAndReturnArgs>(args: SelectSubset<T, LocalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Local.
     * @param {LocalUpsertArgs} args - Arguments to update or create a Local.
     * @example
     * // Update or create a Local
     * const local = await prisma.local.upsert({
     *   create: {
     *     // ... data to create a Local
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Local we want to update
     *   }
     * })
     */
    upsert<T extends LocalUpsertArgs>(args: SelectSubset<T, LocalUpsertArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Locals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalCountArgs} args - Arguments to filter Locals to count.
     * @example
     * // Count the number of Locals
     * const count = await prisma.local.count({
     *   where: {
     *     // ... the filter for the Locals we want to count
     *   }
     * })
    **/
    count<T extends LocalCountArgs>(
      args?: Subset<T, LocalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Local.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalAggregateArgs>(args: Subset<T, LocalAggregateArgs>): Prisma.PrismaPromise<GetLocalAggregateType<T>>

    /**
     * Group by Local.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalGroupByArgs['orderBy'] }
        : { orderBy?: LocalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Local model
   */
  readonly fields: LocalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Local.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cultos<T extends Local$cultosArgs<ExtArgs> = {}>(args?: Subset<T, Local$cultosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    reunioes<T extends Local$reunioesArgs<ExtArgs> = {}>(args?: Subset<T, Local$reunioesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ensaios<T extends Local$ensaiosArgs<ExtArgs> = {}>(args?: Subset<T, Local$ensaiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    eventos<T extends Local$eventosArgs<ExtArgs> = {}>(args?: Subset<T, Local$eventosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Local model
   */ 
  interface LocalFieldRefs {
    readonly id: FieldRef<"Local", 'Int'>
    readonly nome: FieldRef<"Local", 'String'>
    readonly latitude: FieldRef<"Local", 'Float'>
    readonly longitude: FieldRef<"Local", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Local findUnique
   */
  export type LocalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter, which Local to fetch.
     */
    where: LocalWhereUniqueInput
  }

  /**
   * Local findUniqueOrThrow
   */
  export type LocalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter, which Local to fetch.
     */
    where: LocalWhereUniqueInput
  }

  /**
   * Local findFirst
   */
  export type LocalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter, which Local to fetch.
     */
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     */
    orderBy?: LocalOrderByWithRelationInput | LocalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locals.
     */
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locals.
     */
    distinct?: LocalScalarFieldEnum | LocalScalarFieldEnum[]
  }

  /**
   * Local findFirstOrThrow
   */
  export type LocalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter, which Local to fetch.
     */
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     */
    orderBy?: LocalOrderByWithRelationInput | LocalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locals.
     */
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locals.
     */
    distinct?: LocalScalarFieldEnum | LocalScalarFieldEnum[]
  }

  /**
   * Local findMany
   */
  export type LocalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter, which Locals to fetch.
     */
    where?: LocalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locals to fetch.
     */
    orderBy?: LocalOrderByWithRelationInput | LocalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locals.
     */
    cursor?: LocalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locals.
     */
    skip?: number
    distinct?: LocalScalarFieldEnum | LocalScalarFieldEnum[]
  }

  /**
   * Local create
   */
  export type LocalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * The data needed to create a Local.
     */
    data: XOR<LocalCreateInput, LocalUncheckedCreateInput>
  }

  /**
   * Local createMany
   */
  export type LocalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locals.
     */
    data: LocalCreateManyInput | LocalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Local createManyAndReturn
   */
  export type LocalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * The data used to create many Locals.
     */
    data: LocalCreateManyInput | LocalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Local update
   */
  export type LocalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * The data needed to update a Local.
     */
    data: XOR<LocalUpdateInput, LocalUncheckedUpdateInput>
    /**
     * Choose, which Local to update.
     */
    where: LocalWhereUniqueInput
  }

  /**
   * Local updateMany
   */
  export type LocalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locals.
     */
    data: XOR<LocalUpdateManyMutationInput, LocalUncheckedUpdateManyInput>
    /**
     * Filter which Locals to update
     */
    where?: LocalWhereInput
  }

  /**
   * Local updateManyAndReturn
   */
  export type LocalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * The data used to update Locals.
     */
    data: XOR<LocalUpdateManyMutationInput, LocalUncheckedUpdateManyInput>
    /**
     * Filter which Locals to update
     */
    where?: LocalWhereInput
  }

  /**
   * Local upsert
   */
  export type LocalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * The filter to search for the Local to update in case it exists.
     */
    where: LocalWhereUniqueInput
    /**
     * In case the Local found by the `where` argument doesn't exist, create a new Local with this data.
     */
    create: XOR<LocalCreateInput, LocalUncheckedCreateInput>
    /**
     * In case the Local was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalUpdateInput, LocalUncheckedUpdateInput>
  }

  /**
   * Local delete
   */
  export type LocalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
    /**
     * Filter which Local to delete.
     */
    where: LocalWhereUniqueInput
  }

  /**
   * Local deleteMany
   */
  export type LocalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locals to delete
     */
    where?: LocalWhereInput
  }

  /**
   * Local.cultos
   */
  export type Local$cultosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    where?: CultoWhereInput
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    cursor?: CultoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * Local.reunioes
   */
  export type Local$reunioesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    where?: ReuniaoWhereInput
    orderBy?: ReuniaoOrderByWithRelationInput | ReuniaoOrderByWithRelationInput[]
    cursor?: ReuniaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReuniaoScalarFieldEnum | ReuniaoScalarFieldEnum[]
  }

  /**
   * Local.ensaios
   */
  export type Local$ensaiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    where?: EnsaioWhereInput
    orderBy?: EnsaioOrderByWithRelationInput | EnsaioOrderByWithRelationInput[]
    cursor?: EnsaioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnsaioScalarFieldEnum | EnsaioScalarFieldEnum[]
  }

  /**
   * Local.eventos
   */
  export type Local$eventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    where?: EventoWhereInput
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    cursor?: EventoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Local without action
   */
  export type LocalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Local
     */
    select?: LocalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Local
     */
    omit?: LocalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalInclude<ExtArgs> | null
  }


  /**
   * Model Culto
   */

  export type AggregateCulto = {
    _count: CultoCountAggregateOutputType | null
    _avg: CultoAvgAggregateOutputType | null
    _sum: CultoSumAggregateOutputType | null
    _min: CultoMinAggregateOutputType | null
    _max: CultoMaxAggregateOutputType | null
  }

  export type CultoAvgAggregateOutputType = {
    id: number | null
    localId: number | null
    pastorId: number | null
    obreiroId: number | null
    liderCanticoId: number | null
  }

  export type CultoSumAggregateOutputType = {
    id: number | null
    localId: number | null
    pastorId: number | null
    obreiroId: number | null
    liderCanticoId: number | null
  }

  export type CultoMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    dataInicio: Date | null
    dataTermino: Date | null
    localId: number | null
    status: string | null
    pastorId: number | null
    obreiroId: number | null
    liderCanticoId: number | null
    videoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CultoMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    dataInicio: Date | null
    dataTermino: Date | null
    localId: number | null
    status: string | null
    pastorId: number | null
    obreiroId: number | null
    liderCanticoId: number | null
    videoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CultoCountAggregateOutputType = {
    id: number
    titulo: number
    dataInicio: number
    dataTermino: number
    localId: number
    status: number
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CultoAvgAggregateInputType = {
    id?: true
    localId?: true
    pastorId?: true
    obreiroId?: true
    liderCanticoId?: true
  }

  export type CultoSumAggregateInputType = {
    id?: true
    localId?: true
    pastorId?: true
    obreiroId?: true
    liderCanticoId?: true
  }

  export type CultoMinAggregateInputType = {
    id?: true
    titulo?: true
    dataInicio?: true
    dataTermino?: true
    localId?: true
    status?: true
    pastorId?: true
    obreiroId?: true
    liderCanticoId?: true
    videoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CultoMaxAggregateInputType = {
    id?: true
    titulo?: true
    dataInicio?: true
    dataTermino?: true
    localId?: true
    status?: true
    pastorId?: true
    obreiroId?: true
    liderCanticoId?: true
    videoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CultoCountAggregateInputType = {
    id?: true
    titulo?: true
    dataInicio?: true
    dataTermino?: true
    localId?: true
    status?: true
    pastorId?: true
    obreiroId?: true
    liderCanticoId?: true
    videoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CultoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Culto to aggregate.
     */
    where?: CultoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cultos to fetch.
     */
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CultoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cultos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cultos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cultos
    **/
    _count?: true | CultoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CultoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CultoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CultoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CultoMaxAggregateInputType
  }

  export type GetCultoAggregateType<T extends CultoAggregateArgs> = {
        [P in keyof T & keyof AggregateCulto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCulto[P]>
      : GetScalarType<T[P], AggregateCulto[P]>
  }




  export type CultoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CultoWhereInput
    orderBy?: CultoOrderByWithAggregationInput | CultoOrderByWithAggregationInput[]
    by: CultoScalarFieldEnum[] | CultoScalarFieldEnum
    having?: CultoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CultoCountAggregateInputType | true
    _avg?: CultoAvgAggregateInputType
    _sum?: CultoSumAggregateInputType
    _min?: CultoMinAggregateInputType
    _max?: CultoMaxAggregateInputType
  }

  export type CultoGroupByOutputType = {
    id: number
    titulo: string
    dataInicio: Date
    dataTermino: Date
    localId: number
    status: string
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: CultoCountAggregateOutputType | null
    _avg: CultoAvgAggregateOutputType | null
    _sum: CultoSumAggregateOutputType | null
    _min: CultoMinAggregateOutputType | null
    _max: CultoMaxAggregateOutputType | null
  }

  type GetCultoGroupByPayload<T extends CultoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CultoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CultoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CultoGroupByOutputType[P]>
            : GetScalarType<T[P], CultoGroupByOutputType[P]>
        }
      >
    >


  export type CultoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataInicio?: boolean
    dataTermino?: boolean
    localId?: boolean
    status?: boolean
    pastorId?: boolean
    obreiroId?: boolean
    liderCanticoId?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
    pastor?: boolean | UserDefaultArgs<ExtArgs>
    obreiro?: boolean | UserDefaultArgs<ExtArgs>
    auxiliares?: boolean | Culto$auxiliaresArgs<ExtArgs>
    liderCantico?: boolean | UserDefaultArgs<ExtArgs>
    vocal?: boolean | Culto$vocalArgs<ExtArgs>
    hinos?: boolean | Culto$hinosArgs<ExtArgs>
    mensagens?: boolean | Culto$mensagensArgs<ExtArgs>
    leituras?: boolean | Culto$leiturasArgs<ExtArgs>
    _count?: boolean | CultoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["culto"]>

  export type CultoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataInicio?: boolean
    dataTermino?: boolean
    localId?: boolean
    status?: boolean
    pastorId?: boolean
    obreiroId?: boolean
    liderCanticoId?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
    pastor?: boolean | UserDefaultArgs<ExtArgs>
    obreiro?: boolean | UserDefaultArgs<ExtArgs>
    liderCantico?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["culto"]>

  export type CultoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataInicio?: boolean
    dataTermino?: boolean
    localId?: boolean
    status?: boolean
    pastorId?: boolean
    obreiroId?: boolean
    liderCanticoId?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
    pastor?: boolean | UserDefaultArgs<ExtArgs>
    obreiro?: boolean | UserDefaultArgs<ExtArgs>
    liderCantico?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["culto"]>

  export type CultoSelectScalar = {
    id?: boolean
    titulo?: boolean
    dataInicio?: boolean
    dataTermino?: boolean
    localId?: boolean
    status?: boolean
    pastorId?: boolean
    obreiroId?: boolean
    liderCanticoId?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CultoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "dataInicio" | "dataTermino" | "localId" | "status" | "pastorId" | "obreiroId" | "liderCanticoId" | "videoUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["culto"]>
  export type CultoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
    pastor?: boolean | UserDefaultArgs<ExtArgs>
    obreiro?: boolean | UserDefaultArgs<ExtArgs>
    auxiliares?: boolean | Culto$auxiliaresArgs<ExtArgs>
    liderCantico?: boolean | UserDefaultArgs<ExtArgs>
    vocal?: boolean | Culto$vocalArgs<ExtArgs>
    hinos?: boolean | Culto$hinosArgs<ExtArgs>
    mensagens?: boolean | Culto$mensagensArgs<ExtArgs>
    leituras?: boolean | Culto$leiturasArgs<ExtArgs>
    _count?: boolean | CultoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CultoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
    pastor?: boolean | UserDefaultArgs<ExtArgs>
    obreiro?: boolean | UserDefaultArgs<ExtArgs>
    liderCantico?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CultoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
    pastor?: boolean | UserDefaultArgs<ExtArgs>
    obreiro?: boolean | UserDefaultArgs<ExtArgs>
    liderCantico?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CultoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Culto"
    objects: {
      local: Prisma.$LocalPayload<ExtArgs>
      pastor: Prisma.$UserPayload<ExtArgs>
      obreiro: Prisma.$UserPayload<ExtArgs>
      auxiliares: Prisma.$UserPayload<ExtArgs>[]
      liderCantico: Prisma.$UserPayload<ExtArgs>
      vocal: Prisma.$UserPayload<ExtArgs>[]
      hinos: Prisma.$HinoPayload<ExtArgs>[]
      mensagens: Prisma.$MensagemPayload<ExtArgs>[]
      leituras: Prisma.$LeituraBiblicaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      dataInicio: Date
      dataTermino: Date
      localId: number
      status: string
      pastorId: number
      obreiroId: number
      liderCanticoId: number
      videoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["culto"]>
    composites: {}
  }

  type CultoGetPayload<S extends boolean | null | undefined | CultoDefaultArgs> = $Result.GetResult<Prisma.$CultoPayload, S>

  type CultoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CultoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CultoCountAggregateInputType | true
    }

  export interface CultoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Culto'], meta: { name: 'Culto' } }
    /**
     * Find zero or one Culto that matches the filter.
     * @param {CultoFindUniqueArgs} args - Arguments to find a Culto
     * @example
     * // Get one Culto
     * const culto = await prisma.culto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CultoFindUniqueArgs>(args: SelectSubset<T, CultoFindUniqueArgs<ExtArgs>>): Prisma__CultoClient<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Culto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CultoFindUniqueOrThrowArgs} args - Arguments to find a Culto
     * @example
     * // Get one Culto
     * const culto = await prisma.culto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CultoFindUniqueOrThrowArgs>(args: SelectSubset<T, CultoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CultoClient<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Culto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultoFindFirstArgs} args - Arguments to find a Culto
     * @example
     * // Get one Culto
     * const culto = await prisma.culto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CultoFindFirstArgs>(args?: SelectSubset<T, CultoFindFirstArgs<ExtArgs>>): Prisma__CultoClient<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Culto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultoFindFirstOrThrowArgs} args - Arguments to find a Culto
     * @example
     * // Get one Culto
     * const culto = await prisma.culto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CultoFindFirstOrThrowArgs>(args?: SelectSubset<T, CultoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CultoClient<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Cultos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cultos
     * const cultos = await prisma.culto.findMany()
     * 
     * // Get first 10 Cultos
     * const cultos = await prisma.culto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cultoWithIdOnly = await prisma.culto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CultoFindManyArgs>(args?: SelectSubset<T, CultoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Culto.
     * @param {CultoCreateArgs} args - Arguments to create a Culto.
     * @example
     * // Create one Culto
     * const Culto = await prisma.culto.create({
     *   data: {
     *     // ... data to create a Culto
     *   }
     * })
     * 
     */
    create<T extends CultoCreateArgs>(args: SelectSubset<T, CultoCreateArgs<ExtArgs>>): Prisma__CultoClient<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Cultos.
     * @param {CultoCreateManyArgs} args - Arguments to create many Cultos.
     * @example
     * // Create many Cultos
     * const culto = await prisma.culto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CultoCreateManyArgs>(args?: SelectSubset<T, CultoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cultos and returns the data saved in the database.
     * @param {CultoCreateManyAndReturnArgs} args - Arguments to create many Cultos.
     * @example
     * // Create many Cultos
     * const culto = await prisma.culto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cultos and only return the `id`
     * const cultoWithIdOnly = await prisma.culto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CultoCreateManyAndReturnArgs>(args?: SelectSubset<T, CultoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Culto.
     * @param {CultoDeleteArgs} args - Arguments to delete one Culto.
     * @example
     * // Delete one Culto
     * const Culto = await prisma.culto.delete({
     *   where: {
     *     // ... filter to delete one Culto
     *   }
     * })
     * 
     */
    delete<T extends CultoDeleteArgs>(args: SelectSubset<T, CultoDeleteArgs<ExtArgs>>): Prisma__CultoClient<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Culto.
     * @param {CultoUpdateArgs} args - Arguments to update one Culto.
     * @example
     * // Update one Culto
     * const culto = await prisma.culto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CultoUpdateArgs>(args: SelectSubset<T, CultoUpdateArgs<ExtArgs>>): Prisma__CultoClient<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Cultos.
     * @param {CultoDeleteManyArgs} args - Arguments to filter Cultos to delete.
     * @example
     * // Delete a few Cultos
     * const { count } = await prisma.culto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CultoDeleteManyArgs>(args?: SelectSubset<T, CultoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cultos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cultos
     * const culto = await prisma.culto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CultoUpdateManyArgs>(args: SelectSubset<T, CultoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cultos and returns the data updated in the database.
     * @param {CultoUpdateManyAndReturnArgs} args - Arguments to update many Cultos.
     * @example
     * // Update many Cultos
     * const culto = await prisma.culto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cultos and only return the `id`
     * const cultoWithIdOnly = await prisma.culto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CultoUpdateManyAndReturnArgs>(args: SelectSubset<T, CultoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Culto.
     * @param {CultoUpsertArgs} args - Arguments to update or create a Culto.
     * @example
     * // Update or create a Culto
     * const culto = await prisma.culto.upsert({
     *   create: {
     *     // ... data to create a Culto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Culto we want to update
     *   }
     * })
     */
    upsert<T extends CultoUpsertArgs>(args: SelectSubset<T, CultoUpsertArgs<ExtArgs>>): Prisma__CultoClient<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Cultos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultoCountArgs} args - Arguments to filter Cultos to count.
     * @example
     * // Count the number of Cultos
     * const count = await prisma.culto.count({
     *   where: {
     *     // ... the filter for the Cultos we want to count
     *   }
     * })
    **/
    count<T extends CultoCountArgs>(
      args?: Subset<T, CultoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CultoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Culto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CultoAggregateArgs>(args: Subset<T, CultoAggregateArgs>): Prisma.PrismaPromise<GetCultoAggregateType<T>>

    /**
     * Group by Culto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CultoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CultoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CultoGroupByArgs['orderBy'] }
        : { orderBy?: CultoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CultoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCultoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Culto model
   */
  readonly fields: CultoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Culto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CultoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    local<T extends LocalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalDefaultArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    pastor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    obreiro<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    auxiliares<T extends Culto$auxiliaresArgs<ExtArgs> = {}>(args?: Subset<T, Culto$auxiliaresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    liderCantico<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    vocal<T extends Culto$vocalArgs<ExtArgs> = {}>(args?: Subset<T, Culto$vocalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    hinos<T extends Culto$hinosArgs<ExtArgs> = {}>(args?: Subset<T, Culto$hinosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    mensagens<T extends Culto$mensagensArgs<ExtArgs> = {}>(args?: Subset<T, Culto$mensagensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    leituras<T extends Culto$leiturasArgs<ExtArgs> = {}>(args?: Subset<T, Culto$leiturasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Culto model
   */ 
  interface CultoFieldRefs {
    readonly id: FieldRef<"Culto", 'Int'>
    readonly titulo: FieldRef<"Culto", 'String'>
    readonly dataInicio: FieldRef<"Culto", 'DateTime'>
    readonly dataTermino: FieldRef<"Culto", 'DateTime'>
    readonly localId: FieldRef<"Culto", 'Int'>
    readonly status: FieldRef<"Culto", 'String'>
    readonly pastorId: FieldRef<"Culto", 'Int'>
    readonly obreiroId: FieldRef<"Culto", 'Int'>
    readonly liderCanticoId: FieldRef<"Culto", 'Int'>
    readonly videoUrl: FieldRef<"Culto", 'String'>
    readonly createdAt: FieldRef<"Culto", 'DateTime'>
    readonly updatedAt: FieldRef<"Culto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Culto findUnique
   */
  export type CultoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    /**
     * Filter, which Culto to fetch.
     */
    where: CultoWhereUniqueInput
  }

  /**
   * Culto findUniqueOrThrow
   */
  export type CultoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    /**
     * Filter, which Culto to fetch.
     */
    where: CultoWhereUniqueInput
  }

  /**
   * Culto findFirst
   */
  export type CultoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    /**
     * Filter, which Culto to fetch.
     */
    where?: CultoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cultos to fetch.
     */
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cultos.
     */
    cursor?: CultoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cultos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cultos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cultos.
     */
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * Culto findFirstOrThrow
   */
  export type CultoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    /**
     * Filter, which Culto to fetch.
     */
    where?: CultoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cultos to fetch.
     */
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cultos.
     */
    cursor?: CultoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cultos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cultos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cultos.
     */
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * Culto findMany
   */
  export type CultoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    /**
     * Filter, which Cultos to fetch.
     */
    where?: CultoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cultos to fetch.
     */
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cultos.
     */
    cursor?: CultoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cultos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cultos.
     */
    skip?: number
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * Culto create
   */
  export type CultoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    /**
     * The data needed to create a Culto.
     */
    data: XOR<CultoCreateInput, CultoUncheckedCreateInput>
  }

  /**
   * Culto createMany
   */
  export type CultoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cultos.
     */
    data: CultoCreateManyInput | CultoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Culto createManyAndReturn
   */
  export type CultoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * The data used to create many Cultos.
     */
    data: CultoCreateManyInput | CultoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Culto update
   */
  export type CultoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    /**
     * The data needed to update a Culto.
     */
    data: XOR<CultoUpdateInput, CultoUncheckedUpdateInput>
    /**
     * Choose, which Culto to update.
     */
    where: CultoWhereUniqueInput
  }

  /**
   * Culto updateMany
   */
  export type CultoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cultos.
     */
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyInput>
    /**
     * Filter which Cultos to update
     */
    where?: CultoWhereInput
  }

  /**
   * Culto updateManyAndReturn
   */
  export type CultoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * The data used to update Cultos.
     */
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyInput>
    /**
     * Filter which Cultos to update
     */
    where?: CultoWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Culto upsert
   */
  export type CultoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    /**
     * The filter to search for the Culto to update in case it exists.
     */
    where: CultoWhereUniqueInput
    /**
     * In case the Culto found by the `where` argument doesn't exist, create a new Culto with this data.
     */
    create: XOR<CultoCreateInput, CultoUncheckedCreateInput>
    /**
     * In case the Culto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CultoUpdateInput, CultoUncheckedUpdateInput>
  }

  /**
   * Culto delete
   */
  export type CultoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    /**
     * Filter which Culto to delete.
     */
    where: CultoWhereUniqueInput
  }

  /**
   * Culto deleteMany
   */
  export type CultoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cultos to delete
     */
    where?: CultoWhereInput
  }

  /**
   * Culto.auxiliares
   */
  export type Culto$auxiliaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Culto.vocal
   */
  export type Culto$vocalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Culto.hinos
   */
  export type Culto$hinosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    where?: HinoWhereInput
    orderBy?: HinoOrderByWithRelationInput | HinoOrderByWithRelationInput[]
    cursor?: HinoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HinoScalarFieldEnum | HinoScalarFieldEnum[]
  }

  /**
   * Culto.mensagens
   */
  export type Culto$mensagensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
    where?: MensagemWhereInput
    orderBy?: MensagemOrderByWithRelationInput | MensagemOrderByWithRelationInput[]
    cursor?: MensagemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MensagemScalarFieldEnum | MensagemScalarFieldEnum[]
  }

  /**
   * Culto.leituras
   */
  export type Culto$leiturasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
    where?: LeituraBiblicaWhereInput
    orderBy?: LeituraBiblicaOrderByWithRelationInput | LeituraBiblicaOrderByWithRelationInput[]
    cursor?: LeituraBiblicaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeituraBiblicaScalarFieldEnum | LeituraBiblicaScalarFieldEnum[]
  }

  /**
   * Culto without action
   */
  export type CultoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
  }


  /**
   * Model Reuniao
   */

  export type AggregateReuniao = {
    _count: ReuniaoCountAggregateOutputType | null
    _avg: ReuniaoAvgAggregateOutputType | null
    _sum: ReuniaoSumAggregateOutputType | null
    _min: ReuniaoMinAggregateOutputType | null
    _max: ReuniaoMaxAggregateOutputType | null
  }

  export type ReuniaoAvgAggregateOutputType = {
    id: number | null
    localId: number | null
    responsavelId: number | null
  }

  export type ReuniaoSumAggregateOutputType = {
    id: number | null
    localId: number | null
    responsavelId: number | null
  }

  export type ReuniaoMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    dataHora: Date | null
    localId: number | null
    status: string | null
    responsavelId: number | null
    materiais: string | null
    cronograma: string | null
    informacoes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReuniaoMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    dataHora: Date | null
    localId: number | null
    status: string | null
    responsavelId: number | null
    materiais: string | null
    cronograma: string | null
    informacoes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReuniaoCountAggregateOutputType = {
    id: number
    titulo: number
    dataHora: number
    localId: number
    status: number
    responsavelId: number
    materiais: number
    cronograma: number
    informacoes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReuniaoAvgAggregateInputType = {
    id?: true
    localId?: true
    responsavelId?: true
  }

  export type ReuniaoSumAggregateInputType = {
    id?: true
    localId?: true
    responsavelId?: true
  }

  export type ReuniaoMinAggregateInputType = {
    id?: true
    titulo?: true
    dataHora?: true
    localId?: true
    status?: true
    responsavelId?: true
    materiais?: true
    cronograma?: true
    informacoes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReuniaoMaxAggregateInputType = {
    id?: true
    titulo?: true
    dataHora?: true
    localId?: true
    status?: true
    responsavelId?: true
    materiais?: true
    cronograma?: true
    informacoes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReuniaoCountAggregateInputType = {
    id?: true
    titulo?: true
    dataHora?: true
    localId?: true
    status?: true
    responsavelId?: true
    materiais?: true
    cronograma?: true
    informacoes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReuniaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reuniao to aggregate.
     */
    where?: ReuniaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reuniaos to fetch.
     */
    orderBy?: ReuniaoOrderByWithRelationInput | ReuniaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReuniaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reuniaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reuniaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reuniaos
    **/
    _count?: true | ReuniaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReuniaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReuniaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReuniaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReuniaoMaxAggregateInputType
  }

  export type GetReuniaoAggregateType<T extends ReuniaoAggregateArgs> = {
        [P in keyof T & keyof AggregateReuniao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReuniao[P]>
      : GetScalarType<T[P], AggregateReuniao[P]>
  }




  export type ReuniaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReuniaoWhereInput
    orderBy?: ReuniaoOrderByWithAggregationInput | ReuniaoOrderByWithAggregationInput[]
    by: ReuniaoScalarFieldEnum[] | ReuniaoScalarFieldEnum
    having?: ReuniaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReuniaoCountAggregateInputType | true
    _avg?: ReuniaoAvgAggregateInputType
    _sum?: ReuniaoSumAggregateInputType
    _min?: ReuniaoMinAggregateInputType
    _max?: ReuniaoMaxAggregateInputType
  }

  export type ReuniaoGroupByOutputType = {
    id: number
    titulo: string
    dataHora: Date
    localId: number
    status: string
    responsavelId: number
    materiais: string
    cronograma: string
    informacoes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReuniaoCountAggregateOutputType | null
    _avg: ReuniaoAvgAggregateOutputType | null
    _sum: ReuniaoSumAggregateOutputType | null
    _min: ReuniaoMinAggregateOutputType | null
    _max: ReuniaoMaxAggregateOutputType | null
  }

  type GetReuniaoGroupByPayload<T extends ReuniaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReuniaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReuniaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReuniaoGroupByOutputType[P]>
            : GetScalarType<T[P], ReuniaoGroupByOutputType[P]>
        }
      >
    >


  export type ReuniaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    responsavelId?: boolean
    materiais?: boolean
    cronograma?: boolean
    informacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reuniao"]>

  export type ReuniaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    responsavelId?: boolean
    materiais?: boolean
    cronograma?: boolean
    informacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reuniao"]>

  export type ReuniaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    responsavelId?: boolean
    materiais?: boolean
    cronograma?: boolean
    informacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reuniao"]>

  export type ReuniaoSelectScalar = {
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    responsavelId?: boolean
    materiais?: boolean
    cronograma?: boolean
    informacoes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReuniaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "dataHora" | "localId" | "status" | "responsavelId" | "materiais" | "cronograma" | "informacoes" | "createdAt" | "updatedAt", ExtArgs["result"]["reuniao"]>
  export type ReuniaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReuniaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReuniaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReuniaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reuniao"
    objects: {
      local: Prisma.$LocalPayload<ExtArgs>
      responsavel: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      dataHora: Date
      localId: number
      status: string
      responsavelId: number
      materiais: string
      cronograma: string
      informacoes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reuniao"]>
    composites: {}
  }

  type ReuniaoGetPayload<S extends boolean | null | undefined | ReuniaoDefaultArgs> = $Result.GetResult<Prisma.$ReuniaoPayload, S>

  type ReuniaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReuniaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReuniaoCountAggregateInputType | true
    }

  export interface ReuniaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reuniao'], meta: { name: 'Reuniao' } }
    /**
     * Find zero or one Reuniao that matches the filter.
     * @param {ReuniaoFindUniqueArgs} args - Arguments to find a Reuniao
     * @example
     * // Get one Reuniao
     * const reuniao = await prisma.reuniao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReuniaoFindUniqueArgs>(args: SelectSubset<T, ReuniaoFindUniqueArgs<ExtArgs>>): Prisma__ReuniaoClient<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Reuniao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReuniaoFindUniqueOrThrowArgs} args - Arguments to find a Reuniao
     * @example
     * // Get one Reuniao
     * const reuniao = await prisma.reuniao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReuniaoFindUniqueOrThrowArgs>(args: SelectSubset<T, ReuniaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReuniaoClient<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Reuniao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReuniaoFindFirstArgs} args - Arguments to find a Reuniao
     * @example
     * // Get one Reuniao
     * const reuniao = await prisma.reuniao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReuniaoFindFirstArgs>(args?: SelectSubset<T, ReuniaoFindFirstArgs<ExtArgs>>): Prisma__ReuniaoClient<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Reuniao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReuniaoFindFirstOrThrowArgs} args - Arguments to find a Reuniao
     * @example
     * // Get one Reuniao
     * const reuniao = await prisma.reuniao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReuniaoFindFirstOrThrowArgs>(args?: SelectSubset<T, ReuniaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReuniaoClient<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Reuniaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReuniaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reuniaos
     * const reuniaos = await prisma.reuniao.findMany()
     * 
     * // Get first 10 Reuniaos
     * const reuniaos = await prisma.reuniao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reuniaoWithIdOnly = await prisma.reuniao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReuniaoFindManyArgs>(args?: SelectSubset<T, ReuniaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Reuniao.
     * @param {ReuniaoCreateArgs} args - Arguments to create a Reuniao.
     * @example
     * // Create one Reuniao
     * const Reuniao = await prisma.reuniao.create({
     *   data: {
     *     // ... data to create a Reuniao
     *   }
     * })
     * 
     */
    create<T extends ReuniaoCreateArgs>(args: SelectSubset<T, ReuniaoCreateArgs<ExtArgs>>): Prisma__ReuniaoClient<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Reuniaos.
     * @param {ReuniaoCreateManyArgs} args - Arguments to create many Reuniaos.
     * @example
     * // Create many Reuniaos
     * const reuniao = await prisma.reuniao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReuniaoCreateManyArgs>(args?: SelectSubset<T, ReuniaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reuniaos and returns the data saved in the database.
     * @param {ReuniaoCreateManyAndReturnArgs} args - Arguments to create many Reuniaos.
     * @example
     * // Create many Reuniaos
     * const reuniao = await prisma.reuniao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reuniaos and only return the `id`
     * const reuniaoWithIdOnly = await prisma.reuniao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReuniaoCreateManyAndReturnArgs>(args?: SelectSubset<T, ReuniaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Reuniao.
     * @param {ReuniaoDeleteArgs} args - Arguments to delete one Reuniao.
     * @example
     * // Delete one Reuniao
     * const Reuniao = await prisma.reuniao.delete({
     *   where: {
     *     // ... filter to delete one Reuniao
     *   }
     * })
     * 
     */
    delete<T extends ReuniaoDeleteArgs>(args: SelectSubset<T, ReuniaoDeleteArgs<ExtArgs>>): Prisma__ReuniaoClient<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Reuniao.
     * @param {ReuniaoUpdateArgs} args - Arguments to update one Reuniao.
     * @example
     * // Update one Reuniao
     * const reuniao = await prisma.reuniao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReuniaoUpdateArgs>(args: SelectSubset<T, ReuniaoUpdateArgs<ExtArgs>>): Prisma__ReuniaoClient<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Reuniaos.
     * @param {ReuniaoDeleteManyArgs} args - Arguments to filter Reuniaos to delete.
     * @example
     * // Delete a few Reuniaos
     * const { count } = await prisma.reuniao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReuniaoDeleteManyArgs>(args?: SelectSubset<T, ReuniaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reuniaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReuniaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reuniaos
     * const reuniao = await prisma.reuniao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReuniaoUpdateManyArgs>(args: SelectSubset<T, ReuniaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reuniaos and returns the data updated in the database.
     * @param {ReuniaoUpdateManyAndReturnArgs} args - Arguments to update many Reuniaos.
     * @example
     * // Update many Reuniaos
     * const reuniao = await prisma.reuniao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reuniaos and only return the `id`
     * const reuniaoWithIdOnly = await prisma.reuniao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReuniaoUpdateManyAndReturnArgs>(args: SelectSubset<T, ReuniaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Reuniao.
     * @param {ReuniaoUpsertArgs} args - Arguments to update or create a Reuniao.
     * @example
     * // Update or create a Reuniao
     * const reuniao = await prisma.reuniao.upsert({
     *   create: {
     *     // ... data to create a Reuniao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reuniao we want to update
     *   }
     * })
     */
    upsert<T extends ReuniaoUpsertArgs>(args: SelectSubset<T, ReuniaoUpsertArgs<ExtArgs>>): Prisma__ReuniaoClient<$Result.GetResult<Prisma.$ReuniaoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Reuniaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReuniaoCountArgs} args - Arguments to filter Reuniaos to count.
     * @example
     * // Count the number of Reuniaos
     * const count = await prisma.reuniao.count({
     *   where: {
     *     // ... the filter for the Reuniaos we want to count
     *   }
     * })
    **/
    count<T extends ReuniaoCountArgs>(
      args?: Subset<T, ReuniaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReuniaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reuniao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReuniaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReuniaoAggregateArgs>(args: Subset<T, ReuniaoAggregateArgs>): Prisma.PrismaPromise<GetReuniaoAggregateType<T>>

    /**
     * Group by Reuniao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReuniaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReuniaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReuniaoGroupByArgs['orderBy'] }
        : { orderBy?: ReuniaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReuniaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReuniaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reuniao model
   */
  readonly fields: ReuniaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reuniao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReuniaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    local<T extends LocalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalDefaultArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    responsavel<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reuniao model
   */ 
  interface ReuniaoFieldRefs {
    readonly id: FieldRef<"Reuniao", 'Int'>
    readonly titulo: FieldRef<"Reuniao", 'String'>
    readonly dataHora: FieldRef<"Reuniao", 'DateTime'>
    readonly localId: FieldRef<"Reuniao", 'Int'>
    readonly status: FieldRef<"Reuniao", 'String'>
    readonly responsavelId: FieldRef<"Reuniao", 'Int'>
    readonly materiais: FieldRef<"Reuniao", 'String'>
    readonly cronograma: FieldRef<"Reuniao", 'String'>
    readonly informacoes: FieldRef<"Reuniao", 'String'>
    readonly createdAt: FieldRef<"Reuniao", 'DateTime'>
    readonly updatedAt: FieldRef<"Reuniao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reuniao findUnique
   */
  export type ReuniaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    /**
     * Filter, which Reuniao to fetch.
     */
    where: ReuniaoWhereUniqueInput
  }

  /**
   * Reuniao findUniqueOrThrow
   */
  export type ReuniaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    /**
     * Filter, which Reuniao to fetch.
     */
    where: ReuniaoWhereUniqueInput
  }

  /**
   * Reuniao findFirst
   */
  export type ReuniaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    /**
     * Filter, which Reuniao to fetch.
     */
    where?: ReuniaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reuniaos to fetch.
     */
    orderBy?: ReuniaoOrderByWithRelationInput | ReuniaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reuniaos.
     */
    cursor?: ReuniaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reuniaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reuniaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reuniaos.
     */
    distinct?: ReuniaoScalarFieldEnum | ReuniaoScalarFieldEnum[]
  }

  /**
   * Reuniao findFirstOrThrow
   */
  export type ReuniaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    /**
     * Filter, which Reuniao to fetch.
     */
    where?: ReuniaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reuniaos to fetch.
     */
    orderBy?: ReuniaoOrderByWithRelationInput | ReuniaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reuniaos.
     */
    cursor?: ReuniaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reuniaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reuniaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reuniaos.
     */
    distinct?: ReuniaoScalarFieldEnum | ReuniaoScalarFieldEnum[]
  }

  /**
   * Reuniao findMany
   */
  export type ReuniaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    /**
     * Filter, which Reuniaos to fetch.
     */
    where?: ReuniaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reuniaos to fetch.
     */
    orderBy?: ReuniaoOrderByWithRelationInput | ReuniaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reuniaos.
     */
    cursor?: ReuniaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reuniaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reuniaos.
     */
    skip?: number
    distinct?: ReuniaoScalarFieldEnum | ReuniaoScalarFieldEnum[]
  }

  /**
   * Reuniao create
   */
  export type ReuniaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Reuniao.
     */
    data: XOR<ReuniaoCreateInput, ReuniaoUncheckedCreateInput>
  }

  /**
   * Reuniao createMany
   */
  export type ReuniaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reuniaos.
     */
    data: ReuniaoCreateManyInput | ReuniaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reuniao createManyAndReturn
   */
  export type ReuniaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * The data used to create many Reuniaos.
     */
    data: ReuniaoCreateManyInput | ReuniaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reuniao update
   */
  export type ReuniaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Reuniao.
     */
    data: XOR<ReuniaoUpdateInput, ReuniaoUncheckedUpdateInput>
    /**
     * Choose, which Reuniao to update.
     */
    where: ReuniaoWhereUniqueInput
  }

  /**
   * Reuniao updateMany
   */
  export type ReuniaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reuniaos.
     */
    data: XOR<ReuniaoUpdateManyMutationInput, ReuniaoUncheckedUpdateManyInput>
    /**
     * Filter which Reuniaos to update
     */
    where?: ReuniaoWhereInput
  }

  /**
   * Reuniao updateManyAndReturn
   */
  export type ReuniaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * The data used to update Reuniaos.
     */
    data: XOR<ReuniaoUpdateManyMutationInput, ReuniaoUncheckedUpdateManyInput>
    /**
     * Filter which Reuniaos to update
     */
    where?: ReuniaoWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reuniao upsert
   */
  export type ReuniaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Reuniao to update in case it exists.
     */
    where: ReuniaoWhereUniqueInput
    /**
     * In case the Reuniao found by the `where` argument doesn't exist, create a new Reuniao with this data.
     */
    create: XOR<ReuniaoCreateInput, ReuniaoUncheckedCreateInput>
    /**
     * In case the Reuniao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReuniaoUpdateInput, ReuniaoUncheckedUpdateInput>
  }

  /**
   * Reuniao delete
   */
  export type ReuniaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
    /**
     * Filter which Reuniao to delete.
     */
    where: ReuniaoWhereUniqueInput
  }

  /**
   * Reuniao deleteMany
   */
  export type ReuniaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reuniaos to delete
     */
    where?: ReuniaoWhereInput
  }

  /**
   * Reuniao without action
   */
  export type ReuniaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reuniao
     */
    select?: ReuniaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reuniao
     */
    omit?: ReuniaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReuniaoInclude<ExtArgs> | null
  }


  /**
   * Model Ensaio
   */

  export type AggregateEnsaio = {
    _count: EnsaioCountAggregateOutputType | null
    _avg: EnsaioAvgAggregateOutputType | null
    _sum: EnsaioSumAggregateOutputType | null
    _min: EnsaioMinAggregateOutputType | null
    _max: EnsaioMaxAggregateOutputType | null
  }

  export type EnsaioAvgAggregateOutputType = {
    id: number | null
    localId: number | null
    responsavelId: number | null
  }

  export type EnsaioSumAggregateOutputType = {
    id: number | null
    localId: number | null
    responsavelId: number | null
  }

  export type EnsaioMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    dataHora: Date | null
    localId: number | null
    status: string | null
    responsavelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnsaioMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    dataHora: Date | null
    localId: number | null
    status: string | null
    responsavelId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnsaioCountAggregateOutputType = {
    id: number
    titulo: number
    dataHora: number
    localId: number
    status: number
    responsavelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EnsaioAvgAggregateInputType = {
    id?: true
    localId?: true
    responsavelId?: true
  }

  export type EnsaioSumAggregateInputType = {
    id?: true
    localId?: true
    responsavelId?: true
  }

  export type EnsaioMinAggregateInputType = {
    id?: true
    titulo?: true
    dataHora?: true
    localId?: true
    status?: true
    responsavelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnsaioMaxAggregateInputType = {
    id?: true
    titulo?: true
    dataHora?: true
    localId?: true
    status?: true
    responsavelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnsaioCountAggregateInputType = {
    id?: true
    titulo?: true
    dataHora?: true
    localId?: true
    status?: true
    responsavelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EnsaioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ensaio to aggregate.
     */
    where?: EnsaioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ensaios to fetch.
     */
    orderBy?: EnsaioOrderByWithRelationInput | EnsaioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnsaioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ensaios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ensaios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ensaios
    **/
    _count?: true | EnsaioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnsaioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnsaioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnsaioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnsaioMaxAggregateInputType
  }

  export type GetEnsaioAggregateType<T extends EnsaioAggregateArgs> = {
        [P in keyof T & keyof AggregateEnsaio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnsaio[P]>
      : GetScalarType<T[P], AggregateEnsaio[P]>
  }




  export type EnsaioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnsaioWhereInput
    orderBy?: EnsaioOrderByWithAggregationInput | EnsaioOrderByWithAggregationInput[]
    by: EnsaioScalarFieldEnum[] | EnsaioScalarFieldEnum
    having?: EnsaioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnsaioCountAggregateInputType | true
    _avg?: EnsaioAvgAggregateInputType
    _sum?: EnsaioSumAggregateInputType
    _min?: EnsaioMinAggregateInputType
    _max?: EnsaioMaxAggregateInputType
  }

  export type EnsaioGroupByOutputType = {
    id: number
    titulo: string
    dataHora: Date
    localId: number
    status: string
    responsavelId: number
    createdAt: Date
    updatedAt: Date
    _count: EnsaioCountAggregateOutputType | null
    _avg: EnsaioAvgAggregateOutputType | null
    _sum: EnsaioSumAggregateOutputType | null
    _min: EnsaioMinAggregateOutputType | null
    _max: EnsaioMaxAggregateOutputType | null
  }

  type GetEnsaioGroupByPayload<T extends EnsaioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnsaioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnsaioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnsaioGroupByOutputType[P]>
            : GetScalarType<T[P], EnsaioGroupByOutputType[P]>
        }
      >
    >


  export type EnsaioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    responsavelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
    participantes?: boolean | Ensaio$participantesArgs<ExtArgs>
    hinos?: boolean | Ensaio$hinosArgs<ExtArgs>
    _count?: boolean | EnsaioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ensaio"]>

  export type EnsaioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    responsavelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ensaio"]>

  export type EnsaioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    responsavelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ensaio"]>

  export type EnsaioSelectScalar = {
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    responsavelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EnsaioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "dataHora" | "localId" | "status" | "responsavelId" | "createdAt" | "updatedAt", ExtArgs["result"]["ensaio"]>
  export type EnsaioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
    participantes?: boolean | Ensaio$participantesArgs<ExtArgs>
    hinos?: boolean | Ensaio$hinosArgs<ExtArgs>
    _count?: boolean | EnsaioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EnsaioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EnsaioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
    responsavel?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EnsaioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ensaio"
    objects: {
      local: Prisma.$LocalPayload<ExtArgs>
      responsavel: Prisma.$UserPayload<ExtArgs>
      participantes: Prisma.$UserPayload<ExtArgs>[]
      hinos: Prisma.$HinoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      dataHora: Date
      localId: number
      status: string
      responsavelId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ensaio"]>
    composites: {}
  }

  type EnsaioGetPayload<S extends boolean | null | undefined | EnsaioDefaultArgs> = $Result.GetResult<Prisma.$EnsaioPayload, S>

  type EnsaioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnsaioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnsaioCountAggregateInputType | true
    }

  export interface EnsaioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ensaio'], meta: { name: 'Ensaio' } }
    /**
     * Find zero or one Ensaio that matches the filter.
     * @param {EnsaioFindUniqueArgs} args - Arguments to find a Ensaio
     * @example
     * // Get one Ensaio
     * const ensaio = await prisma.ensaio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnsaioFindUniqueArgs>(args: SelectSubset<T, EnsaioFindUniqueArgs<ExtArgs>>): Prisma__EnsaioClient<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Ensaio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnsaioFindUniqueOrThrowArgs} args - Arguments to find a Ensaio
     * @example
     * // Get one Ensaio
     * const ensaio = await prisma.ensaio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnsaioFindUniqueOrThrowArgs>(args: SelectSubset<T, EnsaioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnsaioClient<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Ensaio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnsaioFindFirstArgs} args - Arguments to find a Ensaio
     * @example
     * // Get one Ensaio
     * const ensaio = await prisma.ensaio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnsaioFindFirstArgs>(args?: SelectSubset<T, EnsaioFindFirstArgs<ExtArgs>>): Prisma__EnsaioClient<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Ensaio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnsaioFindFirstOrThrowArgs} args - Arguments to find a Ensaio
     * @example
     * // Get one Ensaio
     * const ensaio = await prisma.ensaio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnsaioFindFirstOrThrowArgs>(args?: SelectSubset<T, EnsaioFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnsaioClient<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Ensaios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnsaioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ensaios
     * const ensaios = await prisma.ensaio.findMany()
     * 
     * // Get first 10 Ensaios
     * const ensaios = await prisma.ensaio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ensaioWithIdOnly = await prisma.ensaio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnsaioFindManyArgs>(args?: SelectSubset<T, EnsaioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Ensaio.
     * @param {EnsaioCreateArgs} args - Arguments to create a Ensaio.
     * @example
     * // Create one Ensaio
     * const Ensaio = await prisma.ensaio.create({
     *   data: {
     *     // ... data to create a Ensaio
     *   }
     * })
     * 
     */
    create<T extends EnsaioCreateArgs>(args: SelectSubset<T, EnsaioCreateArgs<ExtArgs>>): Prisma__EnsaioClient<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Ensaios.
     * @param {EnsaioCreateManyArgs} args - Arguments to create many Ensaios.
     * @example
     * // Create many Ensaios
     * const ensaio = await prisma.ensaio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnsaioCreateManyArgs>(args?: SelectSubset<T, EnsaioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ensaios and returns the data saved in the database.
     * @param {EnsaioCreateManyAndReturnArgs} args - Arguments to create many Ensaios.
     * @example
     * // Create many Ensaios
     * const ensaio = await prisma.ensaio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ensaios and only return the `id`
     * const ensaioWithIdOnly = await prisma.ensaio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnsaioCreateManyAndReturnArgs>(args?: SelectSubset<T, EnsaioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Ensaio.
     * @param {EnsaioDeleteArgs} args - Arguments to delete one Ensaio.
     * @example
     * // Delete one Ensaio
     * const Ensaio = await prisma.ensaio.delete({
     *   where: {
     *     // ... filter to delete one Ensaio
     *   }
     * })
     * 
     */
    delete<T extends EnsaioDeleteArgs>(args: SelectSubset<T, EnsaioDeleteArgs<ExtArgs>>): Prisma__EnsaioClient<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Ensaio.
     * @param {EnsaioUpdateArgs} args - Arguments to update one Ensaio.
     * @example
     * // Update one Ensaio
     * const ensaio = await prisma.ensaio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnsaioUpdateArgs>(args: SelectSubset<T, EnsaioUpdateArgs<ExtArgs>>): Prisma__EnsaioClient<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Ensaios.
     * @param {EnsaioDeleteManyArgs} args - Arguments to filter Ensaios to delete.
     * @example
     * // Delete a few Ensaios
     * const { count } = await prisma.ensaio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnsaioDeleteManyArgs>(args?: SelectSubset<T, EnsaioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ensaios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnsaioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ensaios
     * const ensaio = await prisma.ensaio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnsaioUpdateManyArgs>(args: SelectSubset<T, EnsaioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ensaios and returns the data updated in the database.
     * @param {EnsaioUpdateManyAndReturnArgs} args - Arguments to update many Ensaios.
     * @example
     * // Update many Ensaios
     * const ensaio = await prisma.ensaio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ensaios and only return the `id`
     * const ensaioWithIdOnly = await prisma.ensaio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnsaioUpdateManyAndReturnArgs>(args: SelectSubset<T, EnsaioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Ensaio.
     * @param {EnsaioUpsertArgs} args - Arguments to update or create a Ensaio.
     * @example
     * // Update or create a Ensaio
     * const ensaio = await prisma.ensaio.upsert({
     *   create: {
     *     // ... data to create a Ensaio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ensaio we want to update
     *   }
     * })
     */
    upsert<T extends EnsaioUpsertArgs>(args: SelectSubset<T, EnsaioUpsertArgs<ExtArgs>>): Prisma__EnsaioClient<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Ensaios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnsaioCountArgs} args - Arguments to filter Ensaios to count.
     * @example
     * // Count the number of Ensaios
     * const count = await prisma.ensaio.count({
     *   where: {
     *     // ... the filter for the Ensaios we want to count
     *   }
     * })
    **/
    count<T extends EnsaioCountArgs>(
      args?: Subset<T, EnsaioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnsaioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ensaio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnsaioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnsaioAggregateArgs>(args: Subset<T, EnsaioAggregateArgs>): Prisma.PrismaPromise<GetEnsaioAggregateType<T>>

    /**
     * Group by Ensaio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnsaioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnsaioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnsaioGroupByArgs['orderBy'] }
        : { orderBy?: EnsaioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnsaioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnsaioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ensaio model
   */
  readonly fields: EnsaioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ensaio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnsaioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    local<T extends LocalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalDefaultArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    responsavel<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    participantes<T extends Ensaio$participantesArgs<ExtArgs> = {}>(args?: Subset<T, Ensaio$participantesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    hinos<T extends Ensaio$hinosArgs<ExtArgs> = {}>(args?: Subset<T, Ensaio$hinosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ensaio model
   */ 
  interface EnsaioFieldRefs {
    readonly id: FieldRef<"Ensaio", 'Int'>
    readonly titulo: FieldRef<"Ensaio", 'String'>
    readonly dataHora: FieldRef<"Ensaio", 'DateTime'>
    readonly localId: FieldRef<"Ensaio", 'Int'>
    readonly status: FieldRef<"Ensaio", 'String'>
    readonly responsavelId: FieldRef<"Ensaio", 'Int'>
    readonly createdAt: FieldRef<"Ensaio", 'DateTime'>
    readonly updatedAt: FieldRef<"Ensaio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ensaio findUnique
   */
  export type EnsaioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    /**
     * Filter, which Ensaio to fetch.
     */
    where: EnsaioWhereUniqueInput
  }

  /**
   * Ensaio findUniqueOrThrow
   */
  export type EnsaioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    /**
     * Filter, which Ensaio to fetch.
     */
    where: EnsaioWhereUniqueInput
  }

  /**
   * Ensaio findFirst
   */
  export type EnsaioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    /**
     * Filter, which Ensaio to fetch.
     */
    where?: EnsaioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ensaios to fetch.
     */
    orderBy?: EnsaioOrderByWithRelationInput | EnsaioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ensaios.
     */
    cursor?: EnsaioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ensaios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ensaios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ensaios.
     */
    distinct?: EnsaioScalarFieldEnum | EnsaioScalarFieldEnum[]
  }

  /**
   * Ensaio findFirstOrThrow
   */
  export type EnsaioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    /**
     * Filter, which Ensaio to fetch.
     */
    where?: EnsaioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ensaios to fetch.
     */
    orderBy?: EnsaioOrderByWithRelationInput | EnsaioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ensaios.
     */
    cursor?: EnsaioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ensaios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ensaios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ensaios.
     */
    distinct?: EnsaioScalarFieldEnum | EnsaioScalarFieldEnum[]
  }

  /**
   * Ensaio findMany
   */
  export type EnsaioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    /**
     * Filter, which Ensaios to fetch.
     */
    where?: EnsaioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ensaios to fetch.
     */
    orderBy?: EnsaioOrderByWithRelationInput | EnsaioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ensaios.
     */
    cursor?: EnsaioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ensaios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ensaios.
     */
    skip?: number
    distinct?: EnsaioScalarFieldEnum | EnsaioScalarFieldEnum[]
  }

  /**
   * Ensaio create
   */
  export type EnsaioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    /**
     * The data needed to create a Ensaio.
     */
    data: XOR<EnsaioCreateInput, EnsaioUncheckedCreateInput>
  }

  /**
   * Ensaio createMany
   */
  export type EnsaioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ensaios.
     */
    data: EnsaioCreateManyInput | EnsaioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ensaio createManyAndReturn
   */
  export type EnsaioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * The data used to create many Ensaios.
     */
    data: EnsaioCreateManyInput | EnsaioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ensaio update
   */
  export type EnsaioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    /**
     * The data needed to update a Ensaio.
     */
    data: XOR<EnsaioUpdateInput, EnsaioUncheckedUpdateInput>
    /**
     * Choose, which Ensaio to update.
     */
    where: EnsaioWhereUniqueInput
  }

  /**
   * Ensaio updateMany
   */
  export type EnsaioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ensaios.
     */
    data: XOR<EnsaioUpdateManyMutationInput, EnsaioUncheckedUpdateManyInput>
    /**
     * Filter which Ensaios to update
     */
    where?: EnsaioWhereInput
  }

  /**
   * Ensaio updateManyAndReturn
   */
  export type EnsaioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * The data used to update Ensaios.
     */
    data: XOR<EnsaioUpdateManyMutationInput, EnsaioUncheckedUpdateManyInput>
    /**
     * Filter which Ensaios to update
     */
    where?: EnsaioWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ensaio upsert
   */
  export type EnsaioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    /**
     * The filter to search for the Ensaio to update in case it exists.
     */
    where: EnsaioWhereUniqueInput
    /**
     * In case the Ensaio found by the `where` argument doesn't exist, create a new Ensaio with this data.
     */
    create: XOR<EnsaioCreateInput, EnsaioUncheckedCreateInput>
    /**
     * In case the Ensaio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnsaioUpdateInput, EnsaioUncheckedUpdateInput>
  }

  /**
   * Ensaio delete
   */
  export type EnsaioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    /**
     * Filter which Ensaio to delete.
     */
    where: EnsaioWhereUniqueInput
  }

  /**
   * Ensaio deleteMany
   */
  export type EnsaioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ensaios to delete
     */
    where?: EnsaioWhereInput
  }

  /**
   * Ensaio.participantes
   */
  export type Ensaio$participantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Ensaio.hinos
   */
  export type Ensaio$hinosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    where?: HinoWhereInput
    orderBy?: HinoOrderByWithRelationInput | HinoOrderByWithRelationInput[]
    cursor?: HinoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HinoScalarFieldEnum | HinoScalarFieldEnum[]
  }

  /**
   * Ensaio without action
   */
  export type EnsaioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
  }


  /**
   * Model Evento
   */

  export type AggregateEvento = {
    _count: EventoCountAggregateOutputType | null
    _avg: EventoAvgAggregateOutputType | null
    _sum: EventoSumAggregateOutputType | null
    _min: EventoMinAggregateOutputType | null
    _max: EventoMaxAggregateOutputType | null
  }

  export type EventoAvgAggregateOutputType = {
    id: number | null
    localId: number | null
  }

  export type EventoSumAggregateOutputType = {
    id: number | null
    localId: number | null
  }

  export type EventoMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    dataHora: Date | null
    localId: number | null
    status: string | null
    cronograma: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventoMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    dataHora: Date | null
    localId: number | null
    status: string | null
    cronograma: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventoCountAggregateOutputType = {
    id: number
    titulo: number
    dataHora: number
    localId: number
    status: number
    cronograma: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventoAvgAggregateInputType = {
    id?: true
    localId?: true
  }

  export type EventoSumAggregateInputType = {
    id?: true
    localId?: true
  }

  export type EventoMinAggregateInputType = {
    id?: true
    titulo?: true
    dataHora?: true
    localId?: true
    status?: true
    cronograma?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventoMaxAggregateInputType = {
    id?: true
    titulo?: true
    dataHora?: true
    localId?: true
    status?: true
    cronograma?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventoCountAggregateInputType = {
    id?: true
    titulo?: true
    dataHora?: true
    localId?: true
    status?: true
    cronograma?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evento to aggregate.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Eventos
    **/
    _count?: true | EventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventoMaxAggregateInputType
  }

  export type GetEventoAggregateType<T extends EventoAggregateArgs> = {
        [P in keyof T & keyof AggregateEvento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvento[P]>
      : GetScalarType<T[P], AggregateEvento[P]>
  }




  export type EventoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoWhereInput
    orderBy?: EventoOrderByWithAggregationInput | EventoOrderByWithAggregationInput[]
    by: EventoScalarFieldEnum[] | EventoScalarFieldEnum
    having?: EventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventoCountAggregateInputType | true
    _avg?: EventoAvgAggregateInputType
    _sum?: EventoSumAggregateInputType
    _min?: EventoMinAggregateInputType
    _max?: EventoMaxAggregateInputType
  }

  export type EventoGroupByOutputType = {
    id: number
    titulo: string
    dataHora: Date
    localId: number
    status: string
    cronograma: string
    createdAt: Date
    updatedAt: Date
    _count: EventoCountAggregateOutputType | null
    _avg: EventoAvgAggregateOutputType | null
    _sum: EventoSumAggregateOutputType | null
    _min: EventoMinAggregateOutputType | null
    _max: EventoMaxAggregateOutputType | null
  }

  type GetEventoGroupByPayload<T extends EventoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventoGroupByOutputType[P]>
            : GetScalarType<T[P], EventoGroupByOutputType[P]>
        }
      >
    >


  export type EventoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    cronograma?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evento"]>

  export type EventoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    cronograma?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evento"]>

  export type EventoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    cronograma?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    local?: boolean | LocalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evento"]>

  export type EventoSelectScalar = {
    id?: boolean
    titulo?: boolean
    dataHora?: boolean
    localId?: boolean
    status?: boolean
    cronograma?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "dataHora" | "localId" | "status" | "cronograma" | "createdAt" | "updatedAt", ExtArgs["result"]["evento"]>
  export type EventoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
  }
  export type EventoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
  }
  export type EventoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    local?: boolean | LocalDefaultArgs<ExtArgs>
  }

  export type $EventoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evento"
    objects: {
      local: Prisma.$LocalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      dataHora: Date
      localId: number
      status: string
      cronograma: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evento"]>
    composites: {}
  }

  type EventoGetPayload<S extends boolean | null | undefined | EventoDefaultArgs> = $Result.GetResult<Prisma.$EventoPayload, S>

  type EventoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventoCountAggregateInputType | true
    }

  export interface EventoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evento'], meta: { name: 'Evento' } }
    /**
     * Find zero or one Evento that matches the filter.
     * @param {EventoFindUniqueArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventoFindUniqueArgs>(args: SelectSubset<T, EventoFindUniqueArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Evento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventoFindUniqueOrThrowArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventoFindUniqueOrThrowArgs>(args: SelectSubset<T, EventoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Evento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindFirstArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventoFindFirstArgs>(args?: SelectSubset<T, EventoFindFirstArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Evento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindFirstOrThrowArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventoFindFirstOrThrowArgs>(args?: SelectSubset<T, EventoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Eventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eventos
     * const eventos = await prisma.evento.findMany()
     * 
     * // Get first 10 Eventos
     * const eventos = await prisma.evento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventoWithIdOnly = await prisma.evento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventoFindManyArgs>(args?: SelectSubset<T, EventoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Evento.
     * @param {EventoCreateArgs} args - Arguments to create a Evento.
     * @example
     * // Create one Evento
     * const Evento = await prisma.evento.create({
     *   data: {
     *     // ... data to create a Evento
     *   }
     * })
     * 
     */
    create<T extends EventoCreateArgs>(args: SelectSubset<T, EventoCreateArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Eventos.
     * @param {EventoCreateManyArgs} args - Arguments to create many Eventos.
     * @example
     * // Create many Eventos
     * const evento = await prisma.evento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventoCreateManyArgs>(args?: SelectSubset<T, EventoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Eventos and returns the data saved in the database.
     * @param {EventoCreateManyAndReturnArgs} args - Arguments to create many Eventos.
     * @example
     * // Create many Eventos
     * const evento = await prisma.evento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Eventos and only return the `id`
     * const eventoWithIdOnly = await prisma.evento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventoCreateManyAndReturnArgs>(args?: SelectSubset<T, EventoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Evento.
     * @param {EventoDeleteArgs} args - Arguments to delete one Evento.
     * @example
     * // Delete one Evento
     * const Evento = await prisma.evento.delete({
     *   where: {
     *     // ... filter to delete one Evento
     *   }
     * })
     * 
     */
    delete<T extends EventoDeleteArgs>(args: SelectSubset<T, EventoDeleteArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Evento.
     * @param {EventoUpdateArgs} args - Arguments to update one Evento.
     * @example
     * // Update one Evento
     * const evento = await prisma.evento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventoUpdateArgs>(args: SelectSubset<T, EventoUpdateArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Eventos.
     * @param {EventoDeleteManyArgs} args - Arguments to filter Eventos to delete.
     * @example
     * // Delete a few Eventos
     * const { count } = await prisma.evento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventoDeleteManyArgs>(args?: SelectSubset<T, EventoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eventos
     * const evento = await prisma.evento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventoUpdateManyArgs>(args: SelectSubset<T, EventoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventos and returns the data updated in the database.
     * @param {EventoUpdateManyAndReturnArgs} args - Arguments to update many Eventos.
     * @example
     * // Update many Eventos
     * const evento = await prisma.evento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Eventos and only return the `id`
     * const eventoWithIdOnly = await prisma.evento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventoUpdateManyAndReturnArgs>(args: SelectSubset<T, EventoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Evento.
     * @param {EventoUpsertArgs} args - Arguments to update or create a Evento.
     * @example
     * // Update or create a Evento
     * const evento = await prisma.evento.upsert({
     *   create: {
     *     // ... data to create a Evento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evento we want to update
     *   }
     * })
     */
    upsert<T extends EventoUpsertArgs>(args: SelectSubset<T, EventoUpsertArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoCountArgs} args - Arguments to filter Eventos to count.
     * @example
     * // Count the number of Eventos
     * const count = await prisma.evento.count({
     *   where: {
     *     // ... the filter for the Eventos we want to count
     *   }
     * })
    **/
    count<T extends EventoCountArgs>(
      args?: Subset<T, EventoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventoAggregateArgs>(args: Subset<T, EventoAggregateArgs>): Prisma.PrismaPromise<GetEventoAggregateType<T>>

    /**
     * Group by Evento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventoGroupByArgs['orderBy'] }
        : { orderBy?: EventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evento model
   */
  readonly fields: EventoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    local<T extends LocalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalDefaultArgs<ExtArgs>>): Prisma__LocalClient<$Result.GetResult<Prisma.$LocalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evento model
   */ 
  interface EventoFieldRefs {
    readonly id: FieldRef<"Evento", 'Int'>
    readonly titulo: FieldRef<"Evento", 'String'>
    readonly dataHora: FieldRef<"Evento", 'DateTime'>
    readonly localId: FieldRef<"Evento", 'Int'>
    readonly status: FieldRef<"Evento", 'String'>
    readonly cronograma: FieldRef<"Evento", 'String'>
    readonly createdAt: FieldRef<"Evento", 'DateTime'>
    readonly updatedAt: FieldRef<"Evento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evento findUnique
   */
  export type EventoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento findUniqueOrThrow
   */
  export type EventoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento findFirst
   */
  export type EventoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eventos.
     */
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento findFirstOrThrow
   */
  export type EventoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eventos.
     */
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento findMany
   */
  export type EventoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Eventos to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento create
   */
  export type EventoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The data needed to create a Evento.
     */
    data: XOR<EventoCreateInput, EventoUncheckedCreateInput>
  }

  /**
   * Evento createMany
   */
  export type EventoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Eventos.
     */
    data: EventoCreateManyInput | EventoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evento createManyAndReturn
   */
  export type EventoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * The data used to create many Eventos.
     */
    data: EventoCreateManyInput | EventoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evento update
   */
  export type EventoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The data needed to update a Evento.
     */
    data: XOR<EventoUpdateInput, EventoUncheckedUpdateInput>
    /**
     * Choose, which Evento to update.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento updateMany
   */
  export type EventoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Eventos.
     */
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyInput>
    /**
     * Filter which Eventos to update
     */
    where?: EventoWhereInput
  }

  /**
   * Evento updateManyAndReturn
   */
  export type EventoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * The data used to update Eventos.
     */
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyInput>
    /**
     * Filter which Eventos to update
     */
    where?: EventoWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evento upsert
   */
  export type EventoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The filter to search for the Evento to update in case it exists.
     */
    where: EventoWhereUniqueInput
    /**
     * In case the Evento found by the `where` argument doesn't exist, create a new Evento with this data.
     */
    create: XOR<EventoCreateInput, EventoUncheckedCreateInput>
    /**
     * In case the Evento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventoUpdateInput, EventoUncheckedUpdateInput>
  }

  /**
   * Evento delete
   */
  export type EventoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter which Evento to delete.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento deleteMany
   */
  export type EventoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eventos to delete
     */
    where?: EventoWhereInput
  }

  /**
   * Evento without action
   */
  export type EventoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evento
     */
    omit?: EventoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
  }


  /**
   * Model Mensagem
   */

  export type AggregateMensagem = {
    _count: MensagemCountAggregateOutputType | null
    _avg: MensagemAvgAggregateOutputType | null
    _sum: MensagemSumAggregateOutputType | null
    _min: MensagemMinAggregateOutputType | null
    _max: MensagemMaxAggregateOutputType | null
  }

  export type MensagemAvgAggregateOutputType = {
    id: number | null
  }

  export type MensagemSumAggregateOutputType = {
    id: number | null
  }

  export type MensagemMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    data: Date | null
    cidade: string | null
    estado: string | null
    pais: string | null
    traduzidoPor: string | null
    conteudo: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MensagemMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    data: Date | null
    cidade: string | null
    estado: string | null
    pais: string | null
    traduzidoPor: string | null
    conteudo: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MensagemCountAggregateOutputType = {
    id: number
    titulo: number
    data: number
    cidade: number
    estado: number
    pais: number
    traduzidoPor: number
    conteudo: number
    pdfUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MensagemAvgAggregateInputType = {
    id?: true
  }

  export type MensagemSumAggregateInputType = {
    id?: true
  }

  export type MensagemMinAggregateInputType = {
    id?: true
    titulo?: true
    data?: true
    cidade?: true
    estado?: true
    pais?: true
    traduzidoPor?: true
    conteudo?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MensagemMaxAggregateInputType = {
    id?: true
    titulo?: true
    data?: true
    cidade?: true
    estado?: true
    pais?: true
    traduzidoPor?: true
    conteudo?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MensagemCountAggregateInputType = {
    id?: true
    titulo?: true
    data?: true
    cidade?: true
    estado?: true
    pais?: true
    traduzidoPor?: true
    conteudo?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MensagemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mensagem to aggregate.
     */
    where?: MensagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensagems to fetch.
     */
    orderBy?: MensagemOrderByWithRelationInput | MensagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MensagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensagems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mensagems
    **/
    _count?: true | MensagemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MensagemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MensagemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MensagemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MensagemMaxAggregateInputType
  }

  export type GetMensagemAggregateType<T extends MensagemAggregateArgs> = {
        [P in keyof T & keyof AggregateMensagem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMensagem[P]>
      : GetScalarType<T[P], AggregateMensagem[P]>
  }




  export type MensagemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MensagemWhereInput
    orderBy?: MensagemOrderByWithAggregationInput | MensagemOrderByWithAggregationInput[]
    by: MensagemScalarFieldEnum[] | MensagemScalarFieldEnum
    having?: MensagemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MensagemCountAggregateInputType | true
    _avg?: MensagemAvgAggregateInputType
    _sum?: MensagemSumAggregateInputType
    _min?: MensagemMinAggregateInputType
    _max?: MensagemMaxAggregateInputType
  }

  export type MensagemGroupByOutputType = {
    id: number
    titulo: string
    data: Date
    cidade: string
    estado: string
    pais: string
    traduzidoPor: string | null
    conteudo: string
    pdfUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: MensagemCountAggregateOutputType | null
    _avg: MensagemAvgAggregateOutputType | null
    _sum: MensagemSumAggregateOutputType | null
    _min: MensagemMinAggregateOutputType | null
    _max: MensagemMaxAggregateOutputType | null
  }

  type GetMensagemGroupByPayload<T extends MensagemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MensagemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MensagemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MensagemGroupByOutputType[P]>
            : GetScalarType<T[P], MensagemGroupByOutputType[P]>
        }
      >
    >


  export type MensagemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    data?: boolean
    cidade?: boolean
    estado?: boolean
    pais?: boolean
    traduzidoPor?: boolean
    conteudo?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cultos?: boolean | Mensagem$cultosArgs<ExtArgs>
    _count?: boolean | MensagemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mensagem"]>

  export type MensagemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    data?: boolean
    cidade?: boolean
    estado?: boolean
    pais?: boolean
    traduzidoPor?: boolean
    conteudo?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mensagem"]>

  export type MensagemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    data?: boolean
    cidade?: boolean
    estado?: boolean
    pais?: boolean
    traduzidoPor?: boolean
    conteudo?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mensagem"]>

  export type MensagemSelectScalar = {
    id?: boolean
    titulo?: boolean
    data?: boolean
    cidade?: boolean
    estado?: boolean
    pais?: boolean
    traduzidoPor?: boolean
    conteudo?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MensagemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "data" | "cidade" | "estado" | "pais" | "traduzidoPor" | "conteudo" | "pdfUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["mensagem"]>
  export type MensagemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cultos?: boolean | Mensagem$cultosArgs<ExtArgs>
    _count?: boolean | MensagemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MensagemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MensagemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MensagemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mensagem"
    objects: {
      cultos: Prisma.$CultoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      data: Date
      cidade: string
      estado: string
      pais: string
      traduzidoPor: string | null
      conteudo: string
      pdfUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mensagem"]>
    composites: {}
  }

  type MensagemGetPayload<S extends boolean | null | undefined | MensagemDefaultArgs> = $Result.GetResult<Prisma.$MensagemPayload, S>

  type MensagemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MensagemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MensagemCountAggregateInputType | true
    }

  export interface MensagemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mensagem'], meta: { name: 'Mensagem' } }
    /**
     * Find zero or one Mensagem that matches the filter.
     * @param {MensagemFindUniqueArgs} args - Arguments to find a Mensagem
     * @example
     * // Get one Mensagem
     * const mensagem = await prisma.mensagem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MensagemFindUniqueArgs>(args: SelectSubset<T, MensagemFindUniqueArgs<ExtArgs>>): Prisma__MensagemClient<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Mensagem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MensagemFindUniqueOrThrowArgs} args - Arguments to find a Mensagem
     * @example
     * // Get one Mensagem
     * const mensagem = await prisma.mensagem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MensagemFindUniqueOrThrowArgs>(args: SelectSubset<T, MensagemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MensagemClient<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Mensagem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemFindFirstArgs} args - Arguments to find a Mensagem
     * @example
     * // Get one Mensagem
     * const mensagem = await prisma.mensagem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MensagemFindFirstArgs>(args?: SelectSubset<T, MensagemFindFirstArgs<ExtArgs>>): Prisma__MensagemClient<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Mensagem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemFindFirstOrThrowArgs} args - Arguments to find a Mensagem
     * @example
     * // Get one Mensagem
     * const mensagem = await prisma.mensagem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MensagemFindFirstOrThrowArgs>(args?: SelectSubset<T, MensagemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MensagemClient<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Mensagems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mensagems
     * const mensagems = await prisma.mensagem.findMany()
     * 
     * // Get first 10 Mensagems
     * const mensagems = await prisma.mensagem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mensagemWithIdOnly = await prisma.mensagem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MensagemFindManyArgs>(args?: SelectSubset<T, MensagemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Mensagem.
     * @param {MensagemCreateArgs} args - Arguments to create a Mensagem.
     * @example
     * // Create one Mensagem
     * const Mensagem = await prisma.mensagem.create({
     *   data: {
     *     // ... data to create a Mensagem
     *   }
     * })
     * 
     */
    create<T extends MensagemCreateArgs>(args: SelectSubset<T, MensagemCreateArgs<ExtArgs>>): Prisma__MensagemClient<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Mensagems.
     * @param {MensagemCreateManyArgs} args - Arguments to create many Mensagems.
     * @example
     * // Create many Mensagems
     * const mensagem = await prisma.mensagem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MensagemCreateManyArgs>(args?: SelectSubset<T, MensagemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mensagems and returns the data saved in the database.
     * @param {MensagemCreateManyAndReturnArgs} args - Arguments to create many Mensagems.
     * @example
     * // Create many Mensagems
     * const mensagem = await prisma.mensagem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mensagems and only return the `id`
     * const mensagemWithIdOnly = await prisma.mensagem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MensagemCreateManyAndReturnArgs>(args?: SelectSubset<T, MensagemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Mensagem.
     * @param {MensagemDeleteArgs} args - Arguments to delete one Mensagem.
     * @example
     * // Delete one Mensagem
     * const Mensagem = await prisma.mensagem.delete({
     *   where: {
     *     // ... filter to delete one Mensagem
     *   }
     * })
     * 
     */
    delete<T extends MensagemDeleteArgs>(args: SelectSubset<T, MensagemDeleteArgs<ExtArgs>>): Prisma__MensagemClient<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Mensagem.
     * @param {MensagemUpdateArgs} args - Arguments to update one Mensagem.
     * @example
     * // Update one Mensagem
     * const mensagem = await prisma.mensagem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MensagemUpdateArgs>(args: SelectSubset<T, MensagemUpdateArgs<ExtArgs>>): Prisma__MensagemClient<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Mensagems.
     * @param {MensagemDeleteManyArgs} args - Arguments to filter Mensagems to delete.
     * @example
     * // Delete a few Mensagems
     * const { count } = await prisma.mensagem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MensagemDeleteManyArgs>(args?: SelectSubset<T, MensagemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mensagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mensagems
     * const mensagem = await prisma.mensagem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MensagemUpdateManyArgs>(args: SelectSubset<T, MensagemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mensagems and returns the data updated in the database.
     * @param {MensagemUpdateManyAndReturnArgs} args - Arguments to update many Mensagems.
     * @example
     * // Update many Mensagems
     * const mensagem = await prisma.mensagem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mensagems and only return the `id`
     * const mensagemWithIdOnly = await prisma.mensagem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MensagemUpdateManyAndReturnArgs>(args: SelectSubset<T, MensagemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Mensagem.
     * @param {MensagemUpsertArgs} args - Arguments to update or create a Mensagem.
     * @example
     * // Update or create a Mensagem
     * const mensagem = await prisma.mensagem.upsert({
     *   create: {
     *     // ... data to create a Mensagem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mensagem we want to update
     *   }
     * })
     */
    upsert<T extends MensagemUpsertArgs>(args: SelectSubset<T, MensagemUpsertArgs<ExtArgs>>): Prisma__MensagemClient<$Result.GetResult<Prisma.$MensagemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Mensagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemCountArgs} args - Arguments to filter Mensagems to count.
     * @example
     * // Count the number of Mensagems
     * const count = await prisma.mensagem.count({
     *   where: {
     *     // ... the filter for the Mensagems we want to count
     *   }
     * })
    **/
    count<T extends MensagemCountArgs>(
      args?: Subset<T, MensagemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MensagemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mensagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MensagemAggregateArgs>(args: Subset<T, MensagemAggregateArgs>): Prisma.PrismaPromise<GetMensagemAggregateType<T>>

    /**
     * Group by Mensagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MensagemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MensagemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MensagemGroupByArgs['orderBy'] }
        : { orderBy?: MensagemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MensagemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMensagemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mensagem model
   */
  readonly fields: MensagemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mensagem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MensagemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cultos<T extends Mensagem$cultosArgs<ExtArgs> = {}>(args?: Subset<T, Mensagem$cultosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mensagem model
   */ 
  interface MensagemFieldRefs {
    readonly id: FieldRef<"Mensagem", 'Int'>
    readonly titulo: FieldRef<"Mensagem", 'String'>
    readonly data: FieldRef<"Mensagem", 'DateTime'>
    readonly cidade: FieldRef<"Mensagem", 'String'>
    readonly estado: FieldRef<"Mensagem", 'String'>
    readonly pais: FieldRef<"Mensagem", 'String'>
    readonly traduzidoPor: FieldRef<"Mensagem", 'String'>
    readonly conteudo: FieldRef<"Mensagem", 'String'>
    readonly pdfUrl: FieldRef<"Mensagem", 'String'>
    readonly createdAt: FieldRef<"Mensagem", 'DateTime'>
    readonly updatedAt: FieldRef<"Mensagem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mensagem findUnique
   */
  export type MensagemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
    /**
     * Filter, which Mensagem to fetch.
     */
    where: MensagemWhereUniqueInput
  }

  /**
   * Mensagem findUniqueOrThrow
   */
  export type MensagemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
    /**
     * Filter, which Mensagem to fetch.
     */
    where: MensagemWhereUniqueInput
  }

  /**
   * Mensagem findFirst
   */
  export type MensagemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
    /**
     * Filter, which Mensagem to fetch.
     */
    where?: MensagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensagems to fetch.
     */
    orderBy?: MensagemOrderByWithRelationInput | MensagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mensagems.
     */
    cursor?: MensagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensagems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mensagems.
     */
    distinct?: MensagemScalarFieldEnum | MensagemScalarFieldEnum[]
  }

  /**
   * Mensagem findFirstOrThrow
   */
  export type MensagemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
    /**
     * Filter, which Mensagem to fetch.
     */
    where?: MensagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensagems to fetch.
     */
    orderBy?: MensagemOrderByWithRelationInput | MensagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mensagems.
     */
    cursor?: MensagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensagems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mensagems.
     */
    distinct?: MensagemScalarFieldEnum | MensagemScalarFieldEnum[]
  }

  /**
   * Mensagem findMany
   */
  export type MensagemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
    /**
     * Filter, which Mensagems to fetch.
     */
    where?: MensagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mensagems to fetch.
     */
    orderBy?: MensagemOrderByWithRelationInput | MensagemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mensagems.
     */
    cursor?: MensagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mensagems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mensagems.
     */
    skip?: number
    distinct?: MensagemScalarFieldEnum | MensagemScalarFieldEnum[]
  }

  /**
   * Mensagem create
   */
  export type MensagemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
    /**
     * The data needed to create a Mensagem.
     */
    data: XOR<MensagemCreateInput, MensagemUncheckedCreateInput>
  }

  /**
   * Mensagem createMany
   */
  export type MensagemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mensagems.
     */
    data: MensagemCreateManyInput | MensagemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mensagem createManyAndReturn
   */
  export type MensagemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * The data used to create many Mensagems.
     */
    data: MensagemCreateManyInput | MensagemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mensagem update
   */
  export type MensagemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
    /**
     * The data needed to update a Mensagem.
     */
    data: XOR<MensagemUpdateInput, MensagemUncheckedUpdateInput>
    /**
     * Choose, which Mensagem to update.
     */
    where: MensagemWhereUniqueInput
  }

  /**
   * Mensagem updateMany
   */
  export type MensagemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mensagems.
     */
    data: XOR<MensagemUpdateManyMutationInput, MensagemUncheckedUpdateManyInput>
    /**
     * Filter which Mensagems to update
     */
    where?: MensagemWhereInput
  }

  /**
   * Mensagem updateManyAndReturn
   */
  export type MensagemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * The data used to update Mensagems.
     */
    data: XOR<MensagemUpdateManyMutationInput, MensagemUncheckedUpdateManyInput>
    /**
     * Filter which Mensagems to update
     */
    where?: MensagemWhereInput
  }

  /**
   * Mensagem upsert
   */
  export type MensagemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
    /**
     * The filter to search for the Mensagem to update in case it exists.
     */
    where: MensagemWhereUniqueInput
    /**
     * In case the Mensagem found by the `where` argument doesn't exist, create a new Mensagem with this data.
     */
    create: XOR<MensagemCreateInput, MensagemUncheckedCreateInput>
    /**
     * In case the Mensagem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MensagemUpdateInput, MensagemUncheckedUpdateInput>
  }

  /**
   * Mensagem delete
   */
  export type MensagemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
    /**
     * Filter which Mensagem to delete.
     */
    where: MensagemWhereUniqueInput
  }

  /**
   * Mensagem deleteMany
   */
  export type MensagemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mensagems to delete
     */
    where?: MensagemWhereInput
  }

  /**
   * Mensagem.cultos
   */
  export type Mensagem$cultosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    where?: CultoWhereInput
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    cursor?: CultoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * Mensagem without action
   */
  export type MensagemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mensagem
     */
    select?: MensagemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mensagem
     */
    omit?: MensagemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MensagemInclude<ExtArgs> | null
  }


  /**
   * Model Hino
   */

  export type AggregateHino = {
    _count: HinoCountAggregateOutputType | null
    _avg: HinoAvgAggregateOutputType | null
    _sum: HinoSumAggregateOutputType | null
    _min: HinoMinAggregateOutputType | null
    _max: HinoMaxAggregateOutputType | null
  }

  export type HinoAvgAggregateOutputType = {
    id: number | null
  }

  export type HinoSumAggregateOutputType = {
    id: number | null
  }

  export type HinoMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    autor: string | null
    letra: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HinoMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    autor: string | null
    letra: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HinoCountAggregateOutputType = {
    id: number
    titulo: number
    autor: number
    letra: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HinoAvgAggregateInputType = {
    id?: true
  }

  export type HinoSumAggregateInputType = {
    id?: true
  }

  export type HinoMinAggregateInputType = {
    id?: true
    titulo?: true
    autor?: true
    letra?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HinoMaxAggregateInputType = {
    id?: true
    titulo?: true
    autor?: true
    letra?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HinoCountAggregateInputType = {
    id?: true
    titulo?: true
    autor?: true
    letra?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HinoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hino to aggregate.
     */
    where?: HinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hinos to fetch.
     */
    orderBy?: HinoOrderByWithRelationInput | HinoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hinos
    **/
    _count?: true | HinoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HinoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HinoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HinoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HinoMaxAggregateInputType
  }

  export type GetHinoAggregateType<T extends HinoAggregateArgs> = {
        [P in keyof T & keyof AggregateHino]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHino[P]>
      : GetScalarType<T[P], AggregateHino[P]>
  }




  export type HinoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HinoWhereInput
    orderBy?: HinoOrderByWithAggregationInput | HinoOrderByWithAggregationInput[]
    by: HinoScalarFieldEnum[] | HinoScalarFieldEnum
    having?: HinoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HinoCountAggregateInputType | true
    _avg?: HinoAvgAggregateInputType
    _sum?: HinoSumAggregateInputType
    _min?: HinoMinAggregateInputType
    _max?: HinoMaxAggregateInputType
  }

  export type HinoGroupByOutputType = {
    id: number
    titulo: string
    autor: string
    letra: string
    createdAt: Date
    updatedAt: Date
    _count: HinoCountAggregateOutputType | null
    _avg: HinoAvgAggregateOutputType | null
    _sum: HinoSumAggregateOutputType | null
    _min: HinoMinAggregateOutputType | null
    _max: HinoMaxAggregateOutputType | null
  }

  type GetHinoGroupByPayload<T extends HinoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HinoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HinoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HinoGroupByOutputType[P]>
            : GetScalarType<T[P], HinoGroupByOutputType[P]>
        }
      >
    >


  export type HinoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    autor?: boolean
    letra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cultos?: boolean | Hino$cultosArgs<ExtArgs>
    ensaios?: boolean | Hino$ensaiosArgs<ExtArgs>
    _count?: boolean | HinoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hino"]>

  export type HinoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    autor?: boolean
    letra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hino"]>

  export type HinoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    autor?: boolean
    letra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hino"]>

  export type HinoSelectScalar = {
    id?: boolean
    titulo?: boolean
    autor?: boolean
    letra?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HinoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "autor" | "letra" | "createdAt" | "updatedAt", ExtArgs["result"]["hino"]>
  export type HinoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cultos?: boolean | Hino$cultosArgs<ExtArgs>
    ensaios?: boolean | Hino$ensaiosArgs<ExtArgs>
    _count?: boolean | HinoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HinoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HinoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HinoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hino"
    objects: {
      cultos: Prisma.$CultoPayload<ExtArgs>[]
      ensaios: Prisma.$EnsaioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      autor: string
      letra: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hino"]>
    composites: {}
  }

  type HinoGetPayload<S extends boolean | null | undefined | HinoDefaultArgs> = $Result.GetResult<Prisma.$HinoPayload, S>

  type HinoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HinoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HinoCountAggregateInputType | true
    }

  export interface HinoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hino'], meta: { name: 'Hino' } }
    /**
     * Find zero or one Hino that matches the filter.
     * @param {HinoFindUniqueArgs} args - Arguments to find a Hino
     * @example
     * // Get one Hino
     * const hino = await prisma.hino.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HinoFindUniqueArgs>(args: SelectSubset<T, HinoFindUniqueArgs<ExtArgs>>): Prisma__HinoClient<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Hino that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HinoFindUniqueOrThrowArgs} args - Arguments to find a Hino
     * @example
     * // Get one Hino
     * const hino = await prisma.hino.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HinoFindUniqueOrThrowArgs>(args: SelectSubset<T, HinoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HinoClient<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Hino that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HinoFindFirstArgs} args - Arguments to find a Hino
     * @example
     * // Get one Hino
     * const hino = await prisma.hino.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HinoFindFirstArgs>(args?: SelectSubset<T, HinoFindFirstArgs<ExtArgs>>): Prisma__HinoClient<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Hino that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HinoFindFirstOrThrowArgs} args - Arguments to find a Hino
     * @example
     * // Get one Hino
     * const hino = await prisma.hino.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HinoFindFirstOrThrowArgs>(args?: SelectSubset<T, HinoFindFirstOrThrowArgs<ExtArgs>>): Prisma__HinoClient<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Hinos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HinoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hinos
     * const hinos = await prisma.hino.findMany()
     * 
     * // Get first 10 Hinos
     * const hinos = await prisma.hino.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hinoWithIdOnly = await prisma.hino.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HinoFindManyArgs>(args?: SelectSubset<T, HinoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Hino.
     * @param {HinoCreateArgs} args - Arguments to create a Hino.
     * @example
     * // Create one Hino
     * const Hino = await prisma.hino.create({
     *   data: {
     *     // ... data to create a Hino
     *   }
     * })
     * 
     */
    create<T extends HinoCreateArgs>(args: SelectSubset<T, HinoCreateArgs<ExtArgs>>): Prisma__HinoClient<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Hinos.
     * @param {HinoCreateManyArgs} args - Arguments to create many Hinos.
     * @example
     * // Create many Hinos
     * const hino = await prisma.hino.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HinoCreateManyArgs>(args?: SelectSubset<T, HinoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hinos and returns the data saved in the database.
     * @param {HinoCreateManyAndReturnArgs} args - Arguments to create many Hinos.
     * @example
     * // Create many Hinos
     * const hino = await prisma.hino.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hinos and only return the `id`
     * const hinoWithIdOnly = await prisma.hino.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HinoCreateManyAndReturnArgs>(args?: SelectSubset<T, HinoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Hino.
     * @param {HinoDeleteArgs} args - Arguments to delete one Hino.
     * @example
     * // Delete one Hino
     * const Hino = await prisma.hino.delete({
     *   where: {
     *     // ... filter to delete one Hino
     *   }
     * })
     * 
     */
    delete<T extends HinoDeleteArgs>(args: SelectSubset<T, HinoDeleteArgs<ExtArgs>>): Prisma__HinoClient<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Hino.
     * @param {HinoUpdateArgs} args - Arguments to update one Hino.
     * @example
     * // Update one Hino
     * const hino = await prisma.hino.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HinoUpdateArgs>(args: SelectSubset<T, HinoUpdateArgs<ExtArgs>>): Prisma__HinoClient<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Hinos.
     * @param {HinoDeleteManyArgs} args - Arguments to filter Hinos to delete.
     * @example
     * // Delete a few Hinos
     * const { count } = await prisma.hino.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HinoDeleteManyArgs>(args?: SelectSubset<T, HinoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HinoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hinos
     * const hino = await prisma.hino.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HinoUpdateManyArgs>(args: SelectSubset<T, HinoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hinos and returns the data updated in the database.
     * @param {HinoUpdateManyAndReturnArgs} args - Arguments to update many Hinos.
     * @example
     * // Update many Hinos
     * const hino = await prisma.hino.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hinos and only return the `id`
     * const hinoWithIdOnly = await prisma.hino.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HinoUpdateManyAndReturnArgs>(args: SelectSubset<T, HinoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Hino.
     * @param {HinoUpsertArgs} args - Arguments to update or create a Hino.
     * @example
     * // Update or create a Hino
     * const hino = await prisma.hino.upsert({
     *   create: {
     *     // ... data to create a Hino
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hino we want to update
     *   }
     * })
     */
    upsert<T extends HinoUpsertArgs>(args: SelectSubset<T, HinoUpsertArgs<ExtArgs>>): Prisma__HinoClient<$Result.GetResult<Prisma.$HinoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Hinos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HinoCountArgs} args - Arguments to filter Hinos to count.
     * @example
     * // Count the number of Hinos
     * const count = await prisma.hino.count({
     *   where: {
     *     // ... the filter for the Hinos we want to count
     *   }
     * })
    **/
    count<T extends HinoCountArgs>(
      args?: Subset<T, HinoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HinoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hino.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HinoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HinoAggregateArgs>(args: Subset<T, HinoAggregateArgs>): Prisma.PrismaPromise<GetHinoAggregateType<T>>

    /**
     * Group by Hino.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HinoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HinoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HinoGroupByArgs['orderBy'] }
        : { orderBy?: HinoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HinoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHinoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hino model
   */
  readonly fields: HinoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hino.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HinoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cultos<T extends Hino$cultosArgs<ExtArgs> = {}>(args?: Subset<T, Hino$cultosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ensaios<T extends Hino$ensaiosArgs<ExtArgs> = {}>(args?: Subset<T, Hino$ensaiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnsaioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hino model
   */ 
  interface HinoFieldRefs {
    readonly id: FieldRef<"Hino", 'Int'>
    readonly titulo: FieldRef<"Hino", 'String'>
    readonly autor: FieldRef<"Hino", 'String'>
    readonly letra: FieldRef<"Hino", 'String'>
    readonly createdAt: FieldRef<"Hino", 'DateTime'>
    readonly updatedAt: FieldRef<"Hino", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hino findUnique
   */
  export type HinoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    /**
     * Filter, which Hino to fetch.
     */
    where: HinoWhereUniqueInput
  }

  /**
   * Hino findUniqueOrThrow
   */
  export type HinoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    /**
     * Filter, which Hino to fetch.
     */
    where: HinoWhereUniqueInput
  }

  /**
   * Hino findFirst
   */
  export type HinoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    /**
     * Filter, which Hino to fetch.
     */
    where?: HinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hinos to fetch.
     */
    orderBy?: HinoOrderByWithRelationInput | HinoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hinos.
     */
    cursor?: HinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hinos.
     */
    distinct?: HinoScalarFieldEnum | HinoScalarFieldEnum[]
  }

  /**
   * Hino findFirstOrThrow
   */
  export type HinoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    /**
     * Filter, which Hino to fetch.
     */
    where?: HinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hinos to fetch.
     */
    orderBy?: HinoOrderByWithRelationInput | HinoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hinos.
     */
    cursor?: HinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hinos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hinos.
     */
    distinct?: HinoScalarFieldEnum | HinoScalarFieldEnum[]
  }

  /**
   * Hino findMany
   */
  export type HinoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    /**
     * Filter, which Hinos to fetch.
     */
    where?: HinoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hinos to fetch.
     */
    orderBy?: HinoOrderByWithRelationInput | HinoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hinos.
     */
    cursor?: HinoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hinos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hinos.
     */
    skip?: number
    distinct?: HinoScalarFieldEnum | HinoScalarFieldEnum[]
  }

  /**
   * Hino create
   */
  export type HinoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    /**
     * The data needed to create a Hino.
     */
    data: XOR<HinoCreateInput, HinoUncheckedCreateInput>
  }

  /**
   * Hino createMany
   */
  export type HinoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hinos.
     */
    data: HinoCreateManyInput | HinoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hino createManyAndReturn
   */
  export type HinoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * The data used to create many Hinos.
     */
    data: HinoCreateManyInput | HinoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hino update
   */
  export type HinoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    /**
     * The data needed to update a Hino.
     */
    data: XOR<HinoUpdateInput, HinoUncheckedUpdateInput>
    /**
     * Choose, which Hino to update.
     */
    where: HinoWhereUniqueInput
  }

  /**
   * Hino updateMany
   */
  export type HinoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hinos.
     */
    data: XOR<HinoUpdateManyMutationInput, HinoUncheckedUpdateManyInput>
    /**
     * Filter which Hinos to update
     */
    where?: HinoWhereInput
  }

  /**
   * Hino updateManyAndReturn
   */
  export type HinoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * The data used to update Hinos.
     */
    data: XOR<HinoUpdateManyMutationInput, HinoUncheckedUpdateManyInput>
    /**
     * Filter which Hinos to update
     */
    where?: HinoWhereInput
  }

  /**
   * Hino upsert
   */
  export type HinoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    /**
     * The filter to search for the Hino to update in case it exists.
     */
    where: HinoWhereUniqueInput
    /**
     * In case the Hino found by the `where` argument doesn't exist, create a new Hino with this data.
     */
    create: XOR<HinoCreateInput, HinoUncheckedCreateInput>
    /**
     * In case the Hino was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HinoUpdateInput, HinoUncheckedUpdateInput>
  }

  /**
   * Hino delete
   */
  export type HinoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
    /**
     * Filter which Hino to delete.
     */
    where: HinoWhereUniqueInput
  }

  /**
   * Hino deleteMany
   */
  export type HinoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hinos to delete
     */
    where?: HinoWhereInput
  }

  /**
   * Hino.cultos
   */
  export type Hino$cultosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    where?: CultoWhereInput
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    cursor?: CultoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * Hino.ensaios
   */
  export type Hino$ensaiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ensaio
     */
    select?: EnsaioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ensaio
     */
    omit?: EnsaioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnsaioInclude<ExtArgs> | null
    where?: EnsaioWhereInput
    orderBy?: EnsaioOrderByWithRelationInput | EnsaioOrderByWithRelationInput[]
    cursor?: EnsaioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnsaioScalarFieldEnum | EnsaioScalarFieldEnum[]
  }

  /**
   * Hino without action
   */
  export type HinoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hino
     */
    select?: HinoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hino
     */
    omit?: HinoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HinoInclude<ExtArgs> | null
  }


  /**
   * Model LeituraBiblica
   */

  export type AggregateLeituraBiblica = {
    _count: LeituraBiblicaCountAggregateOutputType | null
    _avg: LeituraBiblicaAvgAggregateOutputType | null
    _sum: LeituraBiblicaSumAggregateOutputType | null
    _min: LeituraBiblicaMinAggregateOutputType | null
    _max: LeituraBiblicaMaxAggregateOutputType | null
  }

  export type LeituraBiblicaAvgAggregateOutputType = {
    id: number | null
    capitulo: number | null
  }

  export type LeituraBiblicaSumAggregateOutputType = {
    id: number | null
    capitulo: number | null
  }

  export type LeituraBiblicaMinAggregateOutputType = {
    id: number | null
    livro: string | null
    capitulo: number | null
    versiculos: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeituraBiblicaMaxAggregateOutputType = {
    id: number | null
    livro: string | null
    capitulo: number | null
    versiculos: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeituraBiblicaCountAggregateOutputType = {
    id: number
    livro: number
    capitulo: number
    versiculos: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeituraBiblicaAvgAggregateInputType = {
    id?: true
    capitulo?: true
  }

  export type LeituraBiblicaSumAggregateInputType = {
    id?: true
    capitulo?: true
  }

  export type LeituraBiblicaMinAggregateInputType = {
    id?: true
    livro?: true
    capitulo?: true
    versiculos?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeituraBiblicaMaxAggregateInputType = {
    id?: true
    livro?: true
    capitulo?: true
    versiculos?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeituraBiblicaCountAggregateInputType = {
    id?: true
    livro?: true
    capitulo?: true
    versiculos?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeituraBiblicaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeituraBiblica to aggregate.
     */
    where?: LeituraBiblicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeituraBiblicas to fetch.
     */
    orderBy?: LeituraBiblicaOrderByWithRelationInput | LeituraBiblicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeituraBiblicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeituraBiblicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeituraBiblicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeituraBiblicas
    **/
    _count?: true | LeituraBiblicaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeituraBiblicaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeituraBiblicaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeituraBiblicaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeituraBiblicaMaxAggregateInputType
  }

  export type GetLeituraBiblicaAggregateType<T extends LeituraBiblicaAggregateArgs> = {
        [P in keyof T & keyof AggregateLeituraBiblica]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeituraBiblica[P]>
      : GetScalarType<T[P], AggregateLeituraBiblica[P]>
  }




  export type LeituraBiblicaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeituraBiblicaWhereInput
    orderBy?: LeituraBiblicaOrderByWithAggregationInput | LeituraBiblicaOrderByWithAggregationInput[]
    by: LeituraBiblicaScalarFieldEnum[] | LeituraBiblicaScalarFieldEnum
    having?: LeituraBiblicaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeituraBiblicaCountAggregateInputType | true
    _avg?: LeituraBiblicaAvgAggregateInputType
    _sum?: LeituraBiblicaSumAggregateInputType
    _min?: LeituraBiblicaMinAggregateInputType
    _max?: LeituraBiblicaMaxAggregateInputType
  }

  export type LeituraBiblicaGroupByOutputType = {
    id: number
    livro: string
    capitulo: number
    versiculos: string
    createdAt: Date
    updatedAt: Date
    _count: LeituraBiblicaCountAggregateOutputType | null
    _avg: LeituraBiblicaAvgAggregateOutputType | null
    _sum: LeituraBiblicaSumAggregateOutputType | null
    _min: LeituraBiblicaMinAggregateOutputType | null
    _max: LeituraBiblicaMaxAggregateOutputType | null
  }

  type GetLeituraBiblicaGroupByPayload<T extends LeituraBiblicaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeituraBiblicaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeituraBiblicaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeituraBiblicaGroupByOutputType[P]>
            : GetScalarType<T[P], LeituraBiblicaGroupByOutputType[P]>
        }
      >
    >


  export type LeituraBiblicaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livro?: boolean
    capitulo?: boolean
    versiculos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cultos?: boolean | LeituraBiblica$cultosArgs<ExtArgs>
    _count?: boolean | LeituraBiblicaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leituraBiblica"]>

  export type LeituraBiblicaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livro?: boolean
    capitulo?: boolean
    versiculos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["leituraBiblica"]>

  export type LeituraBiblicaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    livro?: boolean
    capitulo?: boolean
    versiculos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["leituraBiblica"]>

  export type LeituraBiblicaSelectScalar = {
    id?: boolean
    livro?: boolean
    capitulo?: boolean
    versiculos?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeituraBiblicaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "livro" | "capitulo" | "versiculos" | "createdAt" | "updatedAt", ExtArgs["result"]["leituraBiblica"]>
  export type LeituraBiblicaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cultos?: boolean | LeituraBiblica$cultosArgs<ExtArgs>
    _count?: boolean | LeituraBiblicaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeituraBiblicaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LeituraBiblicaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LeituraBiblicaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeituraBiblica"
    objects: {
      cultos: Prisma.$CultoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      livro: string
      capitulo: number
      versiculos: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leituraBiblica"]>
    composites: {}
  }

  type LeituraBiblicaGetPayload<S extends boolean | null | undefined | LeituraBiblicaDefaultArgs> = $Result.GetResult<Prisma.$LeituraBiblicaPayload, S>

  type LeituraBiblicaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeituraBiblicaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeituraBiblicaCountAggregateInputType | true
    }

  export interface LeituraBiblicaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeituraBiblica'], meta: { name: 'LeituraBiblica' } }
    /**
     * Find zero or one LeituraBiblica that matches the filter.
     * @param {LeituraBiblicaFindUniqueArgs} args - Arguments to find a LeituraBiblica
     * @example
     * // Get one LeituraBiblica
     * const leituraBiblica = await prisma.leituraBiblica.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeituraBiblicaFindUniqueArgs>(args: SelectSubset<T, LeituraBiblicaFindUniqueArgs<ExtArgs>>): Prisma__LeituraBiblicaClient<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LeituraBiblica that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeituraBiblicaFindUniqueOrThrowArgs} args - Arguments to find a LeituraBiblica
     * @example
     * // Get one LeituraBiblica
     * const leituraBiblica = await prisma.leituraBiblica.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeituraBiblicaFindUniqueOrThrowArgs>(args: SelectSubset<T, LeituraBiblicaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeituraBiblicaClient<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LeituraBiblica that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraBiblicaFindFirstArgs} args - Arguments to find a LeituraBiblica
     * @example
     * // Get one LeituraBiblica
     * const leituraBiblica = await prisma.leituraBiblica.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeituraBiblicaFindFirstArgs>(args?: SelectSubset<T, LeituraBiblicaFindFirstArgs<ExtArgs>>): Prisma__LeituraBiblicaClient<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LeituraBiblica that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraBiblicaFindFirstOrThrowArgs} args - Arguments to find a LeituraBiblica
     * @example
     * // Get one LeituraBiblica
     * const leituraBiblica = await prisma.leituraBiblica.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeituraBiblicaFindFirstOrThrowArgs>(args?: SelectSubset<T, LeituraBiblicaFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeituraBiblicaClient<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LeituraBiblicas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraBiblicaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeituraBiblicas
     * const leituraBiblicas = await prisma.leituraBiblica.findMany()
     * 
     * // Get first 10 LeituraBiblicas
     * const leituraBiblicas = await prisma.leituraBiblica.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leituraBiblicaWithIdOnly = await prisma.leituraBiblica.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeituraBiblicaFindManyArgs>(args?: SelectSubset<T, LeituraBiblicaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LeituraBiblica.
     * @param {LeituraBiblicaCreateArgs} args - Arguments to create a LeituraBiblica.
     * @example
     * // Create one LeituraBiblica
     * const LeituraBiblica = await prisma.leituraBiblica.create({
     *   data: {
     *     // ... data to create a LeituraBiblica
     *   }
     * })
     * 
     */
    create<T extends LeituraBiblicaCreateArgs>(args: SelectSubset<T, LeituraBiblicaCreateArgs<ExtArgs>>): Prisma__LeituraBiblicaClient<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LeituraBiblicas.
     * @param {LeituraBiblicaCreateManyArgs} args - Arguments to create many LeituraBiblicas.
     * @example
     * // Create many LeituraBiblicas
     * const leituraBiblica = await prisma.leituraBiblica.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeituraBiblicaCreateManyArgs>(args?: SelectSubset<T, LeituraBiblicaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeituraBiblicas and returns the data saved in the database.
     * @param {LeituraBiblicaCreateManyAndReturnArgs} args - Arguments to create many LeituraBiblicas.
     * @example
     * // Create many LeituraBiblicas
     * const leituraBiblica = await prisma.leituraBiblica.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeituraBiblicas and only return the `id`
     * const leituraBiblicaWithIdOnly = await prisma.leituraBiblica.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeituraBiblicaCreateManyAndReturnArgs>(args?: SelectSubset<T, LeituraBiblicaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LeituraBiblica.
     * @param {LeituraBiblicaDeleteArgs} args - Arguments to delete one LeituraBiblica.
     * @example
     * // Delete one LeituraBiblica
     * const LeituraBiblica = await prisma.leituraBiblica.delete({
     *   where: {
     *     // ... filter to delete one LeituraBiblica
     *   }
     * })
     * 
     */
    delete<T extends LeituraBiblicaDeleteArgs>(args: SelectSubset<T, LeituraBiblicaDeleteArgs<ExtArgs>>): Prisma__LeituraBiblicaClient<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LeituraBiblica.
     * @param {LeituraBiblicaUpdateArgs} args - Arguments to update one LeituraBiblica.
     * @example
     * // Update one LeituraBiblica
     * const leituraBiblica = await prisma.leituraBiblica.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeituraBiblicaUpdateArgs>(args: SelectSubset<T, LeituraBiblicaUpdateArgs<ExtArgs>>): Prisma__LeituraBiblicaClient<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LeituraBiblicas.
     * @param {LeituraBiblicaDeleteManyArgs} args - Arguments to filter LeituraBiblicas to delete.
     * @example
     * // Delete a few LeituraBiblicas
     * const { count } = await prisma.leituraBiblica.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeituraBiblicaDeleteManyArgs>(args?: SelectSubset<T, LeituraBiblicaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeituraBiblicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraBiblicaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeituraBiblicas
     * const leituraBiblica = await prisma.leituraBiblica.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeituraBiblicaUpdateManyArgs>(args: SelectSubset<T, LeituraBiblicaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeituraBiblicas and returns the data updated in the database.
     * @param {LeituraBiblicaUpdateManyAndReturnArgs} args - Arguments to update many LeituraBiblicas.
     * @example
     * // Update many LeituraBiblicas
     * const leituraBiblica = await prisma.leituraBiblica.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeituraBiblicas and only return the `id`
     * const leituraBiblicaWithIdOnly = await prisma.leituraBiblica.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeituraBiblicaUpdateManyAndReturnArgs>(args: SelectSubset<T, LeituraBiblicaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LeituraBiblica.
     * @param {LeituraBiblicaUpsertArgs} args - Arguments to update or create a LeituraBiblica.
     * @example
     * // Update or create a LeituraBiblica
     * const leituraBiblica = await prisma.leituraBiblica.upsert({
     *   create: {
     *     // ... data to create a LeituraBiblica
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeituraBiblica we want to update
     *   }
     * })
     */
    upsert<T extends LeituraBiblicaUpsertArgs>(args: SelectSubset<T, LeituraBiblicaUpsertArgs<ExtArgs>>): Prisma__LeituraBiblicaClient<$Result.GetResult<Prisma.$LeituraBiblicaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LeituraBiblicas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraBiblicaCountArgs} args - Arguments to filter LeituraBiblicas to count.
     * @example
     * // Count the number of LeituraBiblicas
     * const count = await prisma.leituraBiblica.count({
     *   where: {
     *     // ... the filter for the LeituraBiblicas we want to count
     *   }
     * })
    **/
    count<T extends LeituraBiblicaCountArgs>(
      args?: Subset<T, LeituraBiblicaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeituraBiblicaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeituraBiblica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraBiblicaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeituraBiblicaAggregateArgs>(args: Subset<T, LeituraBiblicaAggregateArgs>): Prisma.PrismaPromise<GetLeituraBiblicaAggregateType<T>>

    /**
     * Group by LeituraBiblica.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraBiblicaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeituraBiblicaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeituraBiblicaGroupByArgs['orderBy'] }
        : { orderBy?: LeituraBiblicaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeituraBiblicaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeituraBiblicaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeituraBiblica model
   */
  readonly fields: LeituraBiblicaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeituraBiblica.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeituraBiblicaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cultos<T extends LeituraBiblica$cultosArgs<ExtArgs> = {}>(args?: Subset<T, LeituraBiblica$cultosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CultoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeituraBiblica model
   */ 
  interface LeituraBiblicaFieldRefs {
    readonly id: FieldRef<"LeituraBiblica", 'Int'>
    readonly livro: FieldRef<"LeituraBiblica", 'String'>
    readonly capitulo: FieldRef<"LeituraBiblica", 'Int'>
    readonly versiculos: FieldRef<"LeituraBiblica", 'String'>
    readonly createdAt: FieldRef<"LeituraBiblica", 'DateTime'>
    readonly updatedAt: FieldRef<"LeituraBiblica", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeituraBiblica findUnique
   */
  export type LeituraBiblicaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
    /**
     * Filter, which LeituraBiblica to fetch.
     */
    where: LeituraBiblicaWhereUniqueInput
  }

  /**
   * LeituraBiblica findUniqueOrThrow
   */
  export type LeituraBiblicaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
    /**
     * Filter, which LeituraBiblica to fetch.
     */
    where: LeituraBiblicaWhereUniqueInput
  }

  /**
   * LeituraBiblica findFirst
   */
  export type LeituraBiblicaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
    /**
     * Filter, which LeituraBiblica to fetch.
     */
    where?: LeituraBiblicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeituraBiblicas to fetch.
     */
    orderBy?: LeituraBiblicaOrderByWithRelationInput | LeituraBiblicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeituraBiblicas.
     */
    cursor?: LeituraBiblicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeituraBiblicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeituraBiblicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeituraBiblicas.
     */
    distinct?: LeituraBiblicaScalarFieldEnum | LeituraBiblicaScalarFieldEnum[]
  }

  /**
   * LeituraBiblica findFirstOrThrow
   */
  export type LeituraBiblicaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
    /**
     * Filter, which LeituraBiblica to fetch.
     */
    where?: LeituraBiblicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeituraBiblicas to fetch.
     */
    orderBy?: LeituraBiblicaOrderByWithRelationInput | LeituraBiblicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeituraBiblicas.
     */
    cursor?: LeituraBiblicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeituraBiblicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeituraBiblicas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeituraBiblicas.
     */
    distinct?: LeituraBiblicaScalarFieldEnum | LeituraBiblicaScalarFieldEnum[]
  }

  /**
   * LeituraBiblica findMany
   */
  export type LeituraBiblicaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
    /**
     * Filter, which LeituraBiblicas to fetch.
     */
    where?: LeituraBiblicaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeituraBiblicas to fetch.
     */
    orderBy?: LeituraBiblicaOrderByWithRelationInput | LeituraBiblicaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeituraBiblicas.
     */
    cursor?: LeituraBiblicaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeituraBiblicas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeituraBiblicas.
     */
    skip?: number
    distinct?: LeituraBiblicaScalarFieldEnum | LeituraBiblicaScalarFieldEnum[]
  }

  /**
   * LeituraBiblica create
   */
  export type LeituraBiblicaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
    /**
     * The data needed to create a LeituraBiblica.
     */
    data: XOR<LeituraBiblicaCreateInput, LeituraBiblicaUncheckedCreateInput>
  }

  /**
   * LeituraBiblica createMany
   */
  export type LeituraBiblicaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeituraBiblicas.
     */
    data: LeituraBiblicaCreateManyInput | LeituraBiblicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeituraBiblica createManyAndReturn
   */
  export type LeituraBiblicaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * The data used to create many LeituraBiblicas.
     */
    data: LeituraBiblicaCreateManyInput | LeituraBiblicaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeituraBiblica update
   */
  export type LeituraBiblicaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
    /**
     * The data needed to update a LeituraBiblica.
     */
    data: XOR<LeituraBiblicaUpdateInput, LeituraBiblicaUncheckedUpdateInput>
    /**
     * Choose, which LeituraBiblica to update.
     */
    where: LeituraBiblicaWhereUniqueInput
  }

  /**
   * LeituraBiblica updateMany
   */
  export type LeituraBiblicaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeituraBiblicas.
     */
    data: XOR<LeituraBiblicaUpdateManyMutationInput, LeituraBiblicaUncheckedUpdateManyInput>
    /**
     * Filter which LeituraBiblicas to update
     */
    where?: LeituraBiblicaWhereInput
  }

  /**
   * LeituraBiblica updateManyAndReturn
   */
  export type LeituraBiblicaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * The data used to update LeituraBiblicas.
     */
    data: XOR<LeituraBiblicaUpdateManyMutationInput, LeituraBiblicaUncheckedUpdateManyInput>
    /**
     * Filter which LeituraBiblicas to update
     */
    where?: LeituraBiblicaWhereInput
  }

  /**
   * LeituraBiblica upsert
   */
  export type LeituraBiblicaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
    /**
     * The filter to search for the LeituraBiblica to update in case it exists.
     */
    where: LeituraBiblicaWhereUniqueInput
    /**
     * In case the LeituraBiblica found by the `where` argument doesn't exist, create a new LeituraBiblica with this data.
     */
    create: XOR<LeituraBiblicaCreateInput, LeituraBiblicaUncheckedCreateInput>
    /**
     * In case the LeituraBiblica was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeituraBiblicaUpdateInput, LeituraBiblicaUncheckedUpdateInput>
  }

  /**
   * LeituraBiblica delete
   */
  export type LeituraBiblicaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
    /**
     * Filter which LeituraBiblica to delete.
     */
    where: LeituraBiblicaWhereUniqueInput
  }

  /**
   * LeituraBiblica deleteMany
   */
  export type LeituraBiblicaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeituraBiblicas to delete
     */
    where?: LeituraBiblicaWhereInput
  }

  /**
   * LeituraBiblica.cultos
   */
  export type LeituraBiblica$cultosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Culto
     */
    select?: CultoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Culto
     */
    omit?: CultoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CultoInclude<ExtArgs> | null
    where?: CultoWhereInput
    orderBy?: CultoOrderByWithRelationInput | CultoOrderByWithRelationInput[]
    cursor?: CultoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CultoScalarFieldEnum | CultoScalarFieldEnum[]
  }

  /**
   * LeituraBiblica without action
   */
  export type LeituraBiblicaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeituraBiblica
     */
    select?: LeituraBiblicaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeituraBiblica
     */
    omit?: LeituraBiblicaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeituraBiblicaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    name: 'name',
    email: 'email',
    cargoId: 'cargoId',
    online: 'online',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LiveScalarFieldEnum: {
    id: 'id',
    youtubeId: 'youtubeId',
    title: 'title',
    viewers: 'viewers',
    isActive: 'isActive',
    ofertaAtiva: 'ofertaAtiva',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LiveScalarFieldEnum = (typeof LiveScalarFieldEnum)[keyof typeof LiveScalarFieldEnum]


  export const LeituraScalarFieldEnum: {
    id: 'id',
    texto: 'texto',
    minuto: 'minuto',
    liveId: 'liveId',
    createdAt: 'createdAt'
  };

  export type LeituraScalarFieldEnum = (typeof LeituraScalarFieldEnum)[keyof typeof LeituraScalarFieldEnum]


  export const PedidoOracaoScalarFieldEnum: {
    id: 'id',
    para: 'para',
    motivo: 'motivo',
    liveId: 'liveId',
    createdAt: 'createdAt'
  };

  export type PedidoOracaoScalarFieldEnum = (typeof PedidoOracaoScalarFieldEnum)[keyof typeof PedidoOracaoScalarFieldEnum]


  export const ViewerSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userName: 'userName',
    userImage: 'userImage',
    liveId: 'liveId',
    createdAt: 'createdAt',
    endedAt: 'endedAt'
  };

  export type ViewerSessionScalarFieldEnum = (typeof ViewerSessionScalarFieldEnum)[keyof typeof ViewerSessionScalarFieldEnum]


  export const CargoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type CargoScalarFieldEnum = (typeof CargoScalarFieldEnum)[keyof typeof CargoScalarFieldEnum]


  export const LocalScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    latitude: 'latitude',
    longitude: 'longitude'
  };

  export type LocalScalarFieldEnum = (typeof LocalScalarFieldEnum)[keyof typeof LocalScalarFieldEnum]


  export const CultoScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    dataInicio: 'dataInicio',
    dataTermino: 'dataTermino',
    localId: 'localId',
    status: 'status',
    pastorId: 'pastorId',
    obreiroId: 'obreiroId',
    liderCanticoId: 'liderCanticoId',
    videoUrl: 'videoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CultoScalarFieldEnum = (typeof CultoScalarFieldEnum)[keyof typeof CultoScalarFieldEnum]


  export const ReuniaoScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    dataHora: 'dataHora',
    localId: 'localId',
    status: 'status',
    responsavelId: 'responsavelId',
    materiais: 'materiais',
    cronograma: 'cronograma',
    informacoes: 'informacoes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReuniaoScalarFieldEnum = (typeof ReuniaoScalarFieldEnum)[keyof typeof ReuniaoScalarFieldEnum]


  export const EnsaioScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    dataHora: 'dataHora',
    localId: 'localId',
    status: 'status',
    responsavelId: 'responsavelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EnsaioScalarFieldEnum = (typeof EnsaioScalarFieldEnum)[keyof typeof EnsaioScalarFieldEnum]


  export const EventoScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    dataHora: 'dataHora',
    localId: 'localId',
    status: 'status',
    cronograma: 'cronograma',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventoScalarFieldEnum = (typeof EventoScalarFieldEnum)[keyof typeof EventoScalarFieldEnum]


  export const MensagemScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    data: 'data',
    cidade: 'cidade',
    estado: 'estado',
    pais: 'pais',
    traduzidoPor: 'traduzidoPor',
    conteudo: 'conteudo',
    pdfUrl: 'pdfUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MensagemScalarFieldEnum = (typeof MensagemScalarFieldEnum)[keyof typeof MensagemScalarFieldEnum]


  export const HinoScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    autor: 'autor',
    letra: 'letra',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HinoScalarFieldEnum = (typeof HinoScalarFieldEnum)[keyof typeof HinoScalarFieldEnum]


  export const LeituraBiblicaScalarFieldEnum: {
    id: 'id',
    livro: 'livro',
    capitulo: 'capitulo',
    versiculos: 'versiculos',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeituraBiblicaScalarFieldEnum = (typeof LeituraBiblicaScalarFieldEnum)[keyof typeof LeituraBiblicaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    cargoId?: IntNullableFilter<"User"> | number | null
    online?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    cargo?: XOR<CargoNullableScalarRelationFilter, CargoWhereInput> | null
    cultosComoPastor?: CultoListRelationFilter
    cultosComoObreiro?: CultoListRelationFilter
    cultosComoAuxiliar?: CultoListRelationFilter
    cultosComoLiderCantico?: CultoListRelationFilter
    cultosComoVocal?: CultoListRelationFilter
    reunioesResponsavel?: ReuniaoListRelationFilter
    ensaiosResponsavel?: EnsaioListRelationFilter
    participaEnsaios?: EnsaioListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    cargoId?: SortOrderInput | SortOrder
    online?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cargo?: CargoOrderByWithRelationInput
    cultosComoPastor?: CultoOrderByRelationAggregateInput
    cultosComoObreiro?: CultoOrderByRelationAggregateInput
    cultosComoAuxiliar?: CultoOrderByRelationAggregateInput
    cultosComoLiderCantico?: CultoOrderByRelationAggregateInput
    cultosComoVocal?: CultoOrderByRelationAggregateInput
    reunioesResponsavel?: ReuniaoOrderByRelationAggregateInput
    ensaiosResponsavel?: EnsaioOrderByRelationAggregateInput
    participaEnsaios?: EnsaioOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    cargoId?: IntNullableFilter<"User"> | number | null
    online?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    cargo?: XOR<CargoNullableScalarRelationFilter, CargoWhereInput> | null
    cultosComoPastor?: CultoListRelationFilter
    cultosComoObreiro?: CultoListRelationFilter
    cultosComoAuxiliar?: CultoListRelationFilter
    cultosComoLiderCantico?: CultoListRelationFilter
    cultosComoVocal?: CultoListRelationFilter
    reunioesResponsavel?: ReuniaoListRelationFilter
    ensaiosResponsavel?: EnsaioListRelationFilter
    participaEnsaios?: EnsaioListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    cargoId?: SortOrderInput | SortOrder
    online?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    cargoId?: IntNullableWithAggregatesFilter<"User"> | number | null
    online?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type LiveWhereInput = {
    AND?: LiveWhereInput | LiveWhereInput[]
    OR?: LiveWhereInput[]
    NOT?: LiveWhereInput | LiveWhereInput[]
    id?: IntFilter<"Live"> | number
    youtubeId?: StringFilter<"Live"> | string
    title?: StringFilter<"Live"> | string
    viewers?: IntFilter<"Live"> | number
    isActive?: BoolFilter<"Live"> | boolean
    ofertaAtiva?: BoolFilter<"Live"> | boolean
    createdAt?: DateTimeFilter<"Live"> | Date | string
    updatedAt?: DateTimeFilter<"Live"> | Date | string
    leituras?: LeituraListRelationFilter
    pedidosOracao?: PedidoOracaoListRelationFilter
    viewerSessions?: ViewerSessionListRelationFilter
  }

  export type LiveOrderByWithRelationInput = {
    id?: SortOrder
    youtubeId?: SortOrder
    title?: SortOrder
    viewers?: SortOrder
    isActive?: SortOrder
    ofertaAtiva?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leituras?: LeituraOrderByRelationAggregateInput
    pedidosOracao?: PedidoOracaoOrderByRelationAggregateInput
    viewerSessions?: ViewerSessionOrderByRelationAggregateInput
  }

  export type LiveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    youtubeId?: string
    AND?: LiveWhereInput | LiveWhereInput[]
    OR?: LiveWhereInput[]
    NOT?: LiveWhereInput | LiveWhereInput[]
    title?: StringFilter<"Live"> | string
    viewers?: IntFilter<"Live"> | number
    isActive?: BoolFilter<"Live"> | boolean
    ofertaAtiva?: BoolFilter<"Live"> | boolean
    createdAt?: DateTimeFilter<"Live"> | Date | string
    updatedAt?: DateTimeFilter<"Live"> | Date | string
    leituras?: LeituraListRelationFilter
    pedidosOracao?: PedidoOracaoListRelationFilter
    viewerSessions?: ViewerSessionListRelationFilter
  }, "id" | "youtubeId">

  export type LiveOrderByWithAggregationInput = {
    id?: SortOrder
    youtubeId?: SortOrder
    title?: SortOrder
    viewers?: SortOrder
    isActive?: SortOrder
    ofertaAtiva?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LiveCountOrderByAggregateInput
    _avg?: LiveAvgOrderByAggregateInput
    _max?: LiveMaxOrderByAggregateInput
    _min?: LiveMinOrderByAggregateInput
    _sum?: LiveSumOrderByAggregateInput
  }

  export type LiveScalarWhereWithAggregatesInput = {
    AND?: LiveScalarWhereWithAggregatesInput | LiveScalarWhereWithAggregatesInput[]
    OR?: LiveScalarWhereWithAggregatesInput[]
    NOT?: LiveScalarWhereWithAggregatesInput | LiveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Live"> | number
    youtubeId?: StringWithAggregatesFilter<"Live"> | string
    title?: StringWithAggregatesFilter<"Live"> | string
    viewers?: IntWithAggregatesFilter<"Live"> | number
    isActive?: BoolWithAggregatesFilter<"Live"> | boolean
    ofertaAtiva?: BoolWithAggregatesFilter<"Live"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Live"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Live"> | Date | string
  }

  export type LeituraWhereInput = {
    AND?: LeituraWhereInput | LeituraWhereInput[]
    OR?: LeituraWhereInput[]
    NOT?: LeituraWhereInput | LeituraWhereInput[]
    id?: IntFilter<"Leitura"> | number
    texto?: StringFilter<"Leitura"> | string
    minuto?: StringFilter<"Leitura"> | string
    liveId?: IntFilter<"Leitura"> | number
    createdAt?: DateTimeFilter<"Leitura"> | Date | string
    live?: XOR<LiveScalarRelationFilter, LiveWhereInput>
  }

  export type LeituraOrderByWithRelationInput = {
    id?: SortOrder
    texto?: SortOrder
    minuto?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
    live?: LiveOrderByWithRelationInput
  }

  export type LeituraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeituraWhereInput | LeituraWhereInput[]
    OR?: LeituraWhereInput[]
    NOT?: LeituraWhereInput | LeituraWhereInput[]
    texto?: StringFilter<"Leitura"> | string
    minuto?: StringFilter<"Leitura"> | string
    liveId?: IntFilter<"Leitura"> | number
    createdAt?: DateTimeFilter<"Leitura"> | Date | string
    live?: XOR<LiveScalarRelationFilter, LiveWhereInput>
  }, "id">

  export type LeituraOrderByWithAggregationInput = {
    id?: SortOrder
    texto?: SortOrder
    minuto?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
    _count?: LeituraCountOrderByAggregateInput
    _avg?: LeituraAvgOrderByAggregateInput
    _max?: LeituraMaxOrderByAggregateInput
    _min?: LeituraMinOrderByAggregateInput
    _sum?: LeituraSumOrderByAggregateInput
  }

  export type LeituraScalarWhereWithAggregatesInput = {
    AND?: LeituraScalarWhereWithAggregatesInput | LeituraScalarWhereWithAggregatesInput[]
    OR?: LeituraScalarWhereWithAggregatesInput[]
    NOT?: LeituraScalarWhereWithAggregatesInput | LeituraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leitura"> | number
    texto?: StringWithAggregatesFilter<"Leitura"> | string
    minuto?: StringWithAggregatesFilter<"Leitura"> | string
    liveId?: IntWithAggregatesFilter<"Leitura"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Leitura"> | Date | string
  }

  export type PedidoOracaoWhereInput = {
    AND?: PedidoOracaoWhereInput | PedidoOracaoWhereInput[]
    OR?: PedidoOracaoWhereInput[]
    NOT?: PedidoOracaoWhereInput | PedidoOracaoWhereInput[]
    id?: IntFilter<"PedidoOracao"> | number
    para?: StringFilter<"PedidoOracao"> | string
    motivo?: StringFilter<"PedidoOracao"> | string
    liveId?: IntFilter<"PedidoOracao"> | number
    createdAt?: DateTimeFilter<"PedidoOracao"> | Date | string
    live?: XOR<LiveScalarRelationFilter, LiveWhereInput>
  }

  export type PedidoOracaoOrderByWithRelationInput = {
    id?: SortOrder
    para?: SortOrder
    motivo?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
    live?: LiveOrderByWithRelationInput
  }

  export type PedidoOracaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PedidoOracaoWhereInput | PedidoOracaoWhereInput[]
    OR?: PedidoOracaoWhereInput[]
    NOT?: PedidoOracaoWhereInput | PedidoOracaoWhereInput[]
    para?: StringFilter<"PedidoOracao"> | string
    motivo?: StringFilter<"PedidoOracao"> | string
    liveId?: IntFilter<"PedidoOracao"> | number
    createdAt?: DateTimeFilter<"PedidoOracao"> | Date | string
    live?: XOR<LiveScalarRelationFilter, LiveWhereInput>
  }, "id">

  export type PedidoOracaoOrderByWithAggregationInput = {
    id?: SortOrder
    para?: SortOrder
    motivo?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
    _count?: PedidoOracaoCountOrderByAggregateInput
    _avg?: PedidoOracaoAvgOrderByAggregateInput
    _max?: PedidoOracaoMaxOrderByAggregateInput
    _min?: PedidoOracaoMinOrderByAggregateInput
    _sum?: PedidoOracaoSumOrderByAggregateInput
  }

  export type PedidoOracaoScalarWhereWithAggregatesInput = {
    AND?: PedidoOracaoScalarWhereWithAggregatesInput | PedidoOracaoScalarWhereWithAggregatesInput[]
    OR?: PedidoOracaoScalarWhereWithAggregatesInput[]
    NOT?: PedidoOracaoScalarWhereWithAggregatesInput | PedidoOracaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PedidoOracao"> | number
    para?: StringWithAggregatesFilter<"PedidoOracao"> | string
    motivo?: StringWithAggregatesFilter<"PedidoOracao"> | string
    liveId?: IntWithAggregatesFilter<"PedidoOracao"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PedidoOracao"> | Date | string
  }

  export type ViewerSessionWhereInput = {
    AND?: ViewerSessionWhereInput | ViewerSessionWhereInput[]
    OR?: ViewerSessionWhereInput[]
    NOT?: ViewerSessionWhereInput | ViewerSessionWhereInput[]
    id?: IntFilter<"ViewerSession"> | number
    sessionId?: StringFilter<"ViewerSession"> | string
    userName?: StringNullableFilter<"ViewerSession"> | string | null
    userImage?: StringNullableFilter<"ViewerSession"> | string | null
    liveId?: IntFilter<"ViewerSession"> | number
    createdAt?: DateTimeFilter<"ViewerSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"ViewerSession"> | Date | string | null
    live?: XOR<LiveScalarRelationFilter, LiveWhereInput>
  }

  export type ViewerSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userName?: SortOrderInput | SortOrder
    userImage?: SortOrderInput | SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    live?: LiveOrderByWithRelationInput
  }

  export type ViewerSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionId?: string
    AND?: ViewerSessionWhereInput | ViewerSessionWhereInput[]
    OR?: ViewerSessionWhereInput[]
    NOT?: ViewerSessionWhereInput | ViewerSessionWhereInput[]
    userName?: StringNullableFilter<"ViewerSession"> | string | null
    userImage?: StringNullableFilter<"ViewerSession"> | string | null
    liveId?: IntFilter<"ViewerSession"> | number
    createdAt?: DateTimeFilter<"ViewerSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"ViewerSession"> | Date | string | null
    live?: XOR<LiveScalarRelationFilter, LiveWhereInput>
  }, "id" | "sessionId">

  export type ViewerSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userName?: SortOrderInput | SortOrder
    userImage?: SortOrderInput | SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    _count?: ViewerSessionCountOrderByAggregateInput
    _avg?: ViewerSessionAvgOrderByAggregateInput
    _max?: ViewerSessionMaxOrderByAggregateInput
    _min?: ViewerSessionMinOrderByAggregateInput
    _sum?: ViewerSessionSumOrderByAggregateInput
  }

  export type ViewerSessionScalarWhereWithAggregatesInput = {
    AND?: ViewerSessionScalarWhereWithAggregatesInput | ViewerSessionScalarWhereWithAggregatesInput[]
    OR?: ViewerSessionScalarWhereWithAggregatesInput[]
    NOT?: ViewerSessionScalarWhereWithAggregatesInput | ViewerSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ViewerSession"> | number
    sessionId?: StringWithAggregatesFilter<"ViewerSession"> | string
    userName?: StringNullableWithAggregatesFilter<"ViewerSession"> | string | null
    userImage?: StringNullableWithAggregatesFilter<"ViewerSession"> | string | null
    liveId?: IntWithAggregatesFilter<"ViewerSession"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ViewerSession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"ViewerSession"> | Date | string | null
  }

  export type CargoWhereInput = {
    AND?: CargoWhereInput | CargoWhereInput[]
    OR?: CargoWhereInput[]
    NOT?: CargoWhereInput | CargoWhereInput[]
    id?: IntFilter<"Cargo"> | number
    nome?: StringFilter<"Cargo"> | string
    users?: UserListRelationFilter
  }

  export type CargoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type CargoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: CargoWhereInput | CargoWhereInput[]
    OR?: CargoWhereInput[]
    NOT?: CargoWhereInput | CargoWhereInput[]
    users?: UserListRelationFilter
  }, "id" | "nome">

  export type CargoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: CargoCountOrderByAggregateInput
    _avg?: CargoAvgOrderByAggregateInput
    _max?: CargoMaxOrderByAggregateInput
    _min?: CargoMinOrderByAggregateInput
    _sum?: CargoSumOrderByAggregateInput
  }

  export type CargoScalarWhereWithAggregatesInput = {
    AND?: CargoScalarWhereWithAggregatesInput | CargoScalarWhereWithAggregatesInput[]
    OR?: CargoScalarWhereWithAggregatesInput[]
    NOT?: CargoScalarWhereWithAggregatesInput | CargoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cargo"> | number
    nome?: StringWithAggregatesFilter<"Cargo"> | string
  }

  export type LocalWhereInput = {
    AND?: LocalWhereInput | LocalWhereInput[]
    OR?: LocalWhereInput[]
    NOT?: LocalWhereInput | LocalWhereInput[]
    id?: IntFilter<"Local"> | number
    nome?: StringFilter<"Local"> | string
    latitude?: FloatFilter<"Local"> | number
    longitude?: FloatFilter<"Local"> | number
    cultos?: CultoListRelationFilter
    reunioes?: ReuniaoListRelationFilter
    ensaios?: EnsaioListRelationFilter
    eventos?: EventoListRelationFilter
  }

  export type LocalOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    cultos?: CultoOrderByRelationAggregateInput
    reunioes?: ReuniaoOrderByRelationAggregateInput
    ensaios?: EnsaioOrderByRelationAggregateInput
    eventos?: EventoOrderByRelationAggregateInput
  }

  export type LocalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocalWhereInput | LocalWhereInput[]
    OR?: LocalWhereInput[]
    NOT?: LocalWhereInput | LocalWhereInput[]
    nome?: StringFilter<"Local"> | string
    latitude?: FloatFilter<"Local"> | number
    longitude?: FloatFilter<"Local"> | number
    cultos?: CultoListRelationFilter
    reunioes?: ReuniaoListRelationFilter
    ensaios?: EnsaioListRelationFilter
    eventos?: EventoListRelationFilter
  }, "id">

  export type LocalOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    _count?: LocalCountOrderByAggregateInput
    _avg?: LocalAvgOrderByAggregateInput
    _max?: LocalMaxOrderByAggregateInput
    _min?: LocalMinOrderByAggregateInput
    _sum?: LocalSumOrderByAggregateInput
  }

  export type LocalScalarWhereWithAggregatesInput = {
    AND?: LocalScalarWhereWithAggregatesInput | LocalScalarWhereWithAggregatesInput[]
    OR?: LocalScalarWhereWithAggregatesInput[]
    NOT?: LocalScalarWhereWithAggregatesInput | LocalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Local"> | number
    nome?: StringWithAggregatesFilter<"Local"> | string
    latitude?: FloatWithAggregatesFilter<"Local"> | number
    longitude?: FloatWithAggregatesFilter<"Local"> | number
  }

  export type CultoWhereInput = {
    AND?: CultoWhereInput | CultoWhereInput[]
    OR?: CultoWhereInput[]
    NOT?: CultoWhereInput | CultoWhereInput[]
    id?: IntFilter<"Culto"> | number
    titulo?: StringFilter<"Culto"> | string
    dataInicio?: DateTimeFilter<"Culto"> | Date | string
    dataTermino?: DateTimeFilter<"Culto"> | Date | string
    localId?: IntFilter<"Culto"> | number
    status?: StringFilter<"Culto"> | string
    pastorId?: IntFilter<"Culto"> | number
    obreiroId?: IntFilter<"Culto"> | number
    liderCanticoId?: IntFilter<"Culto"> | number
    videoUrl?: StringNullableFilter<"Culto"> | string | null
    createdAt?: DateTimeFilter<"Culto"> | Date | string
    updatedAt?: DateTimeFilter<"Culto"> | Date | string
    local?: XOR<LocalScalarRelationFilter, LocalWhereInput>
    pastor?: XOR<UserScalarRelationFilter, UserWhereInput>
    obreiro?: XOR<UserScalarRelationFilter, UserWhereInput>
    auxiliares?: UserListRelationFilter
    liderCantico?: XOR<UserScalarRelationFilter, UserWhereInput>
    vocal?: UserListRelationFilter
    hinos?: HinoListRelationFilter
    mensagens?: MensagemListRelationFilter
    leituras?: LeituraBiblicaListRelationFilter
  }

  export type CultoOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataInicio?: SortOrder
    dataTermino?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    pastorId?: SortOrder
    obreiroId?: SortOrder
    liderCanticoId?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    local?: LocalOrderByWithRelationInput
    pastor?: UserOrderByWithRelationInput
    obreiro?: UserOrderByWithRelationInput
    auxiliares?: UserOrderByRelationAggregateInput
    liderCantico?: UserOrderByWithRelationInput
    vocal?: UserOrderByRelationAggregateInput
    hinos?: HinoOrderByRelationAggregateInput
    mensagens?: MensagemOrderByRelationAggregateInput
    leituras?: LeituraBiblicaOrderByRelationAggregateInput
  }

  export type CultoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CultoWhereInput | CultoWhereInput[]
    OR?: CultoWhereInput[]
    NOT?: CultoWhereInput | CultoWhereInput[]
    titulo?: StringFilter<"Culto"> | string
    dataInicio?: DateTimeFilter<"Culto"> | Date | string
    dataTermino?: DateTimeFilter<"Culto"> | Date | string
    localId?: IntFilter<"Culto"> | number
    status?: StringFilter<"Culto"> | string
    pastorId?: IntFilter<"Culto"> | number
    obreiroId?: IntFilter<"Culto"> | number
    liderCanticoId?: IntFilter<"Culto"> | number
    videoUrl?: StringNullableFilter<"Culto"> | string | null
    createdAt?: DateTimeFilter<"Culto"> | Date | string
    updatedAt?: DateTimeFilter<"Culto"> | Date | string
    local?: XOR<LocalScalarRelationFilter, LocalWhereInput>
    pastor?: XOR<UserScalarRelationFilter, UserWhereInput>
    obreiro?: XOR<UserScalarRelationFilter, UserWhereInput>
    auxiliares?: UserListRelationFilter
    liderCantico?: XOR<UserScalarRelationFilter, UserWhereInput>
    vocal?: UserListRelationFilter
    hinos?: HinoListRelationFilter
    mensagens?: MensagemListRelationFilter
    leituras?: LeituraBiblicaListRelationFilter
  }, "id">

  export type CultoOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataInicio?: SortOrder
    dataTermino?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    pastorId?: SortOrder
    obreiroId?: SortOrder
    liderCanticoId?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CultoCountOrderByAggregateInput
    _avg?: CultoAvgOrderByAggregateInput
    _max?: CultoMaxOrderByAggregateInput
    _min?: CultoMinOrderByAggregateInput
    _sum?: CultoSumOrderByAggregateInput
  }

  export type CultoScalarWhereWithAggregatesInput = {
    AND?: CultoScalarWhereWithAggregatesInput | CultoScalarWhereWithAggregatesInput[]
    OR?: CultoScalarWhereWithAggregatesInput[]
    NOT?: CultoScalarWhereWithAggregatesInput | CultoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Culto"> | number
    titulo?: StringWithAggregatesFilter<"Culto"> | string
    dataInicio?: DateTimeWithAggregatesFilter<"Culto"> | Date | string
    dataTermino?: DateTimeWithAggregatesFilter<"Culto"> | Date | string
    localId?: IntWithAggregatesFilter<"Culto"> | number
    status?: StringWithAggregatesFilter<"Culto"> | string
    pastorId?: IntWithAggregatesFilter<"Culto"> | number
    obreiroId?: IntWithAggregatesFilter<"Culto"> | number
    liderCanticoId?: IntWithAggregatesFilter<"Culto"> | number
    videoUrl?: StringNullableWithAggregatesFilter<"Culto"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Culto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Culto"> | Date | string
  }

  export type ReuniaoWhereInput = {
    AND?: ReuniaoWhereInput | ReuniaoWhereInput[]
    OR?: ReuniaoWhereInput[]
    NOT?: ReuniaoWhereInput | ReuniaoWhereInput[]
    id?: IntFilter<"Reuniao"> | number
    titulo?: StringFilter<"Reuniao"> | string
    dataHora?: DateTimeFilter<"Reuniao"> | Date | string
    localId?: IntFilter<"Reuniao"> | number
    status?: StringFilter<"Reuniao"> | string
    responsavelId?: IntFilter<"Reuniao"> | number
    materiais?: StringFilter<"Reuniao"> | string
    cronograma?: StringFilter<"Reuniao"> | string
    informacoes?: StringNullableFilter<"Reuniao"> | string | null
    createdAt?: DateTimeFilter<"Reuniao"> | Date | string
    updatedAt?: DateTimeFilter<"Reuniao"> | Date | string
    local?: XOR<LocalScalarRelationFilter, LocalWhereInput>
    responsavel?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReuniaoOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    responsavelId?: SortOrder
    materiais?: SortOrder
    cronograma?: SortOrder
    informacoes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    local?: LocalOrderByWithRelationInput
    responsavel?: UserOrderByWithRelationInput
  }

  export type ReuniaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReuniaoWhereInput | ReuniaoWhereInput[]
    OR?: ReuniaoWhereInput[]
    NOT?: ReuniaoWhereInput | ReuniaoWhereInput[]
    titulo?: StringFilter<"Reuniao"> | string
    dataHora?: DateTimeFilter<"Reuniao"> | Date | string
    localId?: IntFilter<"Reuniao"> | number
    status?: StringFilter<"Reuniao"> | string
    responsavelId?: IntFilter<"Reuniao"> | number
    materiais?: StringFilter<"Reuniao"> | string
    cronograma?: StringFilter<"Reuniao"> | string
    informacoes?: StringNullableFilter<"Reuniao"> | string | null
    createdAt?: DateTimeFilter<"Reuniao"> | Date | string
    updatedAt?: DateTimeFilter<"Reuniao"> | Date | string
    local?: XOR<LocalScalarRelationFilter, LocalWhereInput>
    responsavel?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReuniaoOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    responsavelId?: SortOrder
    materiais?: SortOrder
    cronograma?: SortOrder
    informacoes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReuniaoCountOrderByAggregateInput
    _avg?: ReuniaoAvgOrderByAggregateInput
    _max?: ReuniaoMaxOrderByAggregateInput
    _min?: ReuniaoMinOrderByAggregateInput
    _sum?: ReuniaoSumOrderByAggregateInput
  }

  export type ReuniaoScalarWhereWithAggregatesInput = {
    AND?: ReuniaoScalarWhereWithAggregatesInput | ReuniaoScalarWhereWithAggregatesInput[]
    OR?: ReuniaoScalarWhereWithAggregatesInput[]
    NOT?: ReuniaoScalarWhereWithAggregatesInput | ReuniaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reuniao"> | number
    titulo?: StringWithAggregatesFilter<"Reuniao"> | string
    dataHora?: DateTimeWithAggregatesFilter<"Reuniao"> | Date | string
    localId?: IntWithAggregatesFilter<"Reuniao"> | number
    status?: StringWithAggregatesFilter<"Reuniao"> | string
    responsavelId?: IntWithAggregatesFilter<"Reuniao"> | number
    materiais?: StringWithAggregatesFilter<"Reuniao"> | string
    cronograma?: StringWithAggregatesFilter<"Reuniao"> | string
    informacoes?: StringNullableWithAggregatesFilter<"Reuniao"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reuniao"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reuniao"> | Date | string
  }

  export type EnsaioWhereInput = {
    AND?: EnsaioWhereInput | EnsaioWhereInput[]
    OR?: EnsaioWhereInput[]
    NOT?: EnsaioWhereInput | EnsaioWhereInput[]
    id?: IntFilter<"Ensaio"> | number
    titulo?: StringFilter<"Ensaio"> | string
    dataHora?: DateTimeFilter<"Ensaio"> | Date | string
    localId?: IntFilter<"Ensaio"> | number
    status?: StringFilter<"Ensaio"> | string
    responsavelId?: IntFilter<"Ensaio"> | number
    createdAt?: DateTimeFilter<"Ensaio"> | Date | string
    updatedAt?: DateTimeFilter<"Ensaio"> | Date | string
    local?: XOR<LocalScalarRelationFilter, LocalWhereInput>
    responsavel?: XOR<UserScalarRelationFilter, UserWhereInput>
    participantes?: UserListRelationFilter
    hinos?: HinoListRelationFilter
  }

  export type EnsaioOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    responsavelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    local?: LocalOrderByWithRelationInput
    responsavel?: UserOrderByWithRelationInput
    participantes?: UserOrderByRelationAggregateInput
    hinos?: HinoOrderByRelationAggregateInput
  }

  export type EnsaioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EnsaioWhereInput | EnsaioWhereInput[]
    OR?: EnsaioWhereInput[]
    NOT?: EnsaioWhereInput | EnsaioWhereInput[]
    titulo?: StringFilter<"Ensaio"> | string
    dataHora?: DateTimeFilter<"Ensaio"> | Date | string
    localId?: IntFilter<"Ensaio"> | number
    status?: StringFilter<"Ensaio"> | string
    responsavelId?: IntFilter<"Ensaio"> | number
    createdAt?: DateTimeFilter<"Ensaio"> | Date | string
    updatedAt?: DateTimeFilter<"Ensaio"> | Date | string
    local?: XOR<LocalScalarRelationFilter, LocalWhereInput>
    responsavel?: XOR<UserScalarRelationFilter, UserWhereInput>
    participantes?: UserListRelationFilter
    hinos?: HinoListRelationFilter
  }, "id">

  export type EnsaioOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    responsavelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EnsaioCountOrderByAggregateInput
    _avg?: EnsaioAvgOrderByAggregateInput
    _max?: EnsaioMaxOrderByAggregateInput
    _min?: EnsaioMinOrderByAggregateInput
    _sum?: EnsaioSumOrderByAggregateInput
  }

  export type EnsaioScalarWhereWithAggregatesInput = {
    AND?: EnsaioScalarWhereWithAggregatesInput | EnsaioScalarWhereWithAggregatesInput[]
    OR?: EnsaioScalarWhereWithAggregatesInput[]
    NOT?: EnsaioScalarWhereWithAggregatesInput | EnsaioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ensaio"> | number
    titulo?: StringWithAggregatesFilter<"Ensaio"> | string
    dataHora?: DateTimeWithAggregatesFilter<"Ensaio"> | Date | string
    localId?: IntWithAggregatesFilter<"Ensaio"> | number
    status?: StringWithAggregatesFilter<"Ensaio"> | string
    responsavelId?: IntWithAggregatesFilter<"Ensaio"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Ensaio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ensaio"> | Date | string
  }

  export type EventoWhereInput = {
    AND?: EventoWhereInput | EventoWhereInput[]
    OR?: EventoWhereInput[]
    NOT?: EventoWhereInput | EventoWhereInput[]
    id?: IntFilter<"Evento"> | number
    titulo?: StringFilter<"Evento"> | string
    dataHora?: DateTimeFilter<"Evento"> | Date | string
    localId?: IntFilter<"Evento"> | number
    status?: StringFilter<"Evento"> | string
    cronograma?: StringFilter<"Evento"> | string
    createdAt?: DateTimeFilter<"Evento"> | Date | string
    updatedAt?: DateTimeFilter<"Evento"> | Date | string
    local?: XOR<LocalScalarRelationFilter, LocalWhereInput>
  }

  export type EventoOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    cronograma?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    local?: LocalOrderByWithRelationInput
  }

  export type EventoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EventoWhereInput | EventoWhereInput[]
    OR?: EventoWhereInput[]
    NOT?: EventoWhereInput | EventoWhereInput[]
    titulo?: StringFilter<"Evento"> | string
    dataHora?: DateTimeFilter<"Evento"> | Date | string
    localId?: IntFilter<"Evento"> | number
    status?: StringFilter<"Evento"> | string
    cronograma?: StringFilter<"Evento"> | string
    createdAt?: DateTimeFilter<"Evento"> | Date | string
    updatedAt?: DateTimeFilter<"Evento"> | Date | string
    local?: XOR<LocalScalarRelationFilter, LocalWhereInput>
  }, "id">

  export type EventoOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    cronograma?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventoCountOrderByAggregateInput
    _avg?: EventoAvgOrderByAggregateInput
    _max?: EventoMaxOrderByAggregateInput
    _min?: EventoMinOrderByAggregateInput
    _sum?: EventoSumOrderByAggregateInput
  }

  export type EventoScalarWhereWithAggregatesInput = {
    AND?: EventoScalarWhereWithAggregatesInput | EventoScalarWhereWithAggregatesInput[]
    OR?: EventoScalarWhereWithAggregatesInput[]
    NOT?: EventoScalarWhereWithAggregatesInput | EventoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Evento"> | number
    titulo?: StringWithAggregatesFilter<"Evento"> | string
    dataHora?: DateTimeWithAggregatesFilter<"Evento"> | Date | string
    localId?: IntWithAggregatesFilter<"Evento"> | number
    status?: StringWithAggregatesFilter<"Evento"> | string
    cronograma?: StringWithAggregatesFilter<"Evento"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Evento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evento"> | Date | string
  }

  export type MensagemWhereInput = {
    AND?: MensagemWhereInput | MensagemWhereInput[]
    OR?: MensagemWhereInput[]
    NOT?: MensagemWhereInput | MensagemWhereInput[]
    id?: IntFilter<"Mensagem"> | number
    titulo?: StringFilter<"Mensagem"> | string
    data?: DateTimeFilter<"Mensagem"> | Date | string
    cidade?: StringFilter<"Mensagem"> | string
    estado?: StringFilter<"Mensagem"> | string
    pais?: StringFilter<"Mensagem"> | string
    traduzidoPor?: StringNullableFilter<"Mensagem"> | string | null
    conteudo?: StringFilter<"Mensagem"> | string
    pdfUrl?: StringNullableFilter<"Mensagem"> | string | null
    createdAt?: DateTimeFilter<"Mensagem"> | Date | string
    updatedAt?: DateTimeFilter<"Mensagem"> | Date | string
    cultos?: CultoListRelationFilter
  }

  export type MensagemOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    data?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    pais?: SortOrder
    traduzidoPor?: SortOrderInput | SortOrder
    conteudo?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cultos?: CultoOrderByRelationAggregateInput
  }

  export type MensagemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MensagemWhereInput | MensagemWhereInput[]
    OR?: MensagemWhereInput[]
    NOT?: MensagemWhereInput | MensagemWhereInput[]
    titulo?: StringFilter<"Mensagem"> | string
    data?: DateTimeFilter<"Mensagem"> | Date | string
    cidade?: StringFilter<"Mensagem"> | string
    estado?: StringFilter<"Mensagem"> | string
    pais?: StringFilter<"Mensagem"> | string
    traduzidoPor?: StringNullableFilter<"Mensagem"> | string | null
    conteudo?: StringFilter<"Mensagem"> | string
    pdfUrl?: StringNullableFilter<"Mensagem"> | string | null
    createdAt?: DateTimeFilter<"Mensagem"> | Date | string
    updatedAt?: DateTimeFilter<"Mensagem"> | Date | string
    cultos?: CultoListRelationFilter
  }, "id">

  export type MensagemOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    data?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    pais?: SortOrder
    traduzidoPor?: SortOrderInput | SortOrder
    conteudo?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MensagemCountOrderByAggregateInput
    _avg?: MensagemAvgOrderByAggregateInput
    _max?: MensagemMaxOrderByAggregateInput
    _min?: MensagemMinOrderByAggregateInput
    _sum?: MensagemSumOrderByAggregateInput
  }

  export type MensagemScalarWhereWithAggregatesInput = {
    AND?: MensagemScalarWhereWithAggregatesInput | MensagemScalarWhereWithAggregatesInput[]
    OR?: MensagemScalarWhereWithAggregatesInput[]
    NOT?: MensagemScalarWhereWithAggregatesInput | MensagemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mensagem"> | number
    titulo?: StringWithAggregatesFilter<"Mensagem"> | string
    data?: DateTimeWithAggregatesFilter<"Mensagem"> | Date | string
    cidade?: StringWithAggregatesFilter<"Mensagem"> | string
    estado?: StringWithAggregatesFilter<"Mensagem"> | string
    pais?: StringWithAggregatesFilter<"Mensagem"> | string
    traduzidoPor?: StringNullableWithAggregatesFilter<"Mensagem"> | string | null
    conteudo?: StringWithAggregatesFilter<"Mensagem"> | string
    pdfUrl?: StringNullableWithAggregatesFilter<"Mensagem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Mensagem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mensagem"> | Date | string
  }

  export type HinoWhereInput = {
    AND?: HinoWhereInput | HinoWhereInput[]
    OR?: HinoWhereInput[]
    NOT?: HinoWhereInput | HinoWhereInput[]
    id?: IntFilter<"Hino"> | number
    titulo?: StringFilter<"Hino"> | string
    autor?: StringFilter<"Hino"> | string
    letra?: StringFilter<"Hino"> | string
    createdAt?: DateTimeFilter<"Hino"> | Date | string
    updatedAt?: DateTimeFilter<"Hino"> | Date | string
    cultos?: CultoListRelationFilter
    ensaios?: EnsaioListRelationFilter
  }

  export type HinoOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    autor?: SortOrder
    letra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cultos?: CultoOrderByRelationAggregateInput
    ensaios?: EnsaioOrderByRelationAggregateInput
  }

  export type HinoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HinoWhereInput | HinoWhereInput[]
    OR?: HinoWhereInput[]
    NOT?: HinoWhereInput | HinoWhereInput[]
    titulo?: StringFilter<"Hino"> | string
    autor?: StringFilter<"Hino"> | string
    letra?: StringFilter<"Hino"> | string
    createdAt?: DateTimeFilter<"Hino"> | Date | string
    updatedAt?: DateTimeFilter<"Hino"> | Date | string
    cultos?: CultoListRelationFilter
    ensaios?: EnsaioListRelationFilter
  }, "id">

  export type HinoOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    autor?: SortOrder
    letra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HinoCountOrderByAggregateInput
    _avg?: HinoAvgOrderByAggregateInput
    _max?: HinoMaxOrderByAggregateInput
    _min?: HinoMinOrderByAggregateInput
    _sum?: HinoSumOrderByAggregateInput
  }

  export type HinoScalarWhereWithAggregatesInput = {
    AND?: HinoScalarWhereWithAggregatesInput | HinoScalarWhereWithAggregatesInput[]
    OR?: HinoScalarWhereWithAggregatesInput[]
    NOT?: HinoScalarWhereWithAggregatesInput | HinoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hino"> | number
    titulo?: StringWithAggregatesFilter<"Hino"> | string
    autor?: StringWithAggregatesFilter<"Hino"> | string
    letra?: StringWithAggregatesFilter<"Hino"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Hino"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hino"> | Date | string
  }

  export type LeituraBiblicaWhereInput = {
    AND?: LeituraBiblicaWhereInput | LeituraBiblicaWhereInput[]
    OR?: LeituraBiblicaWhereInput[]
    NOT?: LeituraBiblicaWhereInput | LeituraBiblicaWhereInput[]
    id?: IntFilter<"LeituraBiblica"> | number
    livro?: StringFilter<"LeituraBiblica"> | string
    capitulo?: IntFilter<"LeituraBiblica"> | number
    versiculos?: StringFilter<"LeituraBiblica"> | string
    createdAt?: DateTimeFilter<"LeituraBiblica"> | Date | string
    updatedAt?: DateTimeFilter<"LeituraBiblica"> | Date | string
    cultos?: CultoListRelationFilter
  }

  export type LeituraBiblicaOrderByWithRelationInput = {
    id?: SortOrder
    livro?: SortOrder
    capitulo?: SortOrder
    versiculos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cultos?: CultoOrderByRelationAggregateInput
  }

  export type LeituraBiblicaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeituraBiblicaWhereInput | LeituraBiblicaWhereInput[]
    OR?: LeituraBiblicaWhereInput[]
    NOT?: LeituraBiblicaWhereInput | LeituraBiblicaWhereInput[]
    livro?: StringFilter<"LeituraBiblica"> | string
    capitulo?: IntFilter<"LeituraBiblica"> | number
    versiculos?: StringFilter<"LeituraBiblica"> | string
    createdAt?: DateTimeFilter<"LeituraBiblica"> | Date | string
    updatedAt?: DateTimeFilter<"LeituraBiblica"> | Date | string
    cultos?: CultoListRelationFilter
  }, "id">

  export type LeituraBiblicaOrderByWithAggregationInput = {
    id?: SortOrder
    livro?: SortOrder
    capitulo?: SortOrder
    versiculos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeituraBiblicaCountOrderByAggregateInput
    _avg?: LeituraBiblicaAvgOrderByAggregateInput
    _max?: LeituraBiblicaMaxOrderByAggregateInput
    _min?: LeituraBiblicaMinOrderByAggregateInput
    _sum?: LeituraBiblicaSumOrderByAggregateInput
  }

  export type LeituraBiblicaScalarWhereWithAggregatesInput = {
    AND?: LeituraBiblicaScalarWhereWithAggregatesInput | LeituraBiblicaScalarWhereWithAggregatesInput[]
    OR?: LeituraBiblicaScalarWhereWithAggregatesInput[]
    NOT?: LeituraBiblicaScalarWhereWithAggregatesInput | LeituraBiblicaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeituraBiblica"> | number
    livro?: StringWithAggregatesFilter<"LeituraBiblica"> | string
    capitulo?: IntWithAggregatesFilter<"LeituraBiblica"> | number
    versiculos?: StringWithAggregatesFilter<"LeituraBiblica"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeituraBiblica"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeituraBiblica"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cargo?: CargoCreateNestedOneWithoutUsersInput
    cultosComoPastor?: CultoCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioCreateNestedManyWithoutParticipantesInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    cargoId?: number | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoPastor?: CultoUncheckedCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoUncheckedCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoUncheckedCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoUncheckedCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoUncheckedCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoUncheckedCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioUncheckedCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioUncheckedCreateNestedManyWithoutParticipantesInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cargo?: CargoUpdateOneWithoutUsersNestedInput
    cultosComoPastor?: CultoUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoPastor?: CultoUncheckedUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUncheckedUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUncheckedUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUncheckedUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUncheckedUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUncheckedUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUncheckedUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUncheckedUpdateManyWithoutParticipantesNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    cargoId?: number | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveCreateInput = {
    youtubeId: string
    title: string
    viewers?: number
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leituras?: LeituraCreateNestedManyWithoutLiveInput
    pedidosOracao?: PedidoOracaoCreateNestedManyWithoutLiveInput
    viewerSessions?: ViewerSessionCreateNestedManyWithoutLiveInput
  }

  export type LiveUncheckedCreateInput = {
    id?: number
    youtubeId: string
    title: string
    viewers?: number
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leituras?: LeituraUncheckedCreateNestedManyWithoutLiveInput
    pedidosOracao?: PedidoOracaoUncheckedCreateNestedManyWithoutLiveInput
    viewerSessions?: ViewerSessionUncheckedCreateNestedManyWithoutLiveInput
  }

  export type LiveUpdateInput = {
    youtubeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    viewers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ofertaAtiva?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leituras?: LeituraUpdateManyWithoutLiveNestedInput
    pedidosOracao?: PedidoOracaoUpdateManyWithoutLiveNestedInput
    viewerSessions?: ViewerSessionUpdateManyWithoutLiveNestedInput
  }

  export type LiveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    youtubeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    viewers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ofertaAtiva?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leituras?: LeituraUncheckedUpdateManyWithoutLiveNestedInput
    pedidosOracao?: PedidoOracaoUncheckedUpdateManyWithoutLiveNestedInput
    viewerSessions?: ViewerSessionUncheckedUpdateManyWithoutLiveNestedInput
  }

  export type LiveCreateManyInput = {
    id?: number
    youtubeId: string
    title: string
    viewers?: number
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiveUpdateManyMutationInput = {
    youtubeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    viewers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ofertaAtiva?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    youtubeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    viewers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ofertaAtiva?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraCreateInput = {
    texto: string
    minuto: string
    createdAt?: Date | string
    live: LiveCreateNestedOneWithoutLeiturasInput
  }

  export type LeituraUncheckedCreateInput = {
    id?: number
    texto: string
    minuto: string
    liveId: number
    createdAt?: Date | string
  }

  export type LeituraUpdateInput = {
    texto?: StringFieldUpdateOperationsInput | string
    minuto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    live?: LiveUpdateOneRequiredWithoutLeiturasNestedInput
  }

  export type LeituraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    texto?: StringFieldUpdateOperationsInput | string
    minuto?: StringFieldUpdateOperationsInput | string
    liveId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraCreateManyInput = {
    id?: number
    texto: string
    minuto: string
    liveId: number
    createdAt?: Date | string
  }

  export type LeituraUpdateManyMutationInput = {
    texto?: StringFieldUpdateOperationsInput | string
    minuto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    texto?: StringFieldUpdateOperationsInput | string
    minuto?: StringFieldUpdateOperationsInput | string
    liveId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoOracaoCreateInput = {
    para: string
    motivo: string
    createdAt?: Date | string
    live: LiveCreateNestedOneWithoutPedidosOracaoInput
  }

  export type PedidoOracaoUncheckedCreateInput = {
    id?: number
    para: string
    motivo: string
    liveId: number
    createdAt?: Date | string
  }

  export type PedidoOracaoUpdateInput = {
    para?: StringFieldUpdateOperationsInput | string
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    live?: LiveUpdateOneRequiredWithoutPedidosOracaoNestedInput
  }

  export type PedidoOracaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    para?: StringFieldUpdateOperationsInput | string
    motivo?: StringFieldUpdateOperationsInput | string
    liveId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoOracaoCreateManyInput = {
    id?: number
    para: string
    motivo: string
    liveId: number
    createdAt?: Date | string
  }

  export type PedidoOracaoUpdateManyMutationInput = {
    para?: StringFieldUpdateOperationsInput | string
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoOracaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    para?: StringFieldUpdateOperationsInput | string
    motivo?: StringFieldUpdateOperationsInput | string
    liveId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewerSessionCreateInput = {
    sessionId: string
    userName?: string | null
    userImage?: string | null
    createdAt?: Date | string
    endedAt?: Date | string | null
    live: LiveCreateNestedOneWithoutViewerSessionsInput
  }

  export type ViewerSessionUncheckedCreateInput = {
    id?: number
    sessionId: string
    userName?: string | null
    userImage?: string | null
    liveId: number
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type ViewerSessionUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    live?: LiveUpdateOneRequiredWithoutViewerSessionsNestedInput
  }

  export type ViewerSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    liveId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ViewerSessionCreateManyInput = {
    id?: number
    sessionId: string
    userName?: string | null
    userImage?: string | null
    liveId: number
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type ViewerSessionUpdateManyMutationInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ViewerSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    liveId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CargoCreateInput = {
    nome: string
    users?: UserCreateNestedManyWithoutCargoInput
  }

  export type CargoUncheckedCreateInput = {
    id?: number
    nome: string
    users?: UserUncheckedCreateNestedManyWithoutCargoInput
  }

  export type CargoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutCargoNestedInput
  }

  export type CargoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutCargoNestedInput
  }

  export type CargoCreateManyInput = {
    id?: number
    nome: string
  }

  export type CargoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type CargoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type LocalCreateInput = {
    nome: string
    latitude: number
    longitude: number
    cultos?: CultoCreateNestedManyWithoutLocalInput
    reunioes?: ReuniaoCreateNestedManyWithoutLocalInput
    ensaios?: EnsaioCreateNestedManyWithoutLocalInput
    eventos?: EventoCreateNestedManyWithoutLocalInput
  }

  export type LocalUncheckedCreateInput = {
    id?: number
    nome: string
    latitude: number
    longitude: number
    cultos?: CultoUncheckedCreateNestedManyWithoutLocalInput
    reunioes?: ReuniaoUncheckedCreateNestedManyWithoutLocalInput
    ensaios?: EnsaioUncheckedCreateNestedManyWithoutLocalInput
    eventos?: EventoUncheckedCreateNestedManyWithoutLocalInput
  }

  export type LocalUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    cultos?: CultoUpdateManyWithoutLocalNestedInput
    reunioes?: ReuniaoUpdateManyWithoutLocalNestedInput
    ensaios?: EnsaioUpdateManyWithoutLocalNestedInput
    eventos?: EventoUpdateManyWithoutLocalNestedInput
  }

  export type LocalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    cultos?: CultoUncheckedUpdateManyWithoutLocalNestedInput
    reunioes?: ReuniaoUncheckedUpdateManyWithoutLocalNestedInput
    ensaios?: EnsaioUncheckedUpdateManyWithoutLocalNestedInput
    eventos?: EventoUncheckedUpdateManyWithoutLocalNestedInput
  }

  export type LocalCreateManyInput = {
    id?: number
    nome: string
    latitude: number
    longitude: number
  }

  export type LocalUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type LocalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type CultoCreateInput = {
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutCultosInput
    pastor: UserCreateNestedOneWithoutCultosComoPastorInput
    obreiro: UserCreateNestedOneWithoutCultosComoObreiroInput
    auxiliares?: UserCreateNestedManyWithoutCultosComoAuxiliarInput
    liderCantico: UserCreateNestedOneWithoutCultosComoLiderCanticoInput
    vocal?: UserCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoCreateNestedManyWithoutCultosInput
    mensagens?: MensagemCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaCreateNestedManyWithoutCultosInput
  }

  export type CultoUncheckedCreateInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auxiliares?: UserUncheckedCreateNestedManyWithoutCultosComoAuxiliarInput
    vocal?: UserUncheckedCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoUncheckedCreateNestedManyWithoutCultosInput
    mensagens?: MensagemUncheckedCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaUncheckedCreateNestedManyWithoutCultosInput
  }

  export type CultoUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutCultosNestedInput
    pastor?: UserUpdateOneRequiredWithoutCultosComoPastorNestedInput
    obreiro?: UserUpdateOneRequiredWithoutCultosComoObreiroNestedInput
    auxiliares?: UserUpdateManyWithoutCultosComoAuxiliarNestedInput
    liderCantico?: UserUpdateOneRequiredWithoutCultosComoLiderCanticoNestedInput
    vocal?: UserUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auxiliares?: UserUncheckedUpdateManyWithoutCultosComoAuxiliarNestedInput
    vocal?: UserUncheckedUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUncheckedUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUncheckedUpdateManyWithoutCultosNestedInput
  }

  export type CultoCreateManyInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CultoUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReuniaoCreateInput = {
    titulo: string
    dataHora: Date | string
    status: string
    materiais: string
    cronograma: string
    informacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutReunioesInput
    responsavel: UserCreateNestedOneWithoutReunioesResponsavelInput
  }

  export type ReuniaoUncheckedCreateInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    responsavelId: number
    materiais: string
    cronograma: string
    informacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReuniaoUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    materiais?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    informacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutReunioesNestedInput
    responsavel?: UserUpdateOneRequiredWithoutReunioesResponsavelNestedInput
  }

  export type ReuniaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    materiais?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    informacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReuniaoCreateManyInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    responsavelId: number
    materiais: string
    cronograma: string
    informacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReuniaoUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    materiais?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    informacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReuniaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    materiais?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    informacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnsaioCreateInput = {
    titulo: string
    dataHora: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutEnsaiosInput
    responsavel: UserCreateNestedOneWithoutEnsaiosResponsavelInput
    participantes?: UserCreateNestedManyWithoutParticipaEnsaiosInput
    hinos?: HinoCreateNestedManyWithoutEnsaiosInput
  }

  export type EnsaioUncheckedCreateInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    participantes?: UserUncheckedCreateNestedManyWithoutParticipaEnsaiosInput
    hinos?: HinoUncheckedCreateNestedManyWithoutEnsaiosInput
  }

  export type EnsaioUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutEnsaiosNestedInput
    responsavel?: UserUpdateOneRequiredWithoutEnsaiosResponsavelNestedInput
    participantes?: UserUpdateManyWithoutParticipaEnsaiosNestedInput
    hinos?: HinoUpdateManyWithoutEnsaiosNestedInput
  }

  export type EnsaioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantes?: UserUncheckedUpdateManyWithoutParticipaEnsaiosNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutEnsaiosNestedInput
  }

  export type EnsaioCreateManyInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnsaioUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnsaioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoCreateInput = {
    titulo: string
    dataHora: Date | string
    status: string
    cronograma: string
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutEventosInput
  }

  export type EventoUncheckedCreateInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    cronograma: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutEventosNestedInput
  }

  export type EventoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoCreateManyInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    cronograma: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensagemCreateInput = {
    titulo: string
    data: Date | string
    cidade: string
    estado: string
    pais: string
    traduzidoPor?: string | null
    conteudo: string
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cultos?: CultoCreateNestedManyWithoutMensagensInput
  }

  export type MensagemUncheckedCreateInput = {
    id?: number
    titulo: string
    data: Date | string
    cidade: string
    estado: string
    pais: string
    traduzidoPor?: string | null
    conteudo: string
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cultos?: CultoUncheckedCreateNestedManyWithoutMensagensInput
  }

  export type MensagemUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    traduzidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultos?: CultoUpdateManyWithoutMensagensNestedInput
  }

  export type MensagemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    traduzidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultos?: CultoUncheckedUpdateManyWithoutMensagensNestedInput
  }

  export type MensagemCreateManyInput = {
    id?: number
    titulo: string
    data: Date | string
    cidade: string
    estado: string
    pais: string
    traduzidoPor?: string | null
    conteudo: string
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MensagemUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    traduzidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensagemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    traduzidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HinoCreateInput = {
    titulo: string
    autor: string
    letra: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cultos?: CultoCreateNestedManyWithoutHinosInput
    ensaios?: EnsaioCreateNestedManyWithoutHinosInput
  }

  export type HinoUncheckedCreateInput = {
    id?: number
    titulo: string
    autor: string
    letra: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cultos?: CultoUncheckedCreateNestedManyWithoutHinosInput
    ensaios?: EnsaioUncheckedCreateNestedManyWithoutHinosInput
  }

  export type HinoUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    autor?: StringFieldUpdateOperationsInput | string
    letra?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultos?: CultoUpdateManyWithoutHinosNestedInput
    ensaios?: EnsaioUpdateManyWithoutHinosNestedInput
  }

  export type HinoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    autor?: StringFieldUpdateOperationsInput | string
    letra?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultos?: CultoUncheckedUpdateManyWithoutHinosNestedInput
    ensaios?: EnsaioUncheckedUpdateManyWithoutHinosNestedInput
  }

  export type HinoCreateManyInput = {
    id?: number
    titulo: string
    autor: string
    letra: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HinoUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    autor?: StringFieldUpdateOperationsInput | string
    letra?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HinoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    autor?: StringFieldUpdateOperationsInput | string
    letra?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraBiblicaCreateInput = {
    livro: string
    capitulo: number
    versiculos: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cultos?: CultoCreateNestedManyWithoutLeiturasInput
  }

  export type LeituraBiblicaUncheckedCreateInput = {
    id?: number
    livro: string
    capitulo: number
    versiculos: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cultos?: CultoUncheckedCreateNestedManyWithoutLeiturasInput
  }

  export type LeituraBiblicaUpdateInput = {
    livro?: StringFieldUpdateOperationsInput | string
    capitulo?: IntFieldUpdateOperationsInput | number
    versiculos?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultos?: CultoUpdateManyWithoutLeiturasNestedInput
  }

  export type LeituraBiblicaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    livro?: StringFieldUpdateOperationsInput | string
    capitulo?: IntFieldUpdateOperationsInput | number
    versiculos?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultos?: CultoUncheckedUpdateManyWithoutLeiturasNestedInput
  }

  export type LeituraBiblicaCreateManyInput = {
    id?: number
    livro: string
    capitulo: number
    versiculos: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeituraBiblicaUpdateManyMutationInput = {
    livro?: StringFieldUpdateOperationsInput | string
    capitulo?: IntFieldUpdateOperationsInput | number
    versiculos?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraBiblicaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    livro?: StringFieldUpdateOperationsInput | string
    capitulo?: IntFieldUpdateOperationsInput | number
    versiculos?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CargoNullableScalarRelationFilter = {
    is?: CargoWhereInput | null
    isNot?: CargoWhereInput | null
  }

  export type CultoListRelationFilter = {
    every?: CultoWhereInput
    some?: CultoWhereInput
    none?: CultoWhereInput
  }

  export type ReuniaoListRelationFilter = {
    every?: ReuniaoWhereInput
    some?: ReuniaoWhereInput
    none?: ReuniaoWhereInput
  }

  export type EnsaioListRelationFilter = {
    every?: EnsaioWhereInput
    some?: EnsaioWhereInput
    none?: EnsaioWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CultoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReuniaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnsaioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cargoId?: SortOrder
    online?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    cargoId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cargoId?: SortOrder
    online?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    cargoId?: SortOrder
    online?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    cargoId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type LeituraListRelationFilter = {
    every?: LeituraWhereInput
    some?: LeituraWhereInput
    none?: LeituraWhereInput
  }

  export type PedidoOracaoListRelationFilter = {
    every?: PedidoOracaoWhereInput
    some?: PedidoOracaoWhereInput
    none?: PedidoOracaoWhereInput
  }

  export type ViewerSessionListRelationFilter = {
    every?: ViewerSessionWhereInput
    some?: ViewerSessionWhereInput
    none?: ViewerSessionWhereInput
  }

  export type LeituraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PedidoOracaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViewerSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiveCountOrderByAggregateInput = {
    id?: SortOrder
    youtubeId?: SortOrder
    title?: SortOrder
    viewers?: SortOrder
    isActive?: SortOrder
    ofertaAtiva?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiveAvgOrderByAggregateInput = {
    id?: SortOrder
    viewers?: SortOrder
  }

  export type LiveMaxOrderByAggregateInput = {
    id?: SortOrder
    youtubeId?: SortOrder
    title?: SortOrder
    viewers?: SortOrder
    isActive?: SortOrder
    ofertaAtiva?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiveMinOrderByAggregateInput = {
    id?: SortOrder
    youtubeId?: SortOrder
    title?: SortOrder
    viewers?: SortOrder
    isActive?: SortOrder
    ofertaAtiva?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LiveSumOrderByAggregateInput = {
    id?: SortOrder
    viewers?: SortOrder
  }

  export type LiveScalarRelationFilter = {
    is?: LiveWhereInput
    isNot?: LiveWhereInput
  }

  export type LeituraCountOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    minuto?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
  }

  export type LeituraAvgOrderByAggregateInput = {
    id?: SortOrder
    liveId?: SortOrder
  }

  export type LeituraMaxOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    minuto?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
  }

  export type LeituraMinOrderByAggregateInput = {
    id?: SortOrder
    texto?: SortOrder
    minuto?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
  }

  export type LeituraSumOrderByAggregateInput = {
    id?: SortOrder
    liveId?: SortOrder
  }

  export type PedidoOracaoCountOrderByAggregateInput = {
    id?: SortOrder
    para?: SortOrder
    motivo?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
  }

  export type PedidoOracaoAvgOrderByAggregateInput = {
    id?: SortOrder
    liveId?: SortOrder
  }

  export type PedidoOracaoMaxOrderByAggregateInput = {
    id?: SortOrder
    para?: SortOrder
    motivo?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
  }

  export type PedidoOracaoMinOrderByAggregateInput = {
    id?: SortOrder
    para?: SortOrder
    motivo?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
  }

  export type PedidoOracaoSumOrderByAggregateInput = {
    id?: SortOrder
    liveId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ViewerSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userName?: SortOrder
    userImage?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type ViewerSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    liveId?: SortOrder
  }

  export type ViewerSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userName?: SortOrder
    userImage?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type ViewerSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userName?: SortOrder
    userImage?: SortOrder
    liveId?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type ViewerSessionSumOrderByAggregateInput = {
    id?: SortOrder
    liveId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CargoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type CargoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CargoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type CargoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type CargoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EventoListRelationFilter = {
    every?: EventoWhereInput
    some?: EventoWhereInput
    none?: EventoWhereInput
  }

  export type EventoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocalCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocalAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocalMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocalMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocalSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LocalScalarRelationFilter = {
    is?: LocalWhereInput
    isNot?: LocalWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type HinoListRelationFilter = {
    every?: HinoWhereInput
    some?: HinoWhereInput
    none?: HinoWhereInput
  }

  export type MensagemListRelationFilter = {
    every?: MensagemWhereInput
    some?: MensagemWhereInput
    none?: MensagemWhereInput
  }

  export type LeituraBiblicaListRelationFilter = {
    every?: LeituraBiblicaWhereInput
    some?: LeituraBiblicaWhereInput
    none?: LeituraBiblicaWhereInput
  }

  export type HinoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MensagemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeituraBiblicaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CultoCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataInicio?: SortOrder
    dataTermino?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    pastorId?: SortOrder
    obreiroId?: SortOrder
    liderCanticoId?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CultoAvgOrderByAggregateInput = {
    id?: SortOrder
    localId?: SortOrder
    pastorId?: SortOrder
    obreiroId?: SortOrder
    liderCanticoId?: SortOrder
  }

  export type CultoMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataInicio?: SortOrder
    dataTermino?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    pastorId?: SortOrder
    obreiroId?: SortOrder
    liderCanticoId?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CultoMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataInicio?: SortOrder
    dataTermino?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    pastorId?: SortOrder
    obreiroId?: SortOrder
    liderCanticoId?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CultoSumOrderByAggregateInput = {
    id?: SortOrder
    localId?: SortOrder
    pastorId?: SortOrder
    obreiroId?: SortOrder
    liderCanticoId?: SortOrder
  }

  export type ReuniaoCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    responsavelId?: SortOrder
    materiais?: SortOrder
    cronograma?: SortOrder
    informacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReuniaoAvgOrderByAggregateInput = {
    id?: SortOrder
    localId?: SortOrder
    responsavelId?: SortOrder
  }

  export type ReuniaoMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    responsavelId?: SortOrder
    materiais?: SortOrder
    cronograma?: SortOrder
    informacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReuniaoMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    responsavelId?: SortOrder
    materiais?: SortOrder
    cronograma?: SortOrder
    informacoes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReuniaoSumOrderByAggregateInput = {
    id?: SortOrder
    localId?: SortOrder
    responsavelId?: SortOrder
  }

  export type EnsaioCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    responsavelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnsaioAvgOrderByAggregateInput = {
    id?: SortOrder
    localId?: SortOrder
    responsavelId?: SortOrder
  }

  export type EnsaioMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    responsavelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnsaioMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    responsavelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnsaioSumOrderByAggregateInput = {
    id?: SortOrder
    localId?: SortOrder
    responsavelId?: SortOrder
  }

  export type EventoCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    cronograma?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventoAvgOrderByAggregateInput = {
    id?: SortOrder
    localId?: SortOrder
  }

  export type EventoMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    cronograma?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventoMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    dataHora?: SortOrder
    localId?: SortOrder
    status?: SortOrder
    cronograma?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventoSumOrderByAggregateInput = {
    id?: SortOrder
    localId?: SortOrder
  }

  export type MensagemCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    data?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    pais?: SortOrder
    traduzidoPor?: SortOrder
    conteudo?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MensagemAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MensagemMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    data?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    pais?: SortOrder
    traduzidoPor?: SortOrder
    conteudo?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MensagemMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    data?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    pais?: SortOrder
    traduzidoPor?: SortOrder
    conteudo?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MensagemSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HinoCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    autor?: SortOrder
    letra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HinoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HinoMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    autor?: SortOrder
    letra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HinoMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    autor?: SortOrder
    letra?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HinoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeituraBiblicaCountOrderByAggregateInput = {
    id?: SortOrder
    livro?: SortOrder
    capitulo?: SortOrder
    versiculos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeituraBiblicaAvgOrderByAggregateInput = {
    id?: SortOrder
    capitulo?: SortOrder
  }

  export type LeituraBiblicaMaxOrderByAggregateInput = {
    id?: SortOrder
    livro?: SortOrder
    capitulo?: SortOrder
    versiculos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeituraBiblicaMinOrderByAggregateInput = {
    id?: SortOrder
    livro?: SortOrder
    capitulo?: SortOrder
    versiculos?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeituraBiblicaSumOrderByAggregateInput = {
    id?: SortOrder
    capitulo?: SortOrder
  }

  export type CargoCreateNestedOneWithoutUsersInput = {
    create?: XOR<CargoCreateWithoutUsersInput, CargoUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CargoCreateOrConnectWithoutUsersInput
    connect?: CargoWhereUniqueInput
  }

  export type CultoCreateNestedManyWithoutPastorInput = {
    create?: XOR<CultoCreateWithoutPastorInput, CultoUncheckedCreateWithoutPastorInput> | CultoCreateWithoutPastorInput[] | CultoUncheckedCreateWithoutPastorInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutPastorInput | CultoCreateOrConnectWithoutPastorInput[]
    createMany?: CultoCreateManyPastorInputEnvelope
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoCreateNestedManyWithoutObreiroInput = {
    create?: XOR<CultoCreateWithoutObreiroInput, CultoUncheckedCreateWithoutObreiroInput> | CultoCreateWithoutObreiroInput[] | CultoUncheckedCreateWithoutObreiroInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutObreiroInput | CultoCreateOrConnectWithoutObreiroInput[]
    createMany?: CultoCreateManyObreiroInputEnvelope
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoCreateNestedManyWithoutAuxiliaresInput = {
    create?: XOR<CultoCreateWithoutAuxiliaresInput, CultoUncheckedCreateWithoutAuxiliaresInput> | CultoCreateWithoutAuxiliaresInput[] | CultoUncheckedCreateWithoutAuxiliaresInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutAuxiliaresInput | CultoCreateOrConnectWithoutAuxiliaresInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoCreateNestedManyWithoutLiderCanticoInput = {
    create?: XOR<CultoCreateWithoutLiderCanticoInput, CultoUncheckedCreateWithoutLiderCanticoInput> | CultoCreateWithoutLiderCanticoInput[] | CultoUncheckedCreateWithoutLiderCanticoInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLiderCanticoInput | CultoCreateOrConnectWithoutLiderCanticoInput[]
    createMany?: CultoCreateManyLiderCanticoInputEnvelope
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoCreateNestedManyWithoutVocalInput = {
    create?: XOR<CultoCreateWithoutVocalInput, CultoUncheckedCreateWithoutVocalInput> | CultoCreateWithoutVocalInput[] | CultoUncheckedCreateWithoutVocalInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutVocalInput | CultoCreateOrConnectWithoutVocalInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type ReuniaoCreateNestedManyWithoutResponsavelInput = {
    create?: XOR<ReuniaoCreateWithoutResponsavelInput, ReuniaoUncheckedCreateWithoutResponsavelInput> | ReuniaoCreateWithoutResponsavelInput[] | ReuniaoUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: ReuniaoCreateOrConnectWithoutResponsavelInput | ReuniaoCreateOrConnectWithoutResponsavelInput[]
    createMany?: ReuniaoCreateManyResponsavelInputEnvelope
    connect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
  }

  export type EnsaioCreateNestedManyWithoutResponsavelInput = {
    create?: XOR<EnsaioCreateWithoutResponsavelInput, EnsaioUncheckedCreateWithoutResponsavelInput> | EnsaioCreateWithoutResponsavelInput[] | EnsaioUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutResponsavelInput | EnsaioCreateOrConnectWithoutResponsavelInput[]
    createMany?: EnsaioCreateManyResponsavelInputEnvelope
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
  }

  export type EnsaioCreateNestedManyWithoutParticipantesInput = {
    create?: XOR<EnsaioCreateWithoutParticipantesInput, EnsaioUncheckedCreateWithoutParticipantesInput> | EnsaioCreateWithoutParticipantesInput[] | EnsaioUncheckedCreateWithoutParticipantesInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutParticipantesInput | EnsaioCreateOrConnectWithoutParticipantesInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
  }

  export type CultoUncheckedCreateNestedManyWithoutPastorInput = {
    create?: XOR<CultoCreateWithoutPastorInput, CultoUncheckedCreateWithoutPastorInput> | CultoCreateWithoutPastorInput[] | CultoUncheckedCreateWithoutPastorInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutPastorInput | CultoCreateOrConnectWithoutPastorInput[]
    createMany?: CultoCreateManyPastorInputEnvelope
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoUncheckedCreateNestedManyWithoutObreiroInput = {
    create?: XOR<CultoCreateWithoutObreiroInput, CultoUncheckedCreateWithoutObreiroInput> | CultoCreateWithoutObreiroInput[] | CultoUncheckedCreateWithoutObreiroInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutObreiroInput | CultoCreateOrConnectWithoutObreiroInput[]
    createMany?: CultoCreateManyObreiroInputEnvelope
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoUncheckedCreateNestedManyWithoutAuxiliaresInput = {
    create?: XOR<CultoCreateWithoutAuxiliaresInput, CultoUncheckedCreateWithoutAuxiliaresInput> | CultoCreateWithoutAuxiliaresInput[] | CultoUncheckedCreateWithoutAuxiliaresInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutAuxiliaresInput | CultoCreateOrConnectWithoutAuxiliaresInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoUncheckedCreateNestedManyWithoutLiderCanticoInput = {
    create?: XOR<CultoCreateWithoutLiderCanticoInput, CultoUncheckedCreateWithoutLiderCanticoInput> | CultoCreateWithoutLiderCanticoInput[] | CultoUncheckedCreateWithoutLiderCanticoInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLiderCanticoInput | CultoCreateOrConnectWithoutLiderCanticoInput[]
    createMany?: CultoCreateManyLiderCanticoInputEnvelope
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoUncheckedCreateNestedManyWithoutVocalInput = {
    create?: XOR<CultoCreateWithoutVocalInput, CultoUncheckedCreateWithoutVocalInput> | CultoCreateWithoutVocalInput[] | CultoUncheckedCreateWithoutVocalInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutVocalInput | CultoCreateOrConnectWithoutVocalInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type ReuniaoUncheckedCreateNestedManyWithoutResponsavelInput = {
    create?: XOR<ReuniaoCreateWithoutResponsavelInput, ReuniaoUncheckedCreateWithoutResponsavelInput> | ReuniaoCreateWithoutResponsavelInput[] | ReuniaoUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: ReuniaoCreateOrConnectWithoutResponsavelInput | ReuniaoCreateOrConnectWithoutResponsavelInput[]
    createMany?: ReuniaoCreateManyResponsavelInputEnvelope
    connect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
  }

  export type EnsaioUncheckedCreateNestedManyWithoutResponsavelInput = {
    create?: XOR<EnsaioCreateWithoutResponsavelInput, EnsaioUncheckedCreateWithoutResponsavelInput> | EnsaioCreateWithoutResponsavelInput[] | EnsaioUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutResponsavelInput | EnsaioCreateOrConnectWithoutResponsavelInput[]
    createMany?: EnsaioCreateManyResponsavelInputEnvelope
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
  }

  export type EnsaioUncheckedCreateNestedManyWithoutParticipantesInput = {
    create?: XOR<EnsaioCreateWithoutParticipantesInput, EnsaioUncheckedCreateWithoutParticipantesInput> | EnsaioCreateWithoutParticipantesInput[] | EnsaioUncheckedCreateWithoutParticipantesInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutParticipantesInput | EnsaioCreateOrConnectWithoutParticipantesInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CargoUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CargoCreateWithoutUsersInput, CargoUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CargoCreateOrConnectWithoutUsersInput
    upsert?: CargoUpsertWithoutUsersInput
    disconnect?: CargoWhereInput | boolean
    delete?: CargoWhereInput | boolean
    connect?: CargoWhereUniqueInput
    update?: XOR<XOR<CargoUpdateToOneWithWhereWithoutUsersInput, CargoUpdateWithoutUsersInput>, CargoUncheckedUpdateWithoutUsersInput>
  }

  export type CultoUpdateManyWithoutPastorNestedInput = {
    create?: XOR<CultoCreateWithoutPastorInput, CultoUncheckedCreateWithoutPastorInput> | CultoCreateWithoutPastorInput[] | CultoUncheckedCreateWithoutPastorInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutPastorInput | CultoCreateOrConnectWithoutPastorInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutPastorInput | CultoUpsertWithWhereUniqueWithoutPastorInput[]
    createMany?: CultoCreateManyPastorInputEnvelope
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutPastorInput | CultoUpdateWithWhereUniqueWithoutPastorInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutPastorInput | CultoUpdateManyWithWhereWithoutPastorInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoUpdateManyWithoutObreiroNestedInput = {
    create?: XOR<CultoCreateWithoutObreiroInput, CultoUncheckedCreateWithoutObreiroInput> | CultoCreateWithoutObreiroInput[] | CultoUncheckedCreateWithoutObreiroInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutObreiroInput | CultoCreateOrConnectWithoutObreiroInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutObreiroInput | CultoUpsertWithWhereUniqueWithoutObreiroInput[]
    createMany?: CultoCreateManyObreiroInputEnvelope
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutObreiroInput | CultoUpdateWithWhereUniqueWithoutObreiroInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutObreiroInput | CultoUpdateManyWithWhereWithoutObreiroInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoUpdateManyWithoutAuxiliaresNestedInput = {
    create?: XOR<CultoCreateWithoutAuxiliaresInput, CultoUncheckedCreateWithoutAuxiliaresInput> | CultoCreateWithoutAuxiliaresInput[] | CultoUncheckedCreateWithoutAuxiliaresInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutAuxiliaresInput | CultoCreateOrConnectWithoutAuxiliaresInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutAuxiliaresInput | CultoUpsertWithWhereUniqueWithoutAuxiliaresInput[]
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutAuxiliaresInput | CultoUpdateWithWhereUniqueWithoutAuxiliaresInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutAuxiliaresInput | CultoUpdateManyWithWhereWithoutAuxiliaresInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoUpdateManyWithoutLiderCanticoNestedInput = {
    create?: XOR<CultoCreateWithoutLiderCanticoInput, CultoUncheckedCreateWithoutLiderCanticoInput> | CultoCreateWithoutLiderCanticoInput[] | CultoUncheckedCreateWithoutLiderCanticoInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLiderCanticoInput | CultoCreateOrConnectWithoutLiderCanticoInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutLiderCanticoInput | CultoUpsertWithWhereUniqueWithoutLiderCanticoInput[]
    createMany?: CultoCreateManyLiderCanticoInputEnvelope
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutLiderCanticoInput | CultoUpdateWithWhereUniqueWithoutLiderCanticoInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutLiderCanticoInput | CultoUpdateManyWithWhereWithoutLiderCanticoInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoUpdateManyWithoutVocalNestedInput = {
    create?: XOR<CultoCreateWithoutVocalInput, CultoUncheckedCreateWithoutVocalInput> | CultoCreateWithoutVocalInput[] | CultoUncheckedCreateWithoutVocalInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutVocalInput | CultoCreateOrConnectWithoutVocalInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutVocalInput | CultoUpsertWithWhereUniqueWithoutVocalInput[]
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutVocalInput | CultoUpdateWithWhereUniqueWithoutVocalInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutVocalInput | CultoUpdateManyWithWhereWithoutVocalInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type ReuniaoUpdateManyWithoutResponsavelNestedInput = {
    create?: XOR<ReuniaoCreateWithoutResponsavelInput, ReuniaoUncheckedCreateWithoutResponsavelInput> | ReuniaoCreateWithoutResponsavelInput[] | ReuniaoUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: ReuniaoCreateOrConnectWithoutResponsavelInput | ReuniaoCreateOrConnectWithoutResponsavelInput[]
    upsert?: ReuniaoUpsertWithWhereUniqueWithoutResponsavelInput | ReuniaoUpsertWithWhereUniqueWithoutResponsavelInput[]
    createMany?: ReuniaoCreateManyResponsavelInputEnvelope
    set?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    disconnect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    delete?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    connect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    update?: ReuniaoUpdateWithWhereUniqueWithoutResponsavelInput | ReuniaoUpdateWithWhereUniqueWithoutResponsavelInput[]
    updateMany?: ReuniaoUpdateManyWithWhereWithoutResponsavelInput | ReuniaoUpdateManyWithWhereWithoutResponsavelInput[]
    deleteMany?: ReuniaoScalarWhereInput | ReuniaoScalarWhereInput[]
  }

  export type EnsaioUpdateManyWithoutResponsavelNestedInput = {
    create?: XOR<EnsaioCreateWithoutResponsavelInput, EnsaioUncheckedCreateWithoutResponsavelInput> | EnsaioCreateWithoutResponsavelInput[] | EnsaioUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutResponsavelInput | EnsaioCreateOrConnectWithoutResponsavelInput[]
    upsert?: EnsaioUpsertWithWhereUniqueWithoutResponsavelInput | EnsaioUpsertWithWhereUniqueWithoutResponsavelInput[]
    createMany?: EnsaioCreateManyResponsavelInputEnvelope
    set?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    disconnect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    delete?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    update?: EnsaioUpdateWithWhereUniqueWithoutResponsavelInput | EnsaioUpdateWithWhereUniqueWithoutResponsavelInput[]
    updateMany?: EnsaioUpdateManyWithWhereWithoutResponsavelInput | EnsaioUpdateManyWithWhereWithoutResponsavelInput[]
    deleteMany?: EnsaioScalarWhereInput | EnsaioScalarWhereInput[]
  }

  export type EnsaioUpdateManyWithoutParticipantesNestedInput = {
    create?: XOR<EnsaioCreateWithoutParticipantesInput, EnsaioUncheckedCreateWithoutParticipantesInput> | EnsaioCreateWithoutParticipantesInput[] | EnsaioUncheckedCreateWithoutParticipantesInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutParticipantesInput | EnsaioCreateOrConnectWithoutParticipantesInput[]
    upsert?: EnsaioUpsertWithWhereUniqueWithoutParticipantesInput | EnsaioUpsertWithWhereUniqueWithoutParticipantesInput[]
    set?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    disconnect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    delete?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    update?: EnsaioUpdateWithWhereUniqueWithoutParticipantesInput | EnsaioUpdateWithWhereUniqueWithoutParticipantesInput[]
    updateMany?: EnsaioUpdateManyWithWhereWithoutParticipantesInput | EnsaioUpdateManyWithWhereWithoutParticipantesInput[]
    deleteMany?: EnsaioScalarWhereInput | EnsaioScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CultoUncheckedUpdateManyWithoutPastorNestedInput = {
    create?: XOR<CultoCreateWithoutPastorInput, CultoUncheckedCreateWithoutPastorInput> | CultoCreateWithoutPastorInput[] | CultoUncheckedCreateWithoutPastorInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutPastorInput | CultoCreateOrConnectWithoutPastorInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutPastorInput | CultoUpsertWithWhereUniqueWithoutPastorInput[]
    createMany?: CultoCreateManyPastorInputEnvelope
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutPastorInput | CultoUpdateWithWhereUniqueWithoutPastorInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutPastorInput | CultoUpdateManyWithWhereWithoutPastorInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoUncheckedUpdateManyWithoutObreiroNestedInput = {
    create?: XOR<CultoCreateWithoutObreiroInput, CultoUncheckedCreateWithoutObreiroInput> | CultoCreateWithoutObreiroInput[] | CultoUncheckedCreateWithoutObreiroInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutObreiroInput | CultoCreateOrConnectWithoutObreiroInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutObreiroInput | CultoUpsertWithWhereUniqueWithoutObreiroInput[]
    createMany?: CultoCreateManyObreiroInputEnvelope
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutObreiroInput | CultoUpdateWithWhereUniqueWithoutObreiroInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutObreiroInput | CultoUpdateManyWithWhereWithoutObreiroInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoUncheckedUpdateManyWithoutAuxiliaresNestedInput = {
    create?: XOR<CultoCreateWithoutAuxiliaresInput, CultoUncheckedCreateWithoutAuxiliaresInput> | CultoCreateWithoutAuxiliaresInput[] | CultoUncheckedCreateWithoutAuxiliaresInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutAuxiliaresInput | CultoCreateOrConnectWithoutAuxiliaresInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutAuxiliaresInput | CultoUpsertWithWhereUniqueWithoutAuxiliaresInput[]
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutAuxiliaresInput | CultoUpdateWithWhereUniqueWithoutAuxiliaresInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutAuxiliaresInput | CultoUpdateManyWithWhereWithoutAuxiliaresInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoUncheckedUpdateManyWithoutLiderCanticoNestedInput = {
    create?: XOR<CultoCreateWithoutLiderCanticoInput, CultoUncheckedCreateWithoutLiderCanticoInput> | CultoCreateWithoutLiderCanticoInput[] | CultoUncheckedCreateWithoutLiderCanticoInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLiderCanticoInput | CultoCreateOrConnectWithoutLiderCanticoInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutLiderCanticoInput | CultoUpsertWithWhereUniqueWithoutLiderCanticoInput[]
    createMany?: CultoCreateManyLiderCanticoInputEnvelope
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutLiderCanticoInput | CultoUpdateWithWhereUniqueWithoutLiderCanticoInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutLiderCanticoInput | CultoUpdateManyWithWhereWithoutLiderCanticoInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoUncheckedUpdateManyWithoutVocalNestedInput = {
    create?: XOR<CultoCreateWithoutVocalInput, CultoUncheckedCreateWithoutVocalInput> | CultoCreateWithoutVocalInput[] | CultoUncheckedCreateWithoutVocalInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutVocalInput | CultoCreateOrConnectWithoutVocalInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutVocalInput | CultoUpsertWithWhereUniqueWithoutVocalInput[]
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutVocalInput | CultoUpdateWithWhereUniqueWithoutVocalInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutVocalInput | CultoUpdateManyWithWhereWithoutVocalInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type ReuniaoUncheckedUpdateManyWithoutResponsavelNestedInput = {
    create?: XOR<ReuniaoCreateWithoutResponsavelInput, ReuniaoUncheckedCreateWithoutResponsavelInput> | ReuniaoCreateWithoutResponsavelInput[] | ReuniaoUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: ReuniaoCreateOrConnectWithoutResponsavelInput | ReuniaoCreateOrConnectWithoutResponsavelInput[]
    upsert?: ReuniaoUpsertWithWhereUniqueWithoutResponsavelInput | ReuniaoUpsertWithWhereUniqueWithoutResponsavelInput[]
    createMany?: ReuniaoCreateManyResponsavelInputEnvelope
    set?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    disconnect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    delete?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    connect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    update?: ReuniaoUpdateWithWhereUniqueWithoutResponsavelInput | ReuniaoUpdateWithWhereUniqueWithoutResponsavelInput[]
    updateMany?: ReuniaoUpdateManyWithWhereWithoutResponsavelInput | ReuniaoUpdateManyWithWhereWithoutResponsavelInput[]
    deleteMany?: ReuniaoScalarWhereInput | ReuniaoScalarWhereInput[]
  }

  export type EnsaioUncheckedUpdateManyWithoutResponsavelNestedInput = {
    create?: XOR<EnsaioCreateWithoutResponsavelInput, EnsaioUncheckedCreateWithoutResponsavelInput> | EnsaioCreateWithoutResponsavelInput[] | EnsaioUncheckedCreateWithoutResponsavelInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutResponsavelInput | EnsaioCreateOrConnectWithoutResponsavelInput[]
    upsert?: EnsaioUpsertWithWhereUniqueWithoutResponsavelInput | EnsaioUpsertWithWhereUniqueWithoutResponsavelInput[]
    createMany?: EnsaioCreateManyResponsavelInputEnvelope
    set?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    disconnect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    delete?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    update?: EnsaioUpdateWithWhereUniqueWithoutResponsavelInput | EnsaioUpdateWithWhereUniqueWithoutResponsavelInput[]
    updateMany?: EnsaioUpdateManyWithWhereWithoutResponsavelInput | EnsaioUpdateManyWithWhereWithoutResponsavelInput[]
    deleteMany?: EnsaioScalarWhereInput | EnsaioScalarWhereInput[]
  }

  export type EnsaioUncheckedUpdateManyWithoutParticipantesNestedInput = {
    create?: XOR<EnsaioCreateWithoutParticipantesInput, EnsaioUncheckedCreateWithoutParticipantesInput> | EnsaioCreateWithoutParticipantesInput[] | EnsaioUncheckedCreateWithoutParticipantesInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutParticipantesInput | EnsaioCreateOrConnectWithoutParticipantesInput[]
    upsert?: EnsaioUpsertWithWhereUniqueWithoutParticipantesInput | EnsaioUpsertWithWhereUniqueWithoutParticipantesInput[]
    set?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    disconnect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    delete?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    update?: EnsaioUpdateWithWhereUniqueWithoutParticipantesInput | EnsaioUpdateWithWhereUniqueWithoutParticipantesInput[]
    updateMany?: EnsaioUpdateManyWithWhereWithoutParticipantesInput | EnsaioUpdateManyWithWhereWithoutParticipantesInput[]
    deleteMany?: EnsaioScalarWhereInput | EnsaioScalarWhereInput[]
  }

  export type LeituraCreateNestedManyWithoutLiveInput = {
    create?: XOR<LeituraCreateWithoutLiveInput, LeituraUncheckedCreateWithoutLiveInput> | LeituraCreateWithoutLiveInput[] | LeituraUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: LeituraCreateOrConnectWithoutLiveInput | LeituraCreateOrConnectWithoutLiveInput[]
    createMany?: LeituraCreateManyLiveInputEnvelope
    connect?: LeituraWhereUniqueInput | LeituraWhereUniqueInput[]
  }

  export type PedidoOracaoCreateNestedManyWithoutLiveInput = {
    create?: XOR<PedidoOracaoCreateWithoutLiveInput, PedidoOracaoUncheckedCreateWithoutLiveInput> | PedidoOracaoCreateWithoutLiveInput[] | PedidoOracaoUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: PedidoOracaoCreateOrConnectWithoutLiveInput | PedidoOracaoCreateOrConnectWithoutLiveInput[]
    createMany?: PedidoOracaoCreateManyLiveInputEnvelope
    connect?: PedidoOracaoWhereUniqueInput | PedidoOracaoWhereUniqueInput[]
  }

  export type ViewerSessionCreateNestedManyWithoutLiveInput = {
    create?: XOR<ViewerSessionCreateWithoutLiveInput, ViewerSessionUncheckedCreateWithoutLiveInput> | ViewerSessionCreateWithoutLiveInput[] | ViewerSessionUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: ViewerSessionCreateOrConnectWithoutLiveInput | ViewerSessionCreateOrConnectWithoutLiveInput[]
    createMany?: ViewerSessionCreateManyLiveInputEnvelope
    connect?: ViewerSessionWhereUniqueInput | ViewerSessionWhereUniqueInput[]
  }

  export type LeituraUncheckedCreateNestedManyWithoutLiveInput = {
    create?: XOR<LeituraCreateWithoutLiveInput, LeituraUncheckedCreateWithoutLiveInput> | LeituraCreateWithoutLiveInput[] | LeituraUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: LeituraCreateOrConnectWithoutLiveInput | LeituraCreateOrConnectWithoutLiveInput[]
    createMany?: LeituraCreateManyLiveInputEnvelope
    connect?: LeituraWhereUniqueInput | LeituraWhereUniqueInput[]
  }

  export type PedidoOracaoUncheckedCreateNestedManyWithoutLiveInput = {
    create?: XOR<PedidoOracaoCreateWithoutLiveInput, PedidoOracaoUncheckedCreateWithoutLiveInput> | PedidoOracaoCreateWithoutLiveInput[] | PedidoOracaoUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: PedidoOracaoCreateOrConnectWithoutLiveInput | PedidoOracaoCreateOrConnectWithoutLiveInput[]
    createMany?: PedidoOracaoCreateManyLiveInputEnvelope
    connect?: PedidoOracaoWhereUniqueInput | PedidoOracaoWhereUniqueInput[]
  }

  export type ViewerSessionUncheckedCreateNestedManyWithoutLiveInput = {
    create?: XOR<ViewerSessionCreateWithoutLiveInput, ViewerSessionUncheckedCreateWithoutLiveInput> | ViewerSessionCreateWithoutLiveInput[] | ViewerSessionUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: ViewerSessionCreateOrConnectWithoutLiveInput | ViewerSessionCreateOrConnectWithoutLiveInput[]
    createMany?: ViewerSessionCreateManyLiveInputEnvelope
    connect?: ViewerSessionWhereUniqueInput | ViewerSessionWhereUniqueInput[]
  }

  export type LeituraUpdateManyWithoutLiveNestedInput = {
    create?: XOR<LeituraCreateWithoutLiveInput, LeituraUncheckedCreateWithoutLiveInput> | LeituraCreateWithoutLiveInput[] | LeituraUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: LeituraCreateOrConnectWithoutLiveInput | LeituraCreateOrConnectWithoutLiveInput[]
    upsert?: LeituraUpsertWithWhereUniqueWithoutLiveInput | LeituraUpsertWithWhereUniqueWithoutLiveInput[]
    createMany?: LeituraCreateManyLiveInputEnvelope
    set?: LeituraWhereUniqueInput | LeituraWhereUniqueInput[]
    disconnect?: LeituraWhereUniqueInput | LeituraWhereUniqueInput[]
    delete?: LeituraWhereUniqueInput | LeituraWhereUniqueInput[]
    connect?: LeituraWhereUniqueInput | LeituraWhereUniqueInput[]
    update?: LeituraUpdateWithWhereUniqueWithoutLiveInput | LeituraUpdateWithWhereUniqueWithoutLiveInput[]
    updateMany?: LeituraUpdateManyWithWhereWithoutLiveInput | LeituraUpdateManyWithWhereWithoutLiveInput[]
    deleteMany?: LeituraScalarWhereInput | LeituraScalarWhereInput[]
  }

  export type PedidoOracaoUpdateManyWithoutLiveNestedInput = {
    create?: XOR<PedidoOracaoCreateWithoutLiveInput, PedidoOracaoUncheckedCreateWithoutLiveInput> | PedidoOracaoCreateWithoutLiveInput[] | PedidoOracaoUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: PedidoOracaoCreateOrConnectWithoutLiveInput | PedidoOracaoCreateOrConnectWithoutLiveInput[]
    upsert?: PedidoOracaoUpsertWithWhereUniqueWithoutLiveInput | PedidoOracaoUpsertWithWhereUniqueWithoutLiveInput[]
    createMany?: PedidoOracaoCreateManyLiveInputEnvelope
    set?: PedidoOracaoWhereUniqueInput | PedidoOracaoWhereUniqueInput[]
    disconnect?: PedidoOracaoWhereUniqueInput | PedidoOracaoWhereUniqueInput[]
    delete?: PedidoOracaoWhereUniqueInput | PedidoOracaoWhereUniqueInput[]
    connect?: PedidoOracaoWhereUniqueInput | PedidoOracaoWhereUniqueInput[]
    update?: PedidoOracaoUpdateWithWhereUniqueWithoutLiveInput | PedidoOracaoUpdateWithWhereUniqueWithoutLiveInput[]
    updateMany?: PedidoOracaoUpdateManyWithWhereWithoutLiveInput | PedidoOracaoUpdateManyWithWhereWithoutLiveInput[]
    deleteMany?: PedidoOracaoScalarWhereInput | PedidoOracaoScalarWhereInput[]
  }

  export type ViewerSessionUpdateManyWithoutLiveNestedInput = {
    create?: XOR<ViewerSessionCreateWithoutLiveInput, ViewerSessionUncheckedCreateWithoutLiveInput> | ViewerSessionCreateWithoutLiveInput[] | ViewerSessionUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: ViewerSessionCreateOrConnectWithoutLiveInput | ViewerSessionCreateOrConnectWithoutLiveInput[]
    upsert?: ViewerSessionUpsertWithWhereUniqueWithoutLiveInput | ViewerSessionUpsertWithWhereUniqueWithoutLiveInput[]
    createMany?: ViewerSessionCreateManyLiveInputEnvelope
    set?: ViewerSessionWhereUniqueInput | ViewerSessionWhereUniqueInput[]
    disconnect?: ViewerSessionWhereUniqueInput | ViewerSessionWhereUniqueInput[]
    delete?: ViewerSessionWhereUniqueInput | ViewerSessionWhereUniqueInput[]
    connect?: ViewerSessionWhereUniqueInput | ViewerSessionWhereUniqueInput[]
    update?: ViewerSessionUpdateWithWhereUniqueWithoutLiveInput | ViewerSessionUpdateWithWhereUniqueWithoutLiveInput[]
    updateMany?: ViewerSessionUpdateManyWithWhereWithoutLiveInput | ViewerSessionUpdateManyWithWhereWithoutLiveInput[]
    deleteMany?: ViewerSessionScalarWhereInput | ViewerSessionScalarWhereInput[]
  }

  export type LeituraUncheckedUpdateManyWithoutLiveNestedInput = {
    create?: XOR<LeituraCreateWithoutLiveInput, LeituraUncheckedCreateWithoutLiveInput> | LeituraCreateWithoutLiveInput[] | LeituraUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: LeituraCreateOrConnectWithoutLiveInput | LeituraCreateOrConnectWithoutLiveInput[]
    upsert?: LeituraUpsertWithWhereUniqueWithoutLiveInput | LeituraUpsertWithWhereUniqueWithoutLiveInput[]
    createMany?: LeituraCreateManyLiveInputEnvelope
    set?: LeituraWhereUniqueInput | LeituraWhereUniqueInput[]
    disconnect?: LeituraWhereUniqueInput | LeituraWhereUniqueInput[]
    delete?: LeituraWhereUniqueInput | LeituraWhereUniqueInput[]
    connect?: LeituraWhereUniqueInput | LeituraWhereUniqueInput[]
    update?: LeituraUpdateWithWhereUniqueWithoutLiveInput | LeituraUpdateWithWhereUniqueWithoutLiveInput[]
    updateMany?: LeituraUpdateManyWithWhereWithoutLiveInput | LeituraUpdateManyWithWhereWithoutLiveInput[]
    deleteMany?: LeituraScalarWhereInput | LeituraScalarWhereInput[]
  }

  export type PedidoOracaoUncheckedUpdateManyWithoutLiveNestedInput = {
    create?: XOR<PedidoOracaoCreateWithoutLiveInput, PedidoOracaoUncheckedCreateWithoutLiveInput> | PedidoOracaoCreateWithoutLiveInput[] | PedidoOracaoUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: PedidoOracaoCreateOrConnectWithoutLiveInput | PedidoOracaoCreateOrConnectWithoutLiveInput[]
    upsert?: PedidoOracaoUpsertWithWhereUniqueWithoutLiveInput | PedidoOracaoUpsertWithWhereUniqueWithoutLiveInput[]
    createMany?: PedidoOracaoCreateManyLiveInputEnvelope
    set?: PedidoOracaoWhereUniqueInput | PedidoOracaoWhereUniqueInput[]
    disconnect?: PedidoOracaoWhereUniqueInput | PedidoOracaoWhereUniqueInput[]
    delete?: PedidoOracaoWhereUniqueInput | PedidoOracaoWhereUniqueInput[]
    connect?: PedidoOracaoWhereUniqueInput | PedidoOracaoWhereUniqueInput[]
    update?: PedidoOracaoUpdateWithWhereUniqueWithoutLiveInput | PedidoOracaoUpdateWithWhereUniqueWithoutLiveInput[]
    updateMany?: PedidoOracaoUpdateManyWithWhereWithoutLiveInput | PedidoOracaoUpdateManyWithWhereWithoutLiveInput[]
    deleteMany?: PedidoOracaoScalarWhereInput | PedidoOracaoScalarWhereInput[]
  }

  export type ViewerSessionUncheckedUpdateManyWithoutLiveNestedInput = {
    create?: XOR<ViewerSessionCreateWithoutLiveInput, ViewerSessionUncheckedCreateWithoutLiveInput> | ViewerSessionCreateWithoutLiveInput[] | ViewerSessionUncheckedCreateWithoutLiveInput[]
    connectOrCreate?: ViewerSessionCreateOrConnectWithoutLiveInput | ViewerSessionCreateOrConnectWithoutLiveInput[]
    upsert?: ViewerSessionUpsertWithWhereUniqueWithoutLiveInput | ViewerSessionUpsertWithWhereUniqueWithoutLiveInput[]
    createMany?: ViewerSessionCreateManyLiveInputEnvelope
    set?: ViewerSessionWhereUniqueInput | ViewerSessionWhereUniqueInput[]
    disconnect?: ViewerSessionWhereUniqueInput | ViewerSessionWhereUniqueInput[]
    delete?: ViewerSessionWhereUniqueInput | ViewerSessionWhereUniqueInput[]
    connect?: ViewerSessionWhereUniqueInput | ViewerSessionWhereUniqueInput[]
    update?: ViewerSessionUpdateWithWhereUniqueWithoutLiveInput | ViewerSessionUpdateWithWhereUniqueWithoutLiveInput[]
    updateMany?: ViewerSessionUpdateManyWithWhereWithoutLiveInput | ViewerSessionUpdateManyWithWhereWithoutLiveInput[]
    deleteMany?: ViewerSessionScalarWhereInput | ViewerSessionScalarWhereInput[]
  }

  export type LiveCreateNestedOneWithoutLeiturasInput = {
    create?: XOR<LiveCreateWithoutLeiturasInput, LiveUncheckedCreateWithoutLeiturasInput>
    connectOrCreate?: LiveCreateOrConnectWithoutLeiturasInput
    connect?: LiveWhereUniqueInput
  }

  export type LiveUpdateOneRequiredWithoutLeiturasNestedInput = {
    create?: XOR<LiveCreateWithoutLeiturasInput, LiveUncheckedCreateWithoutLeiturasInput>
    connectOrCreate?: LiveCreateOrConnectWithoutLeiturasInput
    upsert?: LiveUpsertWithoutLeiturasInput
    connect?: LiveWhereUniqueInput
    update?: XOR<XOR<LiveUpdateToOneWithWhereWithoutLeiturasInput, LiveUpdateWithoutLeiturasInput>, LiveUncheckedUpdateWithoutLeiturasInput>
  }

  export type LiveCreateNestedOneWithoutPedidosOracaoInput = {
    create?: XOR<LiveCreateWithoutPedidosOracaoInput, LiveUncheckedCreateWithoutPedidosOracaoInput>
    connectOrCreate?: LiveCreateOrConnectWithoutPedidosOracaoInput
    connect?: LiveWhereUniqueInput
  }

  export type LiveUpdateOneRequiredWithoutPedidosOracaoNestedInput = {
    create?: XOR<LiveCreateWithoutPedidosOracaoInput, LiveUncheckedCreateWithoutPedidosOracaoInput>
    connectOrCreate?: LiveCreateOrConnectWithoutPedidosOracaoInput
    upsert?: LiveUpsertWithoutPedidosOracaoInput
    connect?: LiveWhereUniqueInput
    update?: XOR<XOR<LiveUpdateToOneWithWhereWithoutPedidosOracaoInput, LiveUpdateWithoutPedidosOracaoInput>, LiveUncheckedUpdateWithoutPedidosOracaoInput>
  }

  export type LiveCreateNestedOneWithoutViewerSessionsInput = {
    create?: XOR<LiveCreateWithoutViewerSessionsInput, LiveUncheckedCreateWithoutViewerSessionsInput>
    connectOrCreate?: LiveCreateOrConnectWithoutViewerSessionsInput
    connect?: LiveWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type LiveUpdateOneRequiredWithoutViewerSessionsNestedInput = {
    create?: XOR<LiveCreateWithoutViewerSessionsInput, LiveUncheckedCreateWithoutViewerSessionsInput>
    connectOrCreate?: LiveCreateOrConnectWithoutViewerSessionsInput
    upsert?: LiveUpsertWithoutViewerSessionsInput
    connect?: LiveWhereUniqueInput
    update?: XOR<XOR<LiveUpdateToOneWithWhereWithoutViewerSessionsInput, LiveUpdateWithoutViewerSessionsInput>, LiveUncheckedUpdateWithoutViewerSessionsInput>
  }

  export type UserCreateNestedManyWithoutCargoInput = {
    create?: XOR<UserCreateWithoutCargoInput, UserUncheckedCreateWithoutCargoInput> | UserCreateWithoutCargoInput[] | UserUncheckedCreateWithoutCargoInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCargoInput | UserCreateOrConnectWithoutCargoInput[]
    createMany?: UserCreateManyCargoInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCargoInput = {
    create?: XOR<UserCreateWithoutCargoInput, UserUncheckedCreateWithoutCargoInput> | UserCreateWithoutCargoInput[] | UserUncheckedCreateWithoutCargoInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCargoInput | UserCreateOrConnectWithoutCargoInput[]
    createMany?: UserCreateManyCargoInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutCargoNestedInput = {
    create?: XOR<UserCreateWithoutCargoInput, UserUncheckedCreateWithoutCargoInput> | UserCreateWithoutCargoInput[] | UserUncheckedCreateWithoutCargoInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCargoInput | UserCreateOrConnectWithoutCargoInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCargoInput | UserUpsertWithWhereUniqueWithoutCargoInput[]
    createMany?: UserCreateManyCargoInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCargoInput | UserUpdateWithWhereUniqueWithoutCargoInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCargoInput | UserUpdateManyWithWhereWithoutCargoInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCargoNestedInput = {
    create?: XOR<UserCreateWithoutCargoInput, UserUncheckedCreateWithoutCargoInput> | UserCreateWithoutCargoInput[] | UserUncheckedCreateWithoutCargoInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCargoInput | UserCreateOrConnectWithoutCargoInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCargoInput | UserUpsertWithWhereUniqueWithoutCargoInput[]
    createMany?: UserCreateManyCargoInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCargoInput | UserUpdateWithWhereUniqueWithoutCargoInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCargoInput | UserUpdateManyWithWhereWithoutCargoInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CultoCreateNestedManyWithoutLocalInput = {
    create?: XOR<CultoCreateWithoutLocalInput, CultoUncheckedCreateWithoutLocalInput> | CultoCreateWithoutLocalInput[] | CultoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLocalInput | CultoCreateOrConnectWithoutLocalInput[]
    createMany?: CultoCreateManyLocalInputEnvelope
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type ReuniaoCreateNestedManyWithoutLocalInput = {
    create?: XOR<ReuniaoCreateWithoutLocalInput, ReuniaoUncheckedCreateWithoutLocalInput> | ReuniaoCreateWithoutLocalInput[] | ReuniaoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: ReuniaoCreateOrConnectWithoutLocalInput | ReuniaoCreateOrConnectWithoutLocalInput[]
    createMany?: ReuniaoCreateManyLocalInputEnvelope
    connect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
  }

  export type EnsaioCreateNestedManyWithoutLocalInput = {
    create?: XOR<EnsaioCreateWithoutLocalInput, EnsaioUncheckedCreateWithoutLocalInput> | EnsaioCreateWithoutLocalInput[] | EnsaioUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutLocalInput | EnsaioCreateOrConnectWithoutLocalInput[]
    createMany?: EnsaioCreateManyLocalInputEnvelope
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
  }

  export type EventoCreateNestedManyWithoutLocalInput = {
    create?: XOR<EventoCreateWithoutLocalInput, EventoUncheckedCreateWithoutLocalInput> | EventoCreateWithoutLocalInput[] | EventoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutLocalInput | EventoCreateOrConnectWithoutLocalInput[]
    createMany?: EventoCreateManyLocalInputEnvelope
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
  }

  export type CultoUncheckedCreateNestedManyWithoutLocalInput = {
    create?: XOR<CultoCreateWithoutLocalInput, CultoUncheckedCreateWithoutLocalInput> | CultoCreateWithoutLocalInput[] | CultoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLocalInput | CultoCreateOrConnectWithoutLocalInput[]
    createMany?: CultoCreateManyLocalInputEnvelope
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type ReuniaoUncheckedCreateNestedManyWithoutLocalInput = {
    create?: XOR<ReuniaoCreateWithoutLocalInput, ReuniaoUncheckedCreateWithoutLocalInput> | ReuniaoCreateWithoutLocalInput[] | ReuniaoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: ReuniaoCreateOrConnectWithoutLocalInput | ReuniaoCreateOrConnectWithoutLocalInput[]
    createMany?: ReuniaoCreateManyLocalInputEnvelope
    connect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
  }

  export type EnsaioUncheckedCreateNestedManyWithoutLocalInput = {
    create?: XOR<EnsaioCreateWithoutLocalInput, EnsaioUncheckedCreateWithoutLocalInput> | EnsaioCreateWithoutLocalInput[] | EnsaioUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutLocalInput | EnsaioCreateOrConnectWithoutLocalInput[]
    createMany?: EnsaioCreateManyLocalInputEnvelope
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
  }

  export type EventoUncheckedCreateNestedManyWithoutLocalInput = {
    create?: XOR<EventoCreateWithoutLocalInput, EventoUncheckedCreateWithoutLocalInput> | EventoCreateWithoutLocalInput[] | EventoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutLocalInput | EventoCreateOrConnectWithoutLocalInput[]
    createMany?: EventoCreateManyLocalInputEnvelope
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CultoUpdateManyWithoutLocalNestedInput = {
    create?: XOR<CultoCreateWithoutLocalInput, CultoUncheckedCreateWithoutLocalInput> | CultoCreateWithoutLocalInput[] | CultoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLocalInput | CultoCreateOrConnectWithoutLocalInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutLocalInput | CultoUpsertWithWhereUniqueWithoutLocalInput[]
    createMany?: CultoCreateManyLocalInputEnvelope
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutLocalInput | CultoUpdateWithWhereUniqueWithoutLocalInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutLocalInput | CultoUpdateManyWithWhereWithoutLocalInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type ReuniaoUpdateManyWithoutLocalNestedInput = {
    create?: XOR<ReuniaoCreateWithoutLocalInput, ReuniaoUncheckedCreateWithoutLocalInput> | ReuniaoCreateWithoutLocalInput[] | ReuniaoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: ReuniaoCreateOrConnectWithoutLocalInput | ReuniaoCreateOrConnectWithoutLocalInput[]
    upsert?: ReuniaoUpsertWithWhereUniqueWithoutLocalInput | ReuniaoUpsertWithWhereUniqueWithoutLocalInput[]
    createMany?: ReuniaoCreateManyLocalInputEnvelope
    set?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    disconnect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    delete?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    connect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    update?: ReuniaoUpdateWithWhereUniqueWithoutLocalInput | ReuniaoUpdateWithWhereUniqueWithoutLocalInput[]
    updateMany?: ReuniaoUpdateManyWithWhereWithoutLocalInput | ReuniaoUpdateManyWithWhereWithoutLocalInput[]
    deleteMany?: ReuniaoScalarWhereInput | ReuniaoScalarWhereInput[]
  }

  export type EnsaioUpdateManyWithoutLocalNestedInput = {
    create?: XOR<EnsaioCreateWithoutLocalInput, EnsaioUncheckedCreateWithoutLocalInput> | EnsaioCreateWithoutLocalInput[] | EnsaioUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutLocalInput | EnsaioCreateOrConnectWithoutLocalInput[]
    upsert?: EnsaioUpsertWithWhereUniqueWithoutLocalInput | EnsaioUpsertWithWhereUniqueWithoutLocalInput[]
    createMany?: EnsaioCreateManyLocalInputEnvelope
    set?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    disconnect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    delete?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    update?: EnsaioUpdateWithWhereUniqueWithoutLocalInput | EnsaioUpdateWithWhereUniqueWithoutLocalInput[]
    updateMany?: EnsaioUpdateManyWithWhereWithoutLocalInput | EnsaioUpdateManyWithWhereWithoutLocalInput[]
    deleteMany?: EnsaioScalarWhereInput | EnsaioScalarWhereInput[]
  }

  export type EventoUpdateManyWithoutLocalNestedInput = {
    create?: XOR<EventoCreateWithoutLocalInput, EventoUncheckedCreateWithoutLocalInput> | EventoCreateWithoutLocalInput[] | EventoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutLocalInput | EventoCreateOrConnectWithoutLocalInput[]
    upsert?: EventoUpsertWithWhereUniqueWithoutLocalInput | EventoUpsertWithWhereUniqueWithoutLocalInput[]
    createMany?: EventoCreateManyLocalInputEnvelope
    set?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    disconnect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    delete?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    update?: EventoUpdateWithWhereUniqueWithoutLocalInput | EventoUpdateWithWhereUniqueWithoutLocalInput[]
    updateMany?: EventoUpdateManyWithWhereWithoutLocalInput | EventoUpdateManyWithWhereWithoutLocalInput[]
    deleteMany?: EventoScalarWhereInput | EventoScalarWhereInput[]
  }

  export type CultoUncheckedUpdateManyWithoutLocalNestedInput = {
    create?: XOR<CultoCreateWithoutLocalInput, CultoUncheckedCreateWithoutLocalInput> | CultoCreateWithoutLocalInput[] | CultoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLocalInput | CultoCreateOrConnectWithoutLocalInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutLocalInput | CultoUpsertWithWhereUniqueWithoutLocalInput[]
    createMany?: CultoCreateManyLocalInputEnvelope
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutLocalInput | CultoUpdateWithWhereUniqueWithoutLocalInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutLocalInput | CultoUpdateManyWithWhereWithoutLocalInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type ReuniaoUncheckedUpdateManyWithoutLocalNestedInput = {
    create?: XOR<ReuniaoCreateWithoutLocalInput, ReuniaoUncheckedCreateWithoutLocalInput> | ReuniaoCreateWithoutLocalInput[] | ReuniaoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: ReuniaoCreateOrConnectWithoutLocalInput | ReuniaoCreateOrConnectWithoutLocalInput[]
    upsert?: ReuniaoUpsertWithWhereUniqueWithoutLocalInput | ReuniaoUpsertWithWhereUniqueWithoutLocalInput[]
    createMany?: ReuniaoCreateManyLocalInputEnvelope
    set?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    disconnect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    delete?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    connect?: ReuniaoWhereUniqueInput | ReuniaoWhereUniqueInput[]
    update?: ReuniaoUpdateWithWhereUniqueWithoutLocalInput | ReuniaoUpdateWithWhereUniqueWithoutLocalInput[]
    updateMany?: ReuniaoUpdateManyWithWhereWithoutLocalInput | ReuniaoUpdateManyWithWhereWithoutLocalInput[]
    deleteMany?: ReuniaoScalarWhereInput | ReuniaoScalarWhereInput[]
  }

  export type EnsaioUncheckedUpdateManyWithoutLocalNestedInput = {
    create?: XOR<EnsaioCreateWithoutLocalInput, EnsaioUncheckedCreateWithoutLocalInput> | EnsaioCreateWithoutLocalInput[] | EnsaioUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutLocalInput | EnsaioCreateOrConnectWithoutLocalInput[]
    upsert?: EnsaioUpsertWithWhereUniqueWithoutLocalInput | EnsaioUpsertWithWhereUniqueWithoutLocalInput[]
    createMany?: EnsaioCreateManyLocalInputEnvelope
    set?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    disconnect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    delete?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    update?: EnsaioUpdateWithWhereUniqueWithoutLocalInput | EnsaioUpdateWithWhereUniqueWithoutLocalInput[]
    updateMany?: EnsaioUpdateManyWithWhereWithoutLocalInput | EnsaioUpdateManyWithWhereWithoutLocalInput[]
    deleteMany?: EnsaioScalarWhereInput | EnsaioScalarWhereInput[]
  }

  export type EventoUncheckedUpdateManyWithoutLocalNestedInput = {
    create?: XOR<EventoCreateWithoutLocalInput, EventoUncheckedCreateWithoutLocalInput> | EventoCreateWithoutLocalInput[] | EventoUncheckedCreateWithoutLocalInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutLocalInput | EventoCreateOrConnectWithoutLocalInput[]
    upsert?: EventoUpsertWithWhereUniqueWithoutLocalInput | EventoUpsertWithWhereUniqueWithoutLocalInput[]
    createMany?: EventoCreateManyLocalInputEnvelope
    set?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    disconnect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    delete?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    update?: EventoUpdateWithWhereUniqueWithoutLocalInput | EventoUpdateWithWhereUniqueWithoutLocalInput[]
    updateMany?: EventoUpdateManyWithWhereWithoutLocalInput | EventoUpdateManyWithWhereWithoutLocalInput[]
    deleteMany?: EventoScalarWhereInput | EventoScalarWhereInput[]
  }

  export type LocalCreateNestedOneWithoutCultosInput = {
    create?: XOR<LocalCreateWithoutCultosInput, LocalUncheckedCreateWithoutCultosInput>
    connectOrCreate?: LocalCreateOrConnectWithoutCultosInput
    connect?: LocalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCultosComoPastorInput = {
    create?: XOR<UserCreateWithoutCultosComoPastorInput, UserUncheckedCreateWithoutCultosComoPastorInput>
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoPastorInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCultosComoObreiroInput = {
    create?: XOR<UserCreateWithoutCultosComoObreiroInput, UserUncheckedCreateWithoutCultosComoObreiroInput>
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoObreiroInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCultosComoAuxiliarInput = {
    create?: XOR<UserCreateWithoutCultosComoAuxiliarInput, UserUncheckedCreateWithoutCultosComoAuxiliarInput> | UserCreateWithoutCultosComoAuxiliarInput[] | UserUncheckedCreateWithoutCultosComoAuxiliarInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoAuxiliarInput | UserCreateOrConnectWithoutCultosComoAuxiliarInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCultosComoLiderCanticoInput = {
    create?: XOR<UserCreateWithoutCultosComoLiderCanticoInput, UserUncheckedCreateWithoutCultosComoLiderCanticoInput>
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoLiderCanticoInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutCultosComoVocalInput = {
    create?: XOR<UserCreateWithoutCultosComoVocalInput, UserUncheckedCreateWithoutCultosComoVocalInput> | UserCreateWithoutCultosComoVocalInput[] | UserUncheckedCreateWithoutCultosComoVocalInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoVocalInput | UserCreateOrConnectWithoutCultosComoVocalInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HinoCreateNestedManyWithoutCultosInput = {
    create?: XOR<HinoCreateWithoutCultosInput, HinoUncheckedCreateWithoutCultosInput> | HinoCreateWithoutCultosInput[] | HinoUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: HinoCreateOrConnectWithoutCultosInput | HinoCreateOrConnectWithoutCultosInput[]
    connect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
  }

  export type MensagemCreateNestedManyWithoutCultosInput = {
    create?: XOR<MensagemCreateWithoutCultosInput, MensagemUncheckedCreateWithoutCultosInput> | MensagemCreateWithoutCultosInput[] | MensagemUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: MensagemCreateOrConnectWithoutCultosInput | MensagemCreateOrConnectWithoutCultosInput[]
    connect?: MensagemWhereUniqueInput | MensagemWhereUniqueInput[]
  }

  export type LeituraBiblicaCreateNestedManyWithoutCultosInput = {
    create?: XOR<LeituraBiblicaCreateWithoutCultosInput, LeituraBiblicaUncheckedCreateWithoutCultosInput> | LeituraBiblicaCreateWithoutCultosInput[] | LeituraBiblicaUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: LeituraBiblicaCreateOrConnectWithoutCultosInput | LeituraBiblicaCreateOrConnectWithoutCultosInput[]
    connect?: LeituraBiblicaWhereUniqueInput | LeituraBiblicaWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCultosComoAuxiliarInput = {
    create?: XOR<UserCreateWithoutCultosComoAuxiliarInput, UserUncheckedCreateWithoutCultosComoAuxiliarInput> | UserCreateWithoutCultosComoAuxiliarInput[] | UserUncheckedCreateWithoutCultosComoAuxiliarInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoAuxiliarInput | UserCreateOrConnectWithoutCultosComoAuxiliarInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCultosComoVocalInput = {
    create?: XOR<UserCreateWithoutCultosComoVocalInput, UserUncheckedCreateWithoutCultosComoVocalInput> | UserCreateWithoutCultosComoVocalInput[] | UserUncheckedCreateWithoutCultosComoVocalInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoVocalInput | UserCreateOrConnectWithoutCultosComoVocalInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HinoUncheckedCreateNestedManyWithoutCultosInput = {
    create?: XOR<HinoCreateWithoutCultosInput, HinoUncheckedCreateWithoutCultosInput> | HinoCreateWithoutCultosInput[] | HinoUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: HinoCreateOrConnectWithoutCultosInput | HinoCreateOrConnectWithoutCultosInput[]
    connect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
  }

  export type MensagemUncheckedCreateNestedManyWithoutCultosInput = {
    create?: XOR<MensagemCreateWithoutCultosInput, MensagemUncheckedCreateWithoutCultosInput> | MensagemCreateWithoutCultosInput[] | MensagemUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: MensagemCreateOrConnectWithoutCultosInput | MensagemCreateOrConnectWithoutCultosInput[]
    connect?: MensagemWhereUniqueInput | MensagemWhereUniqueInput[]
  }

  export type LeituraBiblicaUncheckedCreateNestedManyWithoutCultosInput = {
    create?: XOR<LeituraBiblicaCreateWithoutCultosInput, LeituraBiblicaUncheckedCreateWithoutCultosInput> | LeituraBiblicaCreateWithoutCultosInput[] | LeituraBiblicaUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: LeituraBiblicaCreateOrConnectWithoutCultosInput | LeituraBiblicaCreateOrConnectWithoutCultosInput[]
    connect?: LeituraBiblicaWhereUniqueInput | LeituraBiblicaWhereUniqueInput[]
  }

  export type LocalUpdateOneRequiredWithoutCultosNestedInput = {
    create?: XOR<LocalCreateWithoutCultosInput, LocalUncheckedCreateWithoutCultosInput>
    connectOrCreate?: LocalCreateOrConnectWithoutCultosInput
    upsert?: LocalUpsertWithoutCultosInput
    connect?: LocalWhereUniqueInput
    update?: XOR<XOR<LocalUpdateToOneWithWhereWithoutCultosInput, LocalUpdateWithoutCultosInput>, LocalUncheckedUpdateWithoutCultosInput>
  }

  export type UserUpdateOneRequiredWithoutCultosComoPastorNestedInput = {
    create?: XOR<UserCreateWithoutCultosComoPastorInput, UserUncheckedCreateWithoutCultosComoPastorInput>
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoPastorInput
    upsert?: UserUpsertWithoutCultosComoPastorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCultosComoPastorInput, UserUpdateWithoutCultosComoPastorInput>, UserUncheckedUpdateWithoutCultosComoPastorInput>
  }

  export type UserUpdateOneRequiredWithoutCultosComoObreiroNestedInput = {
    create?: XOR<UserCreateWithoutCultosComoObreiroInput, UserUncheckedCreateWithoutCultosComoObreiroInput>
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoObreiroInput
    upsert?: UserUpsertWithoutCultosComoObreiroInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCultosComoObreiroInput, UserUpdateWithoutCultosComoObreiroInput>, UserUncheckedUpdateWithoutCultosComoObreiroInput>
  }

  export type UserUpdateManyWithoutCultosComoAuxiliarNestedInput = {
    create?: XOR<UserCreateWithoutCultosComoAuxiliarInput, UserUncheckedCreateWithoutCultosComoAuxiliarInput> | UserCreateWithoutCultosComoAuxiliarInput[] | UserUncheckedCreateWithoutCultosComoAuxiliarInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoAuxiliarInput | UserCreateOrConnectWithoutCultosComoAuxiliarInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCultosComoAuxiliarInput | UserUpsertWithWhereUniqueWithoutCultosComoAuxiliarInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCultosComoAuxiliarInput | UserUpdateWithWhereUniqueWithoutCultosComoAuxiliarInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCultosComoAuxiliarInput | UserUpdateManyWithWhereWithoutCultosComoAuxiliarInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCultosComoLiderCanticoNestedInput = {
    create?: XOR<UserCreateWithoutCultosComoLiderCanticoInput, UserUncheckedCreateWithoutCultosComoLiderCanticoInput>
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoLiderCanticoInput
    upsert?: UserUpsertWithoutCultosComoLiderCanticoInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCultosComoLiderCanticoInput, UserUpdateWithoutCultosComoLiderCanticoInput>, UserUncheckedUpdateWithoutCultosComoLiderCanticoInput>
  }

  export type UserUpdateManyWithoutCultosComoVocalNestedInput = {
    create?: XOR<UserCreateWithoutCultosComoVocalInput, UserUncheckedCreateWithoutCultosComoVocalInput> | UserCreateWithoutCultosComoVocalInput[] | UserUncheckedCreateWithoutCultosComoVocalInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoVocalInput | UserCreateOrConnectWithoutCultosComoVocalInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCultosComoVocalInput | UserUpsertWithWhereUniqueWithoutCultosComoVocalInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCultosComoVocalInput | UserUpdateWithWhereUniqueWithoutCultosComoVocalInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCultosComoVocalInput | UserUpdateManyWithWhereWithoutCultosComoVocalInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HinoUpdateManyWithoutCultosNestedInput = {
    create?: XOR<HinoCreateWithoutCultosInput, HinoUncheckedCreateWithoutCultosInput> | HinoCreateWithoutCultosInput[] | HinoUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: HinoCreateOrConnectWithoutCultosInput | HinoCreateOrConnectWithoutCultosInput[]
    upsert?: HinoUpsertWithWhereUniqueWithoutCultosInput | HinoUpsertWithWhereUniqueWithoutCultosInput[]
    set?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    disconnect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    delete?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    connect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    update?: HinoUpdateWithWhereUniqueWithoutCultosInput | HinoUpdateWithWhereUniqueWithoutCultosInput[]
    updateMany?: HinoUpdateManyWithWhereWithoutCultosInput | HinoUpdateManyWithWhereWithoutCultosInput[]
    deleteMany?: HinoScalarWhereInput | HinoScalarWhereInput[]
  }

  export type MensagemUpdateManyWithoutCultosNestedInput = {
    create?: XOR<MensagemCreateWithoutCultosInput, MensagemUncheckedCreateWithoutCultosInput> | MensagemCreateWithoutCultosInput[] | MensagemUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: MensagemCreateOrConnectWithoutCultosInput | MensagemCreateOrConnectWithoutCultosInput[]
    upsert?: MensagemUpsertWithWhereUniqueWithoutCultosInput | MensagemUpsertWithWhereUniqueWithoutCultosInput[]
    set?: MensagemWhereUniqueInput | MensagemWhereUniqueInput[]
    disconnect?: MensagemWhereUniqueInput | MensagemWhereUniqueInput[]
    delete?: MensagemWhereUniqueInput | MensagemWhereUniqueInput[]
    connect?: MensagemWhereUniqueInput | MensagemWhereUniqueInput[]
    update?: MensagemUpdateWithWhereUniqueWithoutCultosInput | MensagemUpdateWithWhereUniqueWithoutCultosInput[]
    updateMany?: MensagemUpdateManyWithWhereWithoutCultosInput | MensagemUpdateManyWithWhereWithoutCultosInput[]
    deleteMany?: MensagemScalarWhereInput | MensagemScalarWhereInput[]
  }

  export type LeituraBiblicaUpdateManyWithoutCultosNestedInput = {
    create?: XOR<LeituraBiblicaCreateWithoutCultosInput, LeituraBiblicaUncheckedCreateWithoutCultosInput> | LeituraBiblicaCreateWithoutCultosInput[] | LeituraBiblicaUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: LeituraBiblicaCreateOrConnectWithoutCultosInput | LeituraBiblicaCreateOrConnectWithoutCultosInput[]
    upsert?: LeituraBiblicaUpsertWithWhereUniqueWithoutCultosInput | LeituraBiblicaUpsertWithWhereUniqueWithoutCultosInput[]
    set?: LeituraBiblicaWhereUniqueInput | LeituraBiblicaWhereUniqueInput[]
    disconnect?: LeituraBiblicaWhereUniqueInput | LeituraBiblicaWhereUniqueInput[]
    delete?: LeituraBiblicaWhereUniqueInput | LeituraBiblicaWhereUniqueInput[]
    connect?: LeituraBiblicaWhereUniqueInput | LeituraBiblicaWhereUniqueInput[]
    update?: LeituraBiblicaUpdateWithWhereUniqueWithoutCultosInput | LeituraBiblicaUpdateWithWhereUniqueWithoutCultosInput[]
    updateMany?: LeituraBiblicaUpdateManyWithWhereWithoutCultosInput | LeituraBiblicaUpdateManyWithWhereWithoutCultosInput[]
    deleteMany?: LeituraBiblicaScalarWhereInput | LeituraBiblicaScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCultosComoAuxiliarNestedInput = {
    create?: XOR<UserCreateWithoutCultosComoAuxiliarInput, UserUncheckedCreateWithoutCultosComoAuxiliarInput> | UserCreateWithoutCultosComoAuxiliarInput[] | UserUncheckedCreateWithoutCultosComoAuxiliarInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoAuxiliarInput | UserCreateOrConnectWithoutCultosComoAuxiliarInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCultosComoAuxiliarInput | UserUpsertWithWhereUniqueWithoutCultosComoAuxiliarInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCultosComoAuxiliarInput | UserUpdateWithWhereUniqueWithoutCultosComoAuxiliarInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCultosComoAuxiliarInput | UserUpdateManyWithWhereWithoutCultosComoAuxiliarInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCultosComoVocalNestedInput = {
    create?: XOR<UserCreateWithoutCultosComoVocalInput, UserUncheckedCreateWithoutCultosComoVocalInput> | UserCreateWithoutCultosComoVocalInput[] | UserUncheckedCreateWithoutCultosComoVocalInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCultosComoVocalInput | UserCreateOrConnectWithoutCultosComoVocalInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCultosComoVocalInput | UserUpsertWithWhereUniqueWithoutCultosComoVocalInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCultosComoVocalInput | UserUpdateWithWhereUniqueWithoutCultosComoVocalInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCultosComoVocalInput | UserUpdateManyWithWhereWithoutCultosComoVocalInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HinoUncheckedUpdateManyWithoutCultosNestedInput = {
    create?: XOR<HinoCreateWithoutCultosInput, HinoUncheckedCreateWithoutCultosInput> | HinoCreateWithoutCultosInput[] | HinoUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: HinoCreateOrConnectWithoutCultosInput | HinoCreateOrConnectWithoutCultosInput[]
    upsert?: HinoUpsertWithWhereUniqueWithoutCultosInput | HinoUpsertWithWhereUniqueWithoutCultosInput[]
    set?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    disconnect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    delete?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    connect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    update?: HinoUpdateWithWhereUniqueWithoutCultosInput | HinoUpdateWithWhereUniqueWithoutCultosInput[]
    updateMany?: HinoUpdateManyWithWhereWithoutCultosInput | HinoUpdateManyWithWhereWithoutCultosInput[]
    deleteMany?: HinoScalarWhereInput | HinoScalarWhereInput[]
  }

  export type MensagemUncheckedUpdateManyWithoutCultosNestedInput = {
    create?: XOR<MensagemCreateWithoutCultosInput, MensagemUncheckedCreateWithoutCultosInput> | MensagemCreateWithoutCultosInput[] | MensagemUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: MensagemCreateOrConnectWithoutCultosInput | MensagemCreateOrConnectWithoutCultosInput[]
    upsert?: MensagemUpsertWithWhereUniqueWithoutCultosInput | MensagemUpsertWithWhereUniqueWithoutCultosInput[]
    set?: MensagemWhereUniqueInput | MensagemWhereUniqueInput[]
    disconnect?: MensagemWhereUniqueInput | MensagemWhereUniqueInput[]
    delete?: MensagemWhereUniqueInput | MensagemWhereUniqueInput[]
    connect?: MensagemWhereUniqueInput | MensagemWhereUniqueInput[]
    update?: MensagemUpdateWithWhereUniqueWithoutCultosInput | MensagemUpdateWithWhereUniqueWithoutCultosInput[]
    updateMany?: MensagemUpdateManyWithWhereWithoutCultosInput | MensagemUpdateManyWithWhereWithoutCultosInput[]
    deleteMany?: MensagemScalarWhereInput | MensagemScalarWhereInput[]
  }

  export type LeituraBiblicaUncheckedUpdateManyWithoutCultosNestedInput = {
    create?: XOR<LeituraBiblicaCreateWithoutCultosInput, LeituraBiblicaUncheckedCreateWithoutCultosInput> | LeituraBiblicaCreateWithoutCultosInput[] | LeituraBiblicaUncheckedCreateWithoutCultosInput[]
    connectOrCreate?: LeituraBiblicaCreateOrConnectWithoutCultosInput | LeituraBiblicaCreateOrConnectWithoutCultosInput[]
    upsert?: LeituraBiblicaUpsertWithWhereUniqueWithoutCultosInput | LeituraBiblicaUpsertWithWhereUniqueWithoutCultosInput[]
    set?: LeituraBiblicaWhereUniqueInput | LeituraBiblicaWhereUniqueInput[]
    disconnect?: LeituraBiblicaWhereUniqueInput | LeituraBiblicaWhereUniqueInput[]
    delete?: LeituraBiblicaWhereUniqueInput | LeituraBiblicaWhereUniqueInput[]
    connect?: LeituraBiblicaWhereUniqueInput | LeituraBiblicaWhereUniqueInput[]
    update?: LeituraBiblicaUpdateWithWhereUniqueWithoutCultosInput | LeituraBiblicaUpdateWithWhereUniqueWithoutCultosInput[]
    updateMany?: LeituraBiblicaUpdateManyWithWhereWithoutCultosInput | LeituraBiblicaUpdateManyWithWhereWithoutCultosInput[]
    deleteMany?: LeituraBiblicaScalarWhereInput | LeituraBiblicaScalarWhereInput[]
  }

  export type LocalCreateNestedOneWithoutReunioesInput = {
    create?: XOR<LocalCreateWithoutReunioesInput, LocalUncheckedCreateWithoutReunioesInput>
    connectOrCreate?: LocalCreateOrConnectWithoutReunioesInput
    connect?: LocalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReunioesResponsavelInput = {
    create?: XOR<UserCreateWithoutReunioesResponsavelInput, UserUncheckedCreateWithoutReunioesResponsavelInput>
    connectOrCreate?: UserCreateOrConnectWithoutReunioesResponsavelInput
    connect?: UserWhereUniqueInput
  }

  export type LocalUpdateOneRequiredWithoutReunioesNestedInput = {
    create?: XOR<LocalCreateWithoutReunioesInput, LocalUncheckedCreateWithoutReunioesInput>
    connectOrCreate?: LocalCreateOrConnectWithoutReunioesInput
    upsert?: LocalUpsertWithoutReunioesInput
    connect?: LocalWhereUniqueInput
    update?: XOR<XOR<LocalUpdateToOneWithWhereWithoutReunioesInput, LocalUpdateWithoutReunioesInput>, LocalUncheckedUpdateWithoutReunioesInput>
  }

  export type UserUpdateOneRequiredWithoutReunioesResponsavelNestedInput = {
    create?: XOR<UserCreateWithoutReunioesResponsavelInput, UserUncheckedCreateWithoutReunioesResponsavelInput>
    connectOrCreate?: UserCreateOrConnectWithoutReunioesResponsavelInput
    upsert?: UserUpsertWithoutReunioesResponsavelInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReunioesResponsavelInput, UserUpdateWithoutReunioesResponsavelInput>, UserUncheckedUpdateWithoutReunioesResponsavelInput>
  }

  export type LocalCreateNestedOneWithoutEnsaiosInput = {
    create?: XOR<LocalCreateWithoutEnsaiosInput, LocalUncheckedCreateWithoutEnsaiosInput>
    connectOrCreate?: LocalCreateOrConnectWithoutEnsaiosInput
    connect?: LocalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEnsaiosResponsavelInput = {
    create?: XOR<UserCreateWithoutEnsaiosResponsavelInput, UserUncheckedCreateWithoutEnsaiosResponsavelInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnsaiosResponsavelInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutParticipaEnsaiosInput = {
    create?: XOR<UserCreateWithoutParticipaEnsaiosInput, UserUncheckedCreateWithoutParticipaEnsaiosInput> | UserCreateWithoutParticipaEnsaiosInput[] | UserUncheckedCreateWithoutParticipaEnsaiosInput[]
    connectOrCreate?: UserCreateOrConnectWithoutParticipaEnsaiosInput | UserCreateOrConnectWithoutParticipaEnsaiosInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HinoCreateNestedManyWithoutEnsaiosInput = {
    create?: XOR<HinoCreateWithoutEnsaiosInput, HinoUncheckedCreateWithoutEnsaiosInput> | HinoCreateWithoutEnsaiosInput[] | HinoUncheckedCreateWithoutEnsaiosInput[]
    connectOrCreate?: HinoCreateOrConnectWithoutEnsaiosInput | HinoCreateOrConnectWithoutEnsaiosInput[]
    connect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutParticipaEnsaiosInput = {
    create?: XOR<UserCreateWithoutParticipaEnsaiosInput, UserUncheckedCreateWithoutParticipaEnsaiosInput> | UserCreateWithoutParticipaEnsaiosInput[] | UserUncheckedCreateWithoutParticipaEnsaiosInput[]
    connectOrCreate?: UserCreateOrConnectWithoutParticipaEnsaiosInput | UserCreateOrConnectWithoutParticipaEnsaiosInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type HinoUncheckedCreateNestedManyWithoutEnsaiosInput = {
    create?: XOR<HinoCreateWithoutEnsaiosInput, HinoUncheckedCreateWithoutEnsaiosInput> | HinoCreateWithoutEnsaiosInput[] | HinoUncheckedCreateWithoutEnsaiosInput[]
    connectOrCreate?: HinoCreateOrConnectWithoutEnsaiosInput | HinoCreateOrConnectWithoutEnsaiosInput[]
    connect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
  }

  export type LocalUpdateOneRequiredWithoutEnsaiosNestedInput = {
    create?: XOR<LocalCreateWithoutEnsaiosInput, LocalUncheckedCreateWithoutEnsaiosInput>
    connectOrCreate?: LocalCreateOrConnectWithoutEnsaiosInput
    upsert?: LocalUpsertWithoutEnsaiosInput
    connect?: LocalWhereUniqueInput
    update?: XOR<XOR<LocalUpdateToOneWithWhereWithoutEnsaiosInput, LocalUpdateWithoutEnsaiosInput>, LocalUncheckedUpdateWithoutEnsaiosInput>
  }

  export type UserUpdateOneRequiredWithoutEnsaiosResponsavelNestedInput = {
    create?: XOR<UserCreateWithoutEnsaiosResponsavelInput, UserUncheckedCreateWithoutEnsaiosResponsavelInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnsaiosResponsavelInput
    upsert?: UserUpsertWithoutEnsaiosResponsavelInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnsaiosResponsavelInput, UserUpdateWithoutEnsaiosResponsavelInput>, UserUncheckedUpdateWithoutEnsaiosResponsavelInput>
  }

  export type UserUpdateManyWithoutParticipaEnsaiosNestedInput = {
    create?: XOR<UserCreateWithoutParticipaEnsaiosInput, UserUncheckedCreateWithoutParticipaEnsaiosInput> | UserCreateWithoutParticipaEnsaiosInput[] | UserUncheckedCreateWithoutParticipaEnsaiosInput[]
    connectOrCreate?: UserCreateOrConnectWithoutParticipaEnsaiosInput | UserCreateOrConnectWithoutParticipaEnsaiosInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutParticipaEnsaiosInput | UserUpsertWithWhereUniqueWithoutParticipaEnsaiosInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutParticipaEnsaiosInput | UserUpdateWithWhereUniqueWithoutParticipaEnsaiosInput[]
    updateMany?: UserUpdateManyWithWhereWithoutParticipaEnsaiosInput | UserUpdateManyWithWhereWithoutParticipaEnsaiosInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HinoUpdateManyWithoutEnsaiosNestedInput = {
    create?: XOR<HinoCreateWithoutEnsaiosInput, HinoUncheckedCreateWithoutEnsaiosInput> | HinoCreateWithoutEnsaiosInput[] | HinoUncheckedCreateWithoutEnsaiosInput[]
    connectOrCreate?: HinoCreateOrConnectWithoutEnsaiosInput | HinoCreateOrConnectWithoutEnsaiosInput[]
    upsert?: HinoUpsertWithWhereUniqueWithoutEnsaiosInput | HinoUpsertWithWhereUniqueWithoutEnsaiosInput[]
    set?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    disconnect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    delete?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    connect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    update?: HinoUpdateWithWhereUniqueWithoutEnsaiosInput | HinoUpdateWithWhereUniqueWithoutEnsaiosInput[]
    updateMany?: HinoUpdateManyWithWhereWithoutEnsaiosInput | HinoUpdateManyWithWhereWithoutEnsaiosInput[]
    deleteMany?: HinoScalarWhereInput | HinoScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutParticipaEnsaiosNestedInput = {
    create?: XOR<UserCreateWithoutParticipaEnsaiosInput, UserUncheckedCreateWithoutParticipaEnsaiosInput> | UserCreateWithoutParticipaEnsaiosInput[] | UserUncheckedCreateWithoutParticipaEnsaiosInput[]
    connectOrCreate?: UserCreateOrConnectWithoutParticipaEnsaiosInput | UserCreateOrConnectWithoutParticipaEnsaiosInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutParticipaEnsaiosInput | UserUpsertWithWhereUniqueWithoutParticipaEnsaiosInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutParticipaEnsaiosInput | UserUpdateWithWhereUniqueWithoutParticipaEnsaiosInput[]
    updateMany?: UserUpdateManyWithWhereWithoutParticipaEnsaiosInput | UserUpdateManyWithWhereWithoutParticipaEnsaiosInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type HinoUncheckedUpdateManyWithoutEnsaiosNestedInput = {
    create?: XOR<HinoCreateWithoutEnsaiosInput, HinoUncheckedCreateWithoutEnsaiosInput> | HinoCreateWithoutEnsaiosInput[] | HinoUncheckedCreateWithoutEnsaiosInput[]
    connectOrCreate?: HinoCreateOrConnectWithoutEnsaiosInput | HinoCreateOrConnectWithoutEnsaiosInput[]
    upsert?: HinoUpsertWithWhereUniqueWithoutEnsaiosInput | HinoUpsertWithWhereUniqueWithoutEnsaiosInput[]
    set?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    disconnect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    delete?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    connect?: HinoWhereUniqueInput | HinoWhereUniqueInput[]
    update?: HinoUpdateWithWhereUniqueWithoutEnsaiosInput | HinoUpdateWithWhereUniqueWithoutEnsaiosInput[]
    updateMany?: HinoUpdateManyWithWhereWithoutEnsaiosInput | HinoUpdateManyWithWhereWithoutEnsaiosInput[]
    deleteMany?: HinoScalarWhereInput | HinoScalarWhereInput[]
  }

  export type LocalCreateNestedOneWithoutEventosInput = {
    create?: XOR<LocalCreateWithoutEventosInput, LocalUncheckedCreateWithoutEventosInput>
    connectOrCreate?: LocalCreateOrConnectWithoutEventosInput
    connect?: LocalWhereUniqueInput
  }

  export type LocalUpdateOneRequiredWithoutEventosNestedInput = {
    create?: XOR<LocalCreateWithoutEventosInput, LocalUncheckedCreateWithoutEventosInput>
    connectOrCreate?: LocalCreateOrConnectWithoutEventosInput
    upsert?: LocalUpsertWithoutEventosInput
    connect?: LocalWhereUniqueInput
    update?: XOR<XOR<LocalUpdateToOneWithWhereWithoutEventosInput, LocalUpdateWithoutEventosInput>, LocalUncheckedUpdateWithoutEventosInput>
  }

  export type CultoCreateNestedManyWithoutMensagensInput = {
    create?: XOR<CultoCreateWithoutMensagensInput, CultoUncheckedCreateWithoutMensagensInput> | CultoCreateWithoutMensagensInput[] | CultoUncheckedCreateWithoutMensagensInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutMensagensInput | CultoCreateOrConnectWithoutMensagensInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoUncheckedCreateNestedManyWithoutMensagensInput = {
    create?: XOR<CultoCreateWithoutMensagensInput, CultoUncheckedCreateWithoutMensagensInput> | CultoCreateWithoutMensagensInput[] | CultoUncheckedCreateWithoutMensagensInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutMensagensInput | CultoCreateOrConnectWithoutMensagensInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoUpdateManyWithoutMensagensNestedInput = {
    create?: XOR<CultoCreateWithoutMensagensInput, CultoUncheckedCreateWithoutMensagensInput> | CultoCreateWithoutMensagensInput[] | CultoUncheckedCreateWithoutMensagensInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutMensagensInput | CultoCreateOrConnectWithoutMensagensInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutMensagensInput | CultoUpsertWithWhereUniqueWithoutMensagensInput[]
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutMensagensInput | CultoUpdateWithWhereUniqueWithoutMensagensInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutMensagensInput | CultoUpdateManyWithWhereWithoutMensagensInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoUncheckedUpdateManyWithoutMensagensNestedInput = {
    create?: XOR<CultoCreateWithoutMensagensInput, CultoUncheckedCreateWithoutMensagensInput> | CultoCreateWithoutMensagensInput[] | CultoUncheckedCreateWithoutMensagensInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutMensagensInput | CultoCreateOrConnectWithoutMensagensInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutMensagensInput | CultoUpsertWithWhereUniqueWithoutMensagensInput[]
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutMensagensInput | CultoUpdateWithWhereUniqueWithoutMensagensInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutMensagensInput | CultoUpdateManyWithWhereWithoutMensagensInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoCreateNestedManyWithoutHinosInput = {
    create?: XOR<CultoCreateWithoutHinosInput, CultoUncheckedCreateWithoutHinosInput> | CultoCreateWithoutHinosInput[] | CultoUncheckedCreateWithoutHinosInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutHinosInput | CultoCreateOrConnectWithoutHinosInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type EnsaioCreateNestedManyWithoutHinosInput = {
    create?: XOR<EnsaioCreateWithoutHinosInput, EnsaioUncheckedCreateWithoutHinosInput> | EnsaioCreateWithoutHinosInput[] | EnsaioUncheckedCreateWithoutHinosInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutHinosInput | EnsaioCreateOrConnectWithoutHinosInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
  }

  export type CultoUncheckedCreateNestedManyWithoutHinosInput = {
    create?: XOR<CultoCreateWithoutHinosInput, CultoUncheckedCreateWithoutHinosInput> | CultoCreateWithoutHinosInput[] | CultoUncheckedCreateWithoutHinosInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutHinosInput | CultoCreateOrConnectWithoutHinosInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type EnsaioUncheckedCreateNestedManyWithoutHinosInput = {
    create?: XOR<EnsaioCreateWithoutHinosInput, EnsaioUncheckedCreateWithoutHinosInput> | EnsaioCreateWithoutHinosInput[] | EnsaioUncheckedCreateWithoutHinosInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutHinosInput | EnsaioCreateOrConnectWithoutHinosInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
  }

  export type CultoUpdateManyWithoutHinosNestedInput = {
    create?: XOR<CultoCreateWithoutHinosInput, CultoUncheckedCreateWithoutHinosInput> | CultoCreateWithoutHinosInput[] | CultoUncheckedCreateWithoutHinosInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutHinosInput | CultoCreateOrConnectWithoutHinosInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutHinosInput | CultoUpsertWithWhereUniqueWithoutHinosInput[]
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutHinosInput | CultoUpdateWithWhereUniqueWithoutHinosInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutHinosInput | CultoUpdateManyWithWhereWithoutHinosInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type EnsaioUpdateManyWithoutHinosNestedInput = {
    create?: XOR<EnsaioCreateWithoutHinosInput, EnsaioUncheckedCreateWithoutHinosInput> | EnsaioCreateWithoutHinosInput[] | EnsaioUncheckedCreateWithoutHinosInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutHinosInput | EnsaioCreateOrConnectWithoutHinosInput[]
    upsert?: EnsaioUpsertWithWhereUniqueWithoutHinosInput | EnsaioUpsertWithWhereUniqueWithoutHinosInput[]
    set?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    disconnect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    delete?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    update?: EnsaioUpdateWithWhereUniqueWithoutHinosInput | EnsaioUpdateWithWhereUniqueWithoutHinosInput[]
    updateMany?: EnsaioUpdateManyWithWhereWithoutHinosInput | EnsaioUpdateManyWithWhereWithoutHinosInput[]
    deleteMany?: EnsaioScalarWhereInput | EnsaioScalarWhereInput[]
  }

  export type CultoUncheckedUpdateManyWithoutHinosNestedInput = {
    create?: XOR<CultoCreateWithoutHinosInput, CultoUncheckedCreateWithoutHinosInput> | CultoCreateWithoutHinosInput[] | CultoUncheckedCreateWithoutHinosInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutHinosInput | CultoCreateOrConnectWithoutHinosInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutHinosInput | CultoUpsertWithWhereUniqueWithoutHinosInput[]
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutHinosInput | CultoUpdateWithWhereUniqueWithoutHinosInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutHinosInput | CultoUpdateManyWithWhereWithoutHinosInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type EnsaioUncheckedUpdateManyWithoutHinosNestedInput = {
    create?: XOR<EnsaioCreateWithoutHinosInput, EnsaioUncheckedCreateWithoutHinosInput> | EnsaioCreateWithoutHinosInput[] | EnsaioUncheckedCreateWithoutHinosInput[]
    connectOrCreate?: EnsaioCreateOrConnectWithoutHinosInput | EnsaioCreateOrConnectWithoutHinosInput[]
    upsert?: EnsaioUpsertWithWhereUniqueWithoutHinosInput | EnsaioUpsertWithWhereUniqueWithoutHinosInput[]
    set?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    disconnect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    delete?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    connect?: EnsaioWhereUniqueInput | EnsaioWhereUniqueInput[]
    update?: EnsaioUpdateWithWhereUniqueWithoutHinosInput | EnsaioUpdateWithWhereUniqueWithoutHinosInput[]
    updateMany?: EnsaioUpdateManyWithWhereWithoutHinosInput | EnsaioUpdateManyWithWhereWithoutHinosInput[]
    deleteMany?: EnsaioScalarWhereInput | EnsaioScalarWhereInput[]
  }

  export type CultoCreateNestedManyWithoutLeiturasInput = {
    create?: XOR<CultoCreateWithoutLeiturasInput, CultoUncheckedCreateWithoutLeiturasInput> | CultoCreateWithoutLeiturasInput[] | CultoUncheckedCreateWithoutLeiturasInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLeiturasInput | CultoCreateOrConnectWithoutLeiturasInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoUncheckedCreateNestedManyWithoutLeiturasInput = {
    create?: XOR<CultoCreateWithoutLeiturasInput, CultoUncheckedCreateWithoutLeiturasInput> | CultoCreateWithoutLeiturasInput[] | CultoUncheckedCreateWithoutLeiturasInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLeiturasInput | CultoCreateOrConnectWithoutLeiturasInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
  }

  export type CultoUpdateManyWithoutLeiturasNestedInput = {
    create?: XOR<CultoCreateWithoutLeiturasInput, CultoUncheckedCreateWithoutLeiturasInput> | CultoCreateWithoutLeiturasInput[] | CultoUncheckedCreateWithoutLeiturasInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLeiturasInput | CultoCreateOrConnectWithoutLeiturasInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutLeiturasInput | CultoUpsertWithWhereUniqueWithoutLeiturasInput[]
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutLeiturasInput | CultoUpdateWithWhereUniqueWithoutLeiturasInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutLeiturasInput | CultoUpdateManyWithWhereWithoutLeiturasInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type CultoUncheckedUpdateManyWithoutLeiturasNestedInput = {
    create?: XOR<CultoCreateWithoutLeiturasInput, CultoUncheckedCreateWithoutLeiturasInput> | CultoCreateWithoutLeiturasInput[] | CultoUncheckedCreateWithoutLeiturasInput[]
    connectOrCreate?: CultoCreateOrConnectWithoutLeiturasInput | CultoCreateOrConnectWithoutLeiturasInput[]
    upsert?: CultoUpsertWithWhereUniqueWithoutLeiturasInput | CultoUpsertWithWhereUniqueWithoutLeiturasInput[]
    set?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    disconnect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    delete?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    connect?: CultoWhereUniqueInput | CultoWhereUniqueInput[]
    update?: CultoUpdateWithWhereUniqueWithoutLeiturasInput | CultoUpdateWithWhereUniqueWithoutLeiturasInput[]
    updateMany?: CultoUpdateManyWithWhereWithoutLeiturasInput | CultoUpdateManyWithWhereWithoutLeiturasInput[]
    deleteMany?: CultoScalarWhereInput | CultoScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CargoCreateWithoutUsersInput = {
    nome: string
  }

  export type CargoUncheckedCreateWithoutUsersInput = {
    id?: number
    nome: string
  }

  export type CargoCreateOrConnectWithoutUsersInput = {
    where: CargoWhereUniqueInput
    create: XOR<CargoCreateWithoutUsersInput, CargoUncheckedCreateWithoutUsersInput>
  }

  export type CultoCreateWithoutPastorInput = {
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutCultosInput
    obreiro: UserCreateNestedOneWithoutCultosComoObreiroInput
    auxiliares?: UserCreateNestedManyWithoutCultosComoAuxiliarInput
    liderCantico: UserCreateNestedOneWithoutCultosComoLiderCanticoInput
    vocal?: UserCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoCreateNestedManyWithoutCultosInput
    mensagens?: MensagemCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaCreateNestedManyWithoutCultosInput
  }

  export type CultoUncheckedCreateWithoutPastorInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auxiliares?: UserUncheckedCreateNestedManyWithoutCultosComoAuxiliarInput
    vocal?: UserUncheckedCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoUncheckedCreateNestedManyWithoutCultosInput
    mensagens?: MensagemUncheckedCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaUncheckedCreateNestedManyWithoutCultosInput
  }

  export type CultoCreateOrConnectWithoutPastorInput = {
    where: CultoWhereUniqueInput
    create: XOR<CultoCreateWithoutPastorInput, CultoUncheckedCreateWithoutPastorInput>
  }

  export type CultoCreateManyPastorInputEnvelope = {
    data: CultoCreateManyPastorInput | CultoCreateManyPastorInput[]
    skipDuplicates?: boolean
  }

  export type CultoCreateWithoutObreiroInput = {
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutCultosInput
    pastor: UserCreateNestedOneWithoutCultosComoPastorInput
    auxiliares?: UserCreateNestedManyWithoutCultosComoAuxiliarInput
    liderCantico: UserCreateNestedOneWithoutCultosComoLiderCanticoInput
    vocal?: UserCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoCreateNestedManyWithoutCultosInput
    mensagens?: MensagemCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaCreateNestedManyWithoutCultosInput
  }

  export type CultoUncheckedCreateWithoutObreiroInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auxiliares?: UserUncheckedCreateNestedManyWithoutCultosComoAuxiliarInput
    vocal?: UserUncheckedCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoUncheckedCreateNestedManyWithoutCultosInput
    mensagens?: MensagemUncheckedCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaUncheckedCreateNestedManyWithoutCultosInput
  }

  export type CultoCreateOrConnectWithoutObreiroInput = {
    where: CultoWhereUniqueInput
    create: XOR<CultoCreateWithoutObreiroInput, CultoUncheckedCreateWithoutObreiroInput>
  }

  export type CultoCreateManyObreiroInputEnvelope = {
    data: CultoCreateManyObreiroInput | CultoCreateManyObreiroInput[]
    skipDuplicates?: boolean
  }

  export type CultoCreateWithoutAuxiliaresInput = {
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutCultosInput
    pastor: UserCreateNestedOneWithoutCultosComoPastorInput
    obreiro: UserCreateNestedOneWithoutCultosComoObreiroInput
    liderCantico: UserCreateNestedOneWithoutCultosComoLiderCanticoInput
    vocal?: UserCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoCreateNestedManyWithoutCultosInput
    mensagens?: MensagemCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaCreateNestedManyWithoutCultosInput
  }

  export type CultoUncheckedCreateWithoutAuxiliaresInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vocal?: UserUncheckedCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoUncheckedCreateNestedManyWithoutCultosInput
    mensagens?: MensagemUncheckedCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaUncheckedCreateNestedManyWithoutCultosInput
  }

  export type CultoCreateOrConnectWithoutAuxiliaresInput = {
    where: CultoWhereUniqueInput
    create: XOR<CultoCreateWithoutAuxiliaresInput, CultoUncheckedCreateWithoutAuxiliaresInput>
  }

  export type CultoCreateWithoutLiderCanticoInput = {
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutCultosInput
    pastor: UserCreateNestedOneWithoutCultosComoPastorInput
    obreiro: UserCreateNestedOneWithoutCultosComoObreiroInput
    auxiliares?: UserCreateNestedManyWithoutCultosComoAuxiliarInput
    vocal?: UserCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoCreateNestedManyWithoutCultosInput
    mensagens?: MensagemCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaCreateNestedManyWithoutCultosInput
  }

  export type CultoUncheckedCreateWithoutLiderCanticoInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    obreiroId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auxiliares?: UserUncheckedCreateNestedManyWithoutCultosComoAuxiliarInput
    vocal?: UserUncheckedCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoUncheckedCreateNestedManyWithoutCultosInput
    mensagens?: MensagemUncheckedCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaUncheckedCreateNestedManyWithoutCultosInput
  }

  export type CultoCreateOrConnectWithoutLiderCanticoInput = {
    where: CultoWhereUniqueInput
    create: XOR<CultoCreateWithoutLiderCanticoInput, CultoUncheckedCreateWithoutLiderCanticoInput>
  }

  export type CultoCreateManyLiderCanticoInputEnvelope = {
    data: CultoCreateManyLiderCanticoInput | CultoCreateManyLiderCanticoInput[]
    skipDuplicates?: boolean
  }

  export type CultoCreateWithoutVocalInput = {
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutCultosInput
    pastor: UserCreateNestedOneWithoutCultosComoPastorInput
    obreiro: UserCreateNestedOneWithoutCultosComoObreiroInput
    auxiliares?: UserCreateNestedManyWithoutCultosComoAuxiliarInput
    liderCantico: UserCreateNestedOneWithoutCultosComoLiderCanticoInput
    hinos?: HinoCreateNestedManyWithoutCultosInput
    mensagens?: MensagemCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaCreateNestedManyWithoutCultosInput
  }

  export type CultoUncheckedCreateWithoutVocalInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auxiliares?: UserUncheckedCreateNestedManyWithoutCultosComoAuxiliarInput
    hinos?: HinoUncheckedCreateNestedManyWithoutCultosInput
    mensagens?: MensagemUncheckedCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaUncheckedCreateNestedManyWithoutCultosInput
  }

  export type CultoCreateOrConnectWithoutVocalInput = {
    where: CultoWhereUniqueInput
    create: XOR<CultoCreateWithoutVocalInput, CultoUncheckedCreateWithoutVocalInput>
  }

  export type ReuniaoCreateWithoutResponsavelInput = {
    titulo: string
    dataHora: Date | string
    status: string
    materiais: string
    cronograma: string
    informacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutReunioesInput
  }

  export type ReuniaoUncheckedCreateWithoutResponsavelInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    materiais: string
    cronograma: string
    informacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReuniaoCreateOrConnectWithoutResponsavelInput = {
    where: ReuniaoWhereUniqueInput
    create: XOR<ReuniaoCreateWithoutResponsavelInput, ReuniaoUncheckedCreateWithoutResponsavelInput>
  }

  export type ReuniaoCreateManyResponsavelInputEnvelope = {
    data: ReuniaoCreateManyResponsavelInput | ReuniaoCreateManyResponsavelInput[]
    skipDuplicates?: boolean
  }

  export type EnsaioCreateWithoutResponsavelInput = {
    titulo: string
    dataHora: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutEnsaiosInput
    participantes?: UserCreateNestedManyWithoutParticipaEnsaiosInput
    hinos?: HinoCreateNestedManyWithoutEnsaiosInput
  }

  export type EnsaioUncheckedCreateWithoutResponsavelInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participantes?: UserUncheckedCreateNestedManyWithoutParticipaEnsaiosInput
    hinos?: HinoUncheckedCreateNestedManyWithoutEnsaiosInput
  }

  export type EnsaioCreateOrConnectWithoutResponsavelInput = {
    where: EnsaioWhereUniqueInput
    create: XOR<EnsaioCreateWithoutResponsavelInput, EnsaioUncheckedCreateWithoutResponsavelInput>
  }

  export type EnsaioCreateManyResponsavelInputEnvelope = {
    data: EnsaioCreateManyResponsavelInput | EnsaioCreateManyResponsavelInput[]
    skipDuplicates?: boolean
  }

  export type EnsaioCreateWithoutParticipantesInput = {
    titulo: string
    dataHora: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutEnsaiosInput
    responsavel: UserCreateNestedOneWithoutEnsaiosResponsavelInput
    hinos?: HinoCreateNestedManyWithoutEnsaiosInput
  }

  export type EnsaioUncheckedCreateWithoutParticipantesInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hinos?: HinoUncheckedCreateNestedManyWithoutEnsaiosInput
  }

  export type EnsaioCreateOrConnectWithoutParticipantesInput = {
    where: EnsaioWhereUniqueInput
    create: XOR<EnsaioCreateWithoutParticipantesInput, EnsaioUncheckedCreateWithoutParticipantesInput>
  }

  export type CargoUpsertWithoutUsersInput = {
    update: XOR<CargoUpdateWithoutUsersInput, CargoUncheckedUpdateWithoutUsersInput>
    create: XOR<CargoCreateWithoutUsersInput, CargoUncheckedCreateWithoutUsersInput>
    where?: CargoWhereInput
  }

  export type CargoUpdateToOneWithWhereWithoutUsersInput = {
    where?: CargoWhereInput
    data: XOR<CargoUpdateWithoutUsersInput, CargoUncheckedUpdateWithoutUsersInput>
  }

  export type CargoUpdateWithoutUsersInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type CargoUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type CultoUpsertWithWhereUniqueWithoutPastorInput = {
    where: CultoWhereUniqueInput
    update: XOR<CultoUpdateWithoutPastorInput, CultoUncheckedUpdateWithoutPastorInput>
    create: XOR<CultoCreateWithoutPastorInput, CultoUncheckedCreateWithoutPastorInput>
  }

  export type CultoUpdateWithWhereUniqueWithoutPastorInput = {
    where: CultoWhereUniqueInput
    data: XOR<CultoUpdateWithoutPastorInput, CultoUncheckedUpdateWithoutPastorInput>
  }

  export type CultoUpdateManyWithWhereWithoutPastorInput = {
    where: CultoScalarWhereInput
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyWithoutPastorInput>
  }

  export type CultoScalarWhereInput = {
    AND?: CultoScalarWhereInput | CultoScalarWhereInput[]
    OR?: CultoScalarWhereInput[]
    NOT?: CultoScalarWhereInput | CultoScalarWhereInput[]
    id?: IntFilter<"Culto"> | number
    titulo?: StringFilter<"Culto"> | string
    dataInicio?: DateTimeFilter<"Culto"> | Date | string
    dataTermino?: DateTimeFilter<"Culto"> | Date | string
    localId?: IntFilter<"Culto"> | number
    status?: StringFilter<"Culto"> | string
    pastorId?: IntFilter<"Culto"> | number
    obreiroId?: IntFilter<"Culto"> | number
    liderCanticoId?: IntFilter<"Culto"> | number
    videoUrl?: StringNullableFilter<"Culto"> | string | null
    createdAt?: DateTimeFilter<"Culto"> | Date | string
    updatedAt?: DateTimeFilter<"Culto"> | Date | string
  }

  export type CultoUpsertWithWhereUniqueWithoutObreiroInput = {
    where: CultoWhereUniqueInput
    update: XOR<CultoUpdateWithoutObreiroInput, CultoUncheckedUpdateWithoutObreiroInput>
    create: XOR<CultoCreateWithoutObreiroInput, CultoUncheckedCreateWithoutObreiroInput>
  }

  export type CultoUpdateWithWhereUniqueWithoutObreiroInput = {
    where: CultoWhereUniqueInput
    data: XOR<CultoUpdateWithoutObreiroInput, CultoUncheckedUpdateWithoutObreiroInput>
  }

  export type CultoUpdateManyWithWhereWithoutObreiroInput = {
    where: CultoScalarWhereInput
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyWithoutObreiroInput>
  }

  export type CultoUpsertWithWhereUniqueWithoutAuxiliaresInput = {
    where: CultoWhereUniqueInput
    update: XOR<CultoUpdateWithoutAuxiliaresInput, CultoUncheckedUpdateWithoutAuxiliaresInput>
    create: XOR<CultoCreateWithoutAuxiliaresInput, CultoUncheckedCreateWithoutAuxiliaresInput>
  }

  export type CultoUpdateWithWhereUniqueWithoutAuxiliaresInput = {
    where: CultoWhereUniqueInput
    data: XOR<CultoUpdateWithoutAuxiliaresInput, CultoUncheckedUpdateWithoutAuxiliaresInput>
  }

  export type CultoUpdateManyWithWhereWithoutAuxiliaresInput = {
    where: CultoScalarWhereInput
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyWithoutAuxiliaresInput>
  }

  export type CultoUpsertWithWhereUniqueWithoutLiderCanticoInput = {
    where: CultoWhereUniqueInput
    update: XOR<CultoUpdateWithoutLiderCanticoInput, CultoUncheckedUpdateWithoutLiderCanticoInput>
    create: XOR<CultoCreateWithoutLiderCanticoInput, CultoUncheckedCreateWithoutLiderCanticoInput>
  }

  export type CultoUpdateWithWhereUniqueWithoutLiderCanticoInput = {
    where: CultoWhereUniqueInput
    data: XOR<CultoUpdateWithoutLiderCanticoInput, CultoUncheckedUpdateWithoutLiderCanticoInput>
  }

  export type CultoUpdateManyWithWhereWithoutLiderCanticoInput = {
    where: CultoScalarWhereInput
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyWithoutLiderCanticoInput>
  }

  export type CultoUpsertWithWhereUniqueWithoutVocalInput = {
    where: CultoWhereUniqueInput
    update: XOR<CultoUpdateWithoutVocalInput, CultoUncheckedUpdateWithoutVocalInput>
    create: XOR<CultoCreateWithoutVocalInput, CultoUncheckedCreateWithoutVocalInput>
  }

  export type CultoUpdateWithWhereUniqueWithoutVocalInput = {
    where: CultoWhereUniqueInput
    data: XOR<CultoUpdateWithoutVocalInput, CultoUncheckedUpdateWithoutVocalInput>
  }

  export type CultoUpdateManyWithWhereWithoutVocalInput = {
    where: CultoScalarWhereInput
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyWithoutVocalInput>
  }

  export type ReuniaoUpsertWithWhereUniqueWithoutResponsavelInput = {
    where: ReuniaoWhereUniqueInput
    update: XOR<ReuniaoUpdateWithoutResponsavelInput, ReuniaoUncheckedUpdateWithoutResponsavelInput>
    create: XOR<ReuniaoCreateWithoutResponsavelInput, ReuniaoUncheckedCreateWithoutResponsavelInput>
  }

  export type ReuniaoUpdateWithWhereUniqueWithoutResponsavelInput = {
    where: ReuniaoWhereUniqueInput
    data: XOR<ReuniaoUpdateWithoutResponsavelInput, ReuniaoUncheckedUpdateWithoutResponsavelInput>
  }

  export type ReuniaoUpdateManyWithWhereWithoutResponsavelInput = {
    where: ReuniaoScalarWhereInput
    data: XOR<ReuniaoUpdateManyMutationInput, ReuniaoUncheckedUpdateManyWithoutResponsavelInput>
  }

  export type ReuniaoScalarWhereInput = {
    AND?: ReuniaoScalarWhereInput | ReuniaoScalarWhereInput[]
    OR?: ReuniaoScalarWhereInput[]
    NOT?: ReuniaoScalarWhereInput | ReuniaoScalarWhereInput[]
    id?: IntFilter<"Reuniao"> | number
    titulo?: StringFilter<"Reuniao"> | string
    dataHora?: DateTimeFilter<"Reuniao"> | Date | string
    localId?: IntFilter<"Reuniao"> | number
    status?: StringFilter<"Reuniao"> | string
    responsavelId?: IntFilter<"Reuniao"> | number
    materiais?: StringFilter<"Reuniao"> | string
    cronograma?: StringFilter<"Reuniao"> | string
    informacoes?: StringNullableFilter<"Reuniao"> | string | null
    createdAt?: DateTimeFilter<"Reuniao"> | Date | string
    updatedAt?: DateTimeFilter<"Reuniao"> | Date | string
  }

  export type EnsaioUpsertWithWhereUniqueWithoutResponsavelInput = {
    where: EnsaioWhereUniqueInput
    update: XOR<EnsaioUpdateWithoutResponsavelInput, EnsaioUncheckedUpdateWithoutResponsavelInput>
    create: XOR<EnsaioCreateWithoutResponsavelInput, EnsaioUncheckedCreateWithoutResponsavelInput>
  }

  export type EnsaioUpdateWithWhereUniqueWithoutResponsavelInput = {
    where: EnsaioWhereUniqueInput
    data: XOR<EnsaioUpdateWithoutResponsavelInput, EnsaioUncheckedUpdateWithoutResponsavelInput>
  }

  export type EnsaioUpdateManyWithWhereWithoutResponsavelInput = {
    where: EnsaioScalarWhereInput
    data: XOR<EnsaioUpdateManyMutationInput, EnsaioUncheckedUpdateManyWithoutResponsavelInput>
  }

  export type EnsaioScalarWhereInput = {
    AND?: EnsaioScalarWhereInput | EnsaioScalarWhereInput[]
    OR?: EnsaioScalarWhereInput[]
    NOT?: EnsaioScalarWhereInput | EnsaioScalarWhereInput[]
    id?: IntFilter<"Ensaio"> | number
    titulo?: StringFilter<"Ensaio"> | string
    dataHora?: DateTimeFilter<"Ensaio"> | Date | string
    localId?: IntFilter<"Ensaio"> | number
    status?: StringFilter<"Ensaio"> | string
    responsavelId?: IntFilter<"Ensaio"> | number
    createdAt?: DateTimeFilter<"Ensaio"> | Date | string
    updatedAt?: DateTimeFilter<"Ensaio"> | Date | string
  }

  export type EnsaioUpsertWithWhereUniqueWithoutParticipantesInput = {
    where: EnsaioWhereUniqueInput
    update: XOR<EnsaioUpdateWithoutParticipantesInput, EnsaioUncheckedUpdateWithoutParticipantesInput>
    create: XOR<EnsaioCreateWithoutParticipantesInput, EnsaioUncheckedCreateWithoutParticipantesInput>
  }

  export type EnsaioUpdateWithWhereUniqueWithoutParticipantesInput = {
    where: EnsaioWhereUniqueInput
    data: XOR<EnsaioUpdateWithoutParticipantesInput, EnsaioUncheckedUpdateWithoutParticipantesInput>
  }

  export type EnsaioUpdateManyWithWhereWithoutParticipantesInput = {
    where: EnsaioScalarWhereInput
    data: XOR<EnsaioUpdateManyMutationInput, EnsaioUncheckedUpdateManyWithoutParticipantesInput>
  }

  export type LeituraCreateWithoutLiveInput = {
    texto: string
    minuto: string
    createdAt?: Date | string
  }

  export type LeituraUncheckedCreateWithoutLiveInput = {
    id?: number
    texto: string
    minuto: string
    createdAt?: Date | string
  }

  export type LeituraCreateOrConnectWithoutLiveInput = {
    where: LeituraWhereUniqueInput
    create: XOR<LeituraCreateWithoutLiveInput, LeituraUncheckedCreateWithoutLiveInput>
  }

  export type LeituraCreateManyLiveInputEnvelope = {
    data: LeituraCreateManyLiveInput | LeituraCreateManyLiveInput[]
    skipDuplicates?: boolean
  }

  export type PedidoOracaoCreateWithoutLiveInput = {
    para: string
    motivo: string
    createdAt?: Date | string
  }

  export type PedidoOracaoUncheckedCreateWithoutLiveInput = {
    id?: number
    para: string
    motivo: string
    createdAt?: Date | string
  }

  export type PedidoOracaoCreateOrConnectWithoutLiveInput = {
    where: PedidoOracaoWhereUniqueInput
    create: XOR<PedidoOracaoCreateWithoutLiveInput, PedidoOracaoUncheckedCreateWithoutLiveInput>
  }

  export type PedidoOracaoCreateManyLiveInputEnvelope = {
    data: PedidoOracaoCreateManyLiveInput | PedidoOracaoCreateManyLiveInput[]
    skipDuplicates?: boolean
  }

  export type ViewerSessionCreateWithoutLiveInput = {
    sessionId: string
    userName?: string | null
    userImage?: string | null
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type ViewerSessionUncheckedCreateWithoutLiveInput = {
    id?: number
    sessionId: string
    userName?: string | null
    userImage?: string | null
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type ViewerSessionCreateOrConnectWithoutLiveInput = {
    where: ViewerSessionWhereUniqueInput
    create: XOR<ViewerSessionCreateWithoutLiveInput, ViewerSessionUncheckedCreateWithoutLiveInput>
  }

  export type ViewerSessionCreateManyLiveInputEnvelope = {
    data: ViewerSessionCreateManyLiveInput | ViewerSessionCreateManyLiveInput[]
    skipDuplicates?: boolean
  }

  export type LeituraUpsertWithWhereUniqueWithoutLiveInput = {
    where: LeituraWhereUniqueInput
    update: XOR<LeituraUpdateWithoutLiveInput, LeituraUncheckedUpdateWithoutLiveInput>
    create: XOR<LeituraCreateWithoutLiveInput, LeituraUncheckedCreateWithoutLiveInput>
  }

  export type LeituraUpdateWithWhereUniqueWithoutLiveInput = {
    where: LeituraWhereUniqueInput
    data: XOR<LeituraUpdateWithoutLiveInput, LeituraUncheckedUpdateWithoutLiveInput>
  }

  export type LeituraUpdateManyWithWhereWithoutLiveInput = {
    where: LeituraScalarWhereInput
    data: XOR<LeituraUpdateManyMutationInput, LeituraUncheckedUpdateManyWithoutLiveInput>
  }

  export type LeituraScalarWhereInput = {
    AND?: LeituraScalarWhereInput | LeituraScalarWhereInput[]
    OR?: LeituraScalarWhereInput[]
    NOT?: LeituraScalarWhereInput | LeituraScalarWhereInput[]
    id?: IntFilter<"Leitura"> | number
    texto?: StringFilter<"Leitura"> | string
    minuto?: StringFilter<"Leitura"> | string
    liveId?: IntFilter<"Leitura"> | number
    createdAt?: DateTimeFilter<"Leitura"> | Date | string
  }

  export type PedidoOracaoUpsertWithWhereUniqueWithoutLiveInput = {
    where: PedidoOracaoWhereUniqueInput
    update: XOR<PedidoOracaoUpdateWithoutLiveInput, PedidoOracaoUncheckedUpdateWithoutLiveInput>
    create: XOR<PedidoOracaoCreateWithoutLiveInput, PedidoOracaoUncheckedCreateWithoutLiveInput>
  }

  export type PedidoOracaoUpdateWithWhereUniqueWithoutLiveInput = {
    where: PedidoOracaoWhereUniqueInput
    data: XOR<PedidoOracaoUpdateWithoutLiveInput, PedidoOracaoUncheckedUpdateWithoutLiveInput>
  }

  export type PedidoOracaoUpdateManyWithWhereWithoutLiveInput = {
    where: PedidoOracaoScalarWhereInput
    data: XOR<PedidoOracaoUpdateManyMutationInput, PedidoOracaoUncheckedUpdateManyWithoutLiveInput>
  }

  export type PedidoOracaoScalarWhereInput = {
    AND?: PedidoOracaoScalarWhereInput | PedidoOracaoScalarWhereInput[]
    OR?: PedidoOracaoScalarWhereInput[]
    NOT?: PedidoOracaoScalarWhereInput | PedidoOracaoScalarWhereInput[]
    id?: IntFilter<"PedidoOracao"> | number
    para?: StringFilter<"PedidoOracao"> | string
    motivo?: StringFilter<"PedidoOracao"> | string
    liveId?: IntFilter<"PedidoOracao"> | number
    createdAt?: DateTimeFilter<"PedidoOracao"> | Date | string
  }

  export type ViewerSessionUpsertWithWhereUniqueWithoutLiveInput = {
    where: ViewerSessionWhereUniqueInput
    update: XOR<ViewerSessionUpdateWithoutLiveInput, ViewerSessionUncheckedUpdateWithoutLiveInput>
    create: XOR<ViewerSessionCreateWithoutLiveInput, ViewerSessionUncheckedCreateWithoutLiveInput>
  }

  export type ViewerSessionUpdateWithWhereUniqueWithoutLiveInput = {
    where: ViewerSessionWhereUniqueInput
    data: XOR<ViewerSessionUpdateWithoutLiveInput, ViewerSessionUncheckedUpdateWithoutLiveInput>
  }

  export type ViewerSessionUpdateManyWithWhereWithoutLiveInput = {
    where: ViewerSessionScalarWhereInput
    data: XOR<ViewerSessionUpdateManyMutationInput, ViewerSessionUncheckedUpdateManyWithoutLiveInput>
  }

  export type ViewerSessionScalarWhereInput = {
    AND?: ViewerSessionScalarWhereInput | ViewerSessionScalarWhereInput[]
    OR?: ViewerSessionScalarWhereInput[]
    NOT?: ViewerSessionScalarWhereInput | ViewerSessionScalarWhereInput[]
    id?: IntFilter<"ViewerSession"> | number
    sessionId?: StringFilter<"ViewerSession"> | string
    userName?: StringNullableFilter<"ViewerSession"> | string | null
    userImage?: StringNullableFilter<"ViewerSession"> | string | null
    liveId?: IntFilter<"ViewerSession"> | number
    createdAt?: DateTimeFilter<"ViewerSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"ViewerSession"> | Date | string | null
  }

  export type LiveCreateWithoutLeiturasInput = {
    youtubeId: string
    title: string
    viewers?: number
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosOracao?: PedidoOracaoCreateNestedManyWithoutLiveInput
    viewerSessions?: ViewerSessionCreateNestedManyWithoutLiveInput
  }

  export type LiveUncheckedCreateWithoutLeiturasInput = {
    id?: number
    youtubeId: string
    title: string
    viewers?: number
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pedidosOracao?: PedidoOracaoUncheckedCreateNestedManyWithoutLiveInput
    viewerSessions?: ViewerSessionUncheckedCreateNestedManyWithoutLiveInput
  }

  export type LiveCreateOrConnectWithoutLeiturasInput = {
    where: LiveWhereUniqueInput
    create: XOR<LiveCreateWithoutLeiturasInput, LiveUncheckedCreateWithoutLeiturasInput>
  }

  export type LiveUpsertWithoutLeiturasInput = {
    update: XOR<LiveUpdateWithoutLeiturasInput, LiveUncheckedUpdateWithoutLeiturasInput>
    create: XOR<LiveCreateWithoutLeiturasInput, LiveUncheckedCreateWithoutLeiturasInput>
    where?: LiveWhereInput
  }

  export type LiveUpdateToOneWithWhereWithoutLeiturasInput = {
    where?: LiveWhereInput
    data: XOR<LiveUpdateWithoutLeiturasInput, LiveUncheckedUpdateWithoutLeiturasInput>
  }

  export type LiveUpdateWithoutLeiturasInput = {
    youtubeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    viewers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ofertaAtiva?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosOracao?: PedidoOracaoUpdateManyWithoutLiveNestedInput
    viewerSessions?: ViewerSessionUpdateManyWithoutLiveNestedInput
  }

  export type LiveUncheckedUpdateWithoutLeiturasInput = {
    id?: IntFieldUpdateOperationsInput | number
    youtubeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    viewers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ofertaAtiva?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pedidosOracao?: PedidoOracaoUncheckedUpdateManyWithoutLiveNestedInput
    viewerSessions?: ViewerSessionUncheckedUpdateManyWithoutLiveNestedInput
  }

  export type LiveCreateWithoutPedidosOracaoInput = {
    youtubeId: string
    title: string
    viewers?: number
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leituras?: LeituraCreateNestedManyWithoutLiveInput
    viewerSessions?: ViewerSessionCreateNestedManyWithoutLiveInput
  }

  export type LiveUncheckedCreateWithoutPedidosOracaoInput = {
    id?: number
    youtubeId: string
    title: string
    viewers?: number
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leituras?: LeituraUncheckedCreateNestedManyWithoutLiveInput
    viewerSessions?: ViewerSessionUncheckedCreateNestedManyWithoutLiveInput
  }

  export type LiveCreateOrConnectWithoutPedidosOracaoInput = {
    where: LiveWhereUniqueInput
    create: XOR<LiveCreateWithoutPedidosOracaoInput, LiveUncheckedCreateWithoutPedidosOracaoInput>
  }

  export type LiveUpsertWithoutPedidosOracaoInput = {
    update: XOR<LiveUpdateWithoutPedidosOracaoInput, LiveUncheckedUpdateWithoutPedidosOracaoInput>
    create: XOR<LiveCreateWithoutPedidosOracaoInput, LiveUncheckedCreateWithoutPedidosOracaoInput>
    where?: LiveWhereInput
  }

  export type LiveUpdateToOneWithWhereWithoutPedidosOracaoInput = {
    where?: LiveWhereInput
    data: XOR<LiveUpdateWithoutPedidosOracaoInput, LiveUncheckedUpdateWithoutPedidosOracaoInput>
  }

  export type LiveUpdateWithoutPedidosOracaoInput = {
    youtubeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    viewers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ofertaAtiva?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leituras?: LeituraUpdateManyWithoutLiveNestedInput
    viewerSessions?: ViewerSessionUpdateManyWithoutLiveNestedInput
  }

  export type LiveUncheckedUpdateWithoutPedidosOracaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    youtubeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    viewers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ofertaAtiva?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leituras?: LeituraUncheckedUpdateManyWithoutLiveNestedInput
    viewerSessions?: ViewerSessionUncheckedUpdateManyWithoutLiveNestedInput
  }

  export type LiveCreateWithoutViewerSessionsInput = {
    youtubeId: string
    title: string
    viewers?: number
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leituras?: LeituraCreateNestedManyWithoutLiveInput
    pedidosOracao?: PedidoOracaoCreateNestedManyWithoutLiveInput
  }

  export type LiveUncheckedCreateWithoutViewerSessionsInput = {
    id?: number
    youtubeId: string
    title: string
    viewers?: number
    isActive?: boolean
    ofertaAtiva?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    leituras?: LeituraUncheckedCreateNestedManyWithoutLiveInput
    pedidosOracao?: PedidoOracaoUncheckedCreateNestedManyWithoutLiveInput
  }

  export type LiveCreateOrConnectWithoutViewerSessionsInput = {
    where: LiveWhereUniqueInput
    create: XOR<LiveCreateWithoutViewerSessionsInput, LiveUncheckedCreateWithoutViewerSessionsInput>
  }

  export type LiveUpsertWithoutViewerSessionsInput = {
    update: XOR<LiveUpdateWithoutViewerSessionsInput, LiveUncheckedUpdateWithoutViewerSessionsInput>
    create: XOR<LiveCreateWithoutViewerSessionsInput, LiveUncheckedCreateWithoutViewerSessionsInput>
    where?: LiveWhereInput
  }

  export type LiveUpdateToOneWithWhereWithoutViewerSessionsInput = {
    where?: LiveWhereInput
    data: XOR<LiveUpdateWithoutViewerSessionsInput, LiveUncheckedUpdateWithoutViewerSessionsInput>
  }

  export type LiveUpdateWithoutViewerSessionsInput = {
    youtubeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    viewers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ofertaAtiva?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leituras?: LeituraUpdateManyWithoutLiveNestedInput
    pedidosOracao?: PedidoOracaoUpdateManyWithoutLiveNestedInput
  }

  export type LiveUncheckedUpdateWithoutViewerSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    youtubeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    viewers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ofertaAtiva?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leituras?: LeituraUncheckedUpdateManyWithoutLiveNestedInput
    pedidosOracao?: PedidoOracaoUncheckedUpdateManyWithoutLiveNestedInput
  }

  export type UserCreateWithoutCargoInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoPastor?: CultoCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioCreateNestedManyWithoutParticipantesInput
  }

  export type UserUncheckedCreateWithoutCargoInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoPastor?: CultoUncheckedCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoUncheckedCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoUncheckedCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoUncheckedCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoUncheckedCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoUncheckedCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioUncheckedCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioUncheckedCreateNestedManyWithoutParticipantesInput
  }

  export type UserCreateOrConnectWithoutCargoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCargoInput, UserUncheckedCreateWithoutCargoInput>
  }

  export type UserCreateManyCargoInputEnvelope = {
    data: UserCreateManyCargoInput | UserCreateManyCargoInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCargoInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCargoInput, UserUncheckedUpdateWithoutCargoInput>
    create: XOR<UserCreateWithoutCargoInput, UserUncheckedCreateWithoutCargoInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCargoInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCargoInput, UserUncheckedUpdateWithoutCargoInput>
  }

  export type UserUpdateManyWithWhereWithoutCargoInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCargoInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    cargoId?: IntNullableFilter<"User"> | number | null
    online?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type CultoCreateWithoutLocalInput = {
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pastor: UserCreateNestedOneWithoutCultosComoPastorInput
    obreiro: UserCreateNestedOneWithoutCultosComoObreiroInput
    auxiliares?: UserCreateNestedManyWithoutCultosComoAuxiliarInput
    liderCantico: UserCreateNestedOneWithoutCultosComoLiderCanticoInput
    vocal?: UserCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoCreateNestedManyWithoutCultosInput
    mensagens?: MensagemCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaCreateNestedManyWithoutCultosInput
  }

  export type CultoUncheckedCreateWithoutLocalInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auxiliares?: UserUncheckedCreateNestedManyWithoutCultosComoAuxiliarInput
    vocal?: UserUncheckedCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoUncheckedCreateNestedManyWithoutCultosInput
    mensagens?: MensagemUncheckedCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaUncheckedCreateNestedManyWithoutCultosInput
  }

  export type CultoCreateOrConnectWithoutLocalInput = {
    where: CultoWhereUniqueInput
    create: XOR<CultoCreateWithoutLocalInput, CultoUncheckedCreateWithoutLocalInput>
  }

  export type CultoCreateManyLocalInputEnvelope = {
    data: CultoCreateManyLocalInput | CultoCreateManyLocalInput[]
    skipDuplicates?: boolean
  }

  export type ReuniaoCreateWithoutLocalInput = {
    titulo: string
    dataHora: Date | string
    status: string
    materiais: string
    cronograma: string
    informacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsavel: UserCreateNestedOneWithoutReunioesResponsavelInput
  }

  export type ReuniaoUncheckedCreateWithoutLocalInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    status: string
    responsavelId: number
    materiais: string
    cronograma: string
    informacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReuniaoCreateOrConnectWithoutLocalInput = {
    where: ReuniaoWhereUniqueInput
    create: XOR<ReuniaoCreateWithoutLocalInput, ReuniaoUncheckedCreateWithoutLocalInput>
  }

  export type ReuniaoCreateManyLocalInputEnvelope = {
    data: ReuniaoCreateManyLocalInput | ReuniaoCreateManyLocalInput[]
    skipDuplicates?: boolean
  }

  export type EnsaioCreateWithoutLocalInput = {
    titulo: string
    dataHora: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responsavel: UserCreateNestedOneWithoutEnsaiosResponsavelInput
    participantes?: UserCreateNestedManyWithoutParticipaEnsaiosInput
    hinos?: HinoCreateNestedManyWithoutEnsaiosInput
  }

  export type EnsaioUncheckedCreateWithoutLocalInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    status: string
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    participantes?: UserUncheckedCreateNestedManyWithoutParticipaEnsaiosInput
    hinos?: HinoUncheckedCreateNestedManyWithoutEnsaiosInput
  }

  export type EnsaioCreateOrConnectWithoutLocalInput = {
    where: EnsaioWhereUniqueInput
    create: XOR<EnsaioCreateWithoutLocalInput, EnsaioUncheckedCreateWithoutLocalInput>
  }

  export type EnsaioCreateManyLocalInputEnvelope = {
    data: EnsaioCreateManyLocalInput | EnsaioCreateManyLocalInput[]
    skipDuplicates?: boolean
  }

  export type EventoCreateWithoutLocalInput = {
    titulo: string
    dataHora: Date | string
    status: string
    cronograma: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoUncheckedCreateWithoutLocalInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    status: string
    cronograma: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoCreateOrConnectWithoutLocalInput = {
    where: EventoWhereUniqueInput
    create: XOR<EventoCreateWithoutLocalInput, EventoUncheckedCreateWithoutLocalInput>
  }

  export type EventoCreateManyLocalInputEnvelope = {
    data: EventoCreateManyLocalInput | EventoCreateManyLocalInput[]
    skipDuplicates?: boolean
  }

  export type CultoUpsertWithWhereUniqueWithoutLocalInput = {
    where: CultoWhereUniqueInput
    update: XOR<CultoUpdateWithoutLocalInput, CultoUncheckedUpdateWithoutLocalInput>
    create: XOR<CultoCreateWithoutLocalInput, CultoUncheckedCreateWithoutLocalInput>
  }

  export type CultoUpdateWithWhereUniqueWithoutLocalInput = {
    where: CultoWhereUniqueInput
    data: XOR<CultoUpdateWithoutLocalInput, CultoUncheckedUpdateWithoutLocalInput>
  }

  export type CultoUpdateManyWithWhereWithoutLocalInput = {
    where: CultoScalarWhereInput
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyWithoutLocalInput>
  }

  export type ReuniaoUpsertWithWhereUniqueWithoutLocalInput = {
    where: ReuniaoWhereUniqueInput
    update: XOR<ReuniaoUpdateWithoutLocalInput, ReuniaoUncheckedUpdateWithoutLocalInput>
    create: XOR<ReuniaoCreateWithoutLocalInput, ReuniaoUncheckedCreateWithoutLocalInput>
  }

  export type ReuniaoUpdateWithWhereUniqueWithoutLocalInput = {
    where: ReuniaoWhereUniqueInput
    data: XOR<ReuniaoUpdateWithoutLocalInput, ReuniaoUncheckedUpdateWithoutLocalInput>
  }

  export type ReuniaoUpdateManyWithWhereWithoutLocalInput = {
    where: ReuniaoScalarWhereInput
    data: XOR<ReuniaoUpdateManyMutationInput, ReuniaoUncheckedUpdateManyWithoutLocalInput>
  }

  export type EnsaioUpsertWithWhereUniqueWithoutLocalInput = {
    where: EnsaioWhereUniqueInput
    update: XOR<EnsaioUpdateWithoutLocalInput, EnsaioUncheckedUpdateWithoutLocalInput>
    create: XOR<EnsaioCreateWithoutLocalInput, EnsaioUncheckedCreateWithoutLocalInput>
  }

  export type EnsaioUpdateWithWhereUniqueWithoutLocalInput = {
    where: EnsaioWhereUniqueInput
    data: XOR<EnsaioUpdateWithoutLocalInput, EnsaioUncheckedUpdateWithoutLocalInput>
  }

  export type EnsaioUpdateManyWithWhereWithoutLocalInput = {
    where: EnsaioScalarWhereInput
    data: XOR<EnsaioUpdateManyMutationInput, EnsaioUncheckedUpdateManyWithoutLocalInput>
  }

  export type EventoUpsertWithWhereUniqueWithoutLocalInput = {
    where: EventoWhereUniqueInput
    update: XOR<EventoUpdateWithoutLocalInput, EventoUncheckedUpdateWithoutLocalInput>
    create: XOR<EventoCreateWithoutLocalInput, EventoUncheckedCreateWithoutLocalInput>
  }

  export type EventoUpdateWithWhereUniqueWithoutLocalInput = {
    where: EventoWhereUniqueInput
    data: XOR<EventoUpdateWithoutLocalInput, EventoUncheckedUpdateWithoutLocalInput>
  }

  export type EventoUpdateManyWithWhereWithoutLocalInput = {
    where: EventoScalarWhereInput
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyWithoutLocalInput>
  }

  export type EventoScalarWhereInput = {
    AND?: EventoScalarWhereInput | EventoScalarWhereInput[]
    OR?: EventoScalarWhereInput[]
    NOT?: EventoScalarWhereInput | EventoScalarWhereInput[]
    id?: IntFilter<"Evento"> | number
    titulo?: StringFilter<"Evento"> | string
    dataHora?: DateTimeFilter<"Evento"> | Date | string
    localId?: IntFilter<"Evento"> | number
    status?: StringFilter<"Evento"> | string
    cronograma?: StringFilter<"Evento"> | string
    createdAt?: DateTimeFilter<"Evento"> | Date | string
    updatedAt?: DateTimeFilter<"Evento"> | Date | string
  }

  export type LocalCreateWithoutCultosInput = {
    nome: string
    latitude: number
    longitude: number
    reunioes?: ReuniaoCreateNestedManyWithoutLocalInput
    ensaios?: EnsaioCreateNestedManyWithoutLocalInput
    eventos?: EventoCreateNestedManyWithoutLocalInput
  }

  export type LocalUncheckedCreateWithoutCultosInput = {
    id?: number
    nome: string
    latitude: number
    longitude: number
    reunioes?: ReuniaoUncheckedCreateNestedManyWithoutLocalInput
    ensaios?: EnsaioUncheckedCreateNestedManyWithoutLocalInput
    eventos?: EventoUncheckedCreateNestedManyWithoutLocalInput
  }

  export type LocalCreateOrConnectWithoutCultosInput = {
    where: LocalWhereUniqueInput
    create: XOR<LocalCreateWithoutCultosInput, LocalUncheckedCreateWithoutCultosInput>
  }

  export type UserCreateWithoutCultosComoPastorInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cargo?: CargoCreateNestedOneWithoutUsersInput
    cultosComoObreiro?: CultoCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioCreateNestedManyWithoutParticipantesInput
  }

  export type UserUncheckedCreateWithoutCultosComoPastorInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    cargoId?: number | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoObreiro?: CultoUncheckedCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoUncheckedCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoUncheckedCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoUncheckedCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoUncheckedCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioUncheckedCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioUncheckedCreateNestedManyWithoutParticipantesInput
  }

  export type UserCreateOrConnectWithoutCultosComoPastorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCultosComoPastorInput, UserUncheckedCreateWithoutCultosComoPastorInput>
  }

  export type UserCreateWithoutCultosComoObreiroInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cargo?: CargoCreateNestedOneWithoutUsersInput
    cultosComoPastor?: CultoCreateNestedManyWithoutPastorInput
    cultosComoAuxiliar?: CultoCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioCreateNestedManyWithoutParticipantesInput
  }

  export type UserUncheckedCreateWithoutCultosComoObreiroInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    cargoId?: number | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoPastor?: CultoUncheckedCreateNestedManyWithoutPastorInput
    cultosComoAuxiliar?: CultoUncheckedCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoUncheckedCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoUncheckedCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoUncheckedCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioUncheckedCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioUncheckedCreateNestedManyWithoutParticipantesInput
  }

  export type UserCreateOrConnectWithoutCultosComoObreiroInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCultosComoObreiroInput, UserUncheckedCreateWithoutCultosComoObreiroInput>
  }

  export type UserCreateWithoutCultosComoAuxiliarInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cargo?: CargoCreateNestedOneWithoutUsersInput
    cultosComoPastor?: CultoCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoCreateNestedManyWithoutObreiroInput
    cultosComoLiderCantico?: CultoCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioCreateNestedManyWithoutParticipantesInput
  }

  export type UserUncheckedCreateWithoutCultosComoAuxiliarInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    cargoId?: number | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoPastor?: CultoUncheckedCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoUncheckedCreateNestedManyWithoutObreiroInput
    cultosComoLiderCantico?: CultoUncheckedCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoUncheckedCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoUncheckedCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioUncheckedCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioUncheckedCreateNestedManyWithoutParticipantesInput
  }

  export type UserCreateOrConnectWithoutCultosComoAuxiliarInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCultosComoAuxiliarInput, UserUncheckedCreateWithoutCultosComoAuxiliarInput>
  }

  export type UserCreateWithoutCultosComoLiderCanticoInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cargo?: CargoCreateNestedOneWithoutUsersInput
    cultosComoPastor?: CultoCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoCreateNestedManyWithoutAuxiliaresInput
    cultosComoVocal?: CultoCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioCreateNestedManyWithoutParticipantesInput
  }

  export type UserUncheckedCreateWithoutCultosComoLiderCanticoInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    cargoId?: number | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoPastor?: CultoUncheckedCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoUncheckedCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoUncheckedCreateNestedManyWithoutAuxiliaresInput
    cultosComoVocal?: CultoUncheckedCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoUncheckedCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioUncheckedCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioUncheckedCreateNestedManyWithoutParticipantesInput
  }

  export type UserCreateOrConnectWithoutCultosComoLiderCanticoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCultosComoLiderCanticoInput, UserUncheckedCreateWithoutCultosComoLiderCanticoInput>
  }

  export type UserCreateWithoutCultosComoVocalInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cargo?: CargoCreateNestedOneWithoutUsersInput
    cultosComoPastor?: CultoCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoCreateNestedManyWithoutLiderCanticoInput
    reunioesResponsavel?: ReuniaoCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioCreateNestedManyWithoutParticipantesInput
  }

  export type UserUncheckedCreateWithoutCultosComoVocalInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    cargoId?: number | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoPastor?: CultoUncheckedCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoUncheckedCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoUncheckedCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoUncheckedCreateNestedManyWithoutLiderCanticoInput
    reunioesResponsavel?: ReuniaoUncheckedCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioUncheckedCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioUncheckedCreateNestedManyWithoutParticipantesInput
  }

  export type UserCreateOrConnectWithoutCultosComoVocalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCultosComoVocalInput, UserUncheckedCreateWithoutCultosComoVocalInput>
  }

  export type HinoCreateWithoutCultosInput = {
    titulo: string
    autor: string
    letra: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ensaios?: EnsaioCreateNestedManyWithoutHinosInput
  }

  export type HinoUncheckedCreateWithoutCultosInput = {
    id?: number
    titulo: string
    autor: string
    letra: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ensaios?: EnsaioUncheckedCreateNestedManyWithoutHinosInput
  }

  export type HinoCreateOrConnectWithoutCultosInput = {
    where: HinoWhereUniqueInput
    create: XOR<HinoCreateWithoutCultosInput, HinoUncheckedCreateWithoutCultosInput>
  }

  export type MensagemCreateWithoutCultosInput = {
    titulo: string
    data: Date | string
    cidade: string
    estado: string
    pais: string
    traduzidoPor?: string | null
    conteudo: string
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MensagemUncheckedCreateWithoutCultosInput = {
    id?: number
    titulo: string
    data: Date | string
    cidade: string
    estado: string
    pais: string
    traduzidoPor?: string | null
    conteudo: string
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MensagemCreateOrConnectWithoutCultosInput = {
    where: MensagemWhereUniqueInput
    create: XOR<MensagemCreateWithoutCultosInput, MensagemUncheckedCreateWithoutCultosInput>
  }

  export type LeituraBiblicaCreateWithoutCultosInput = {
    livro: string
    capitulo: number
    versiculos: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeituraBiblicaUncheckedCreateWithoutCultosInput = {
    id?: number
    livro: string
    capitulo: number
    versiculos: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeituraBiblicaCreateOrConnectWithoutCultosInput = {
    where: LeituraBiblicaWhereUniqueInput
    create: XOR<LeituraBiblicaCreateWithoutCultosInput, LeituraBiblicaUncheckedCreateWithoutCultosInput>
  }

  export type LocalUpsertWithoutCultosInput = {
    update: XOR<LocalUpdateWithoutCultosInput, LocalUncheckedUpdateWithoutCultosInput>
    create: XOR<LocalCreateWithoutCultosInput, LocalUncheckedCreateWithoutCultosInput>
    where?: LocalWhereInput
  }

  export type LocalUpdateToOneWithWhereWithoutCultosInput = {
    where?: LocalWhereInput
    data: XOR<LocalUpdateWithoutCultosInput, LocalUncheckedUpdateWithoutCultosInput>
  }

  export type LocalUpdateWithoutCultosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    reunioes?: ReuniaoUpdateManyWithoutLocalNestedInput
    ensaios?: EnsaioUpdateManyWithoutLocalNestedInput
    eventos?: EventoUpdateManyWithoutLocalNestedInput
  }

  export type LocalUncheckedUpdateWithoutCultosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    reunioes?: ReuniaoUncheckedUpdateManyWithoutLocalNestedInput
    ensaios?: EnsaioUncheckedUpdateManyWithoutLocalNestedInput
    eventos?: EventoUncheckedUpdateManyWithoutLocalNestedInput
  }

  export type UserUpsertWithoutCultosComoPastorInput = {
    update: XOR<UserUpdateWithoutCultosComoPastorInput, UserUncheckedUpdateWithoutCultosComoPastorInput>
    create: XOR<UserCreateWithoutCultosComoPastorInput, UserUncheckedCreateWithoutCultosComoPastorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCultosComoPastorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCultosComoPastorInput, UserUncheckedUpdateWithoutCultosComoPastorInput>
  }

  export type UserUpdateWithoutCultosComoPastorInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cargo?: CargoUpdateOneWithoutUsersNestedInput
    cultosComoObreiro?: CultoUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateWithoutCultosComoPastorInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoObreiro?: CultoUncheckedUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUncheckedUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUncheckedUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUncheckedUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUncheckedUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUncheckedUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUncheckedUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUpsertWithoutCultosComoObreiroInput = {
    update: XOR<UserUpdateWithoutCultosComoObreiroInput, UserUncheckedUpdateWithoutCultosComoObreiroInput>
    create: XOR<UserCreateWithoutCultosComoObreiroInput, UserUncheckedCreateWithoutCultosComoObreiroInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCultosComoObreiroInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCultosComoObreiroInput, UserUncheckedUpdateWithoutCultosComoObreiroInput>
  }

  export type UserUpdateWithoutCultosComoObreiroInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cargo?: CargoUpdateOneWithoutUsersNestedInput
    cultosComoPastor?: CultoUpdateManyWithoutPastorNestedInput
    cultosComoAuxiliar?: CultoUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateWithoutCultosComoObreiroInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoPastor?: CultoUncheckedUpdateManyWithoutPastorNestedInput
    cultosComoAuxiliar?: CultoUncheckedUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUncheckedUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUncheckedUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUncheckedUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUncheckedUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUncheckedUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCultosComoAuxiliarInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCultosComoAuxiliarInput, UserUncheckedUpdateWithoutCultosComoAuxiliarInput>
    create: XOR<UserCreateWithoutCultosComoAuxiliarInput, UserUncheckedCreateWithoutCultosComoAuxiliarInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCultosComoAuxiliarInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCultosComoAuxiliarInput, UserUncheckedUpdateWithoutCultosComoAuxiliarInput>
  }

  export type UserUpdateManyWithWhereWithoutCultosComoAuxiliarInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCultosComoAuxiliarInput>
  }

  export type UserUpsertWithoutCultosComoLiderCanticoInput = {
    update: XOR<UserUpdateWithoutCultosComoLiderCanticoInput, UserUncheckedUpdateWithoutCultosComoLiderCanticoInput>
    create: XOR<UserCreateWithoutCultosComoLiderCanticoInput, UserUncheckedCreateWithoutCultosComoLiderCanticoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCultosComoLiderCanticoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCultosComoLiderCanticoInput, UserUncheckedUpdateWithoutCultosComoLiderCanticoInput>
  }

  export type UserUpdateWithoutCultosComoLiderCanticoInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cargo?: CargoUpdateOneWithoutUsersNestedInput
    cultosComoPastor?: CultoUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUpdateManyWithoutAuxiliaresNestedInput
    cultosComoVocal?: CultoUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateWithoutCultosComoLiderCanticoInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoPastor?: CultoUncheckedUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUncheckedUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUncheckedUpdateManyWithoutAuxiliaresNestedInput
    cultosComoVocal?: CultoUncheckedUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUncheckedUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUncheckedUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUncheckedUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutCultosComoVocalInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCultosComoVocalInput, UserUncheckedUpdateWithoutCultosComoVocalInput>
    create: XOR<UserCreateWithoutCultosComoVocalInput, UserUncheckedCreateWithoutCultosComoVocalInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCultosComoVocalInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCultosComoVocalInput, UserUncheckedUpdateWithoutCultosComoVocalInput>
  }

  export type UserUpdateManyWithWhereWithoutCultosComoVocalInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCultosComoVocalInput>
  }

  export type HinoUpsertWithWhereUniqueWithoutCultosInput = {
    where: HinoWhereUniqueInput
    update: XOR<HinoUpdateWithoutCultosInput, HinoUncheckedUpdateWithoutCultosInput>
    create: XOR<HinoCreateWithoutCultosInput, HinoUncheckedCreateWithoutCultosInput>
  }

  export type HinoUpdateWithWhereUniqueWithoutCultosInput = {
    where: HinoWhereUniqueInput
    data: XOR<HinoUpdateWithoutCultosInput, HinoUncheckedUpdateWithoutCultosInput>
  }

  export type HinoUpdateManyWithWhereWithoutCultosInput = {
    where: HinoScalarWhereInput
    data: XOR<HinoUpdateManyMutationInput, HinoUncheckedUpdateManyWithoutCultosInput>
  }

  export type HinoScalarWhereInput = {
    AND?: HinoScalarWhereInput | HinoScalarWhereInput[]
    OR?: HinoScalarWhereInput[]
    NOT?: HinoScalarWhereInput | HinoScalarWhereInput[]
    id?: IntFilter<"Hino"> | number
    titulo?: StringFilter<"Hino"> | string
    autor?: StringFilter<"Hino"> | string
    letra?: StringFilter<"Hino"> | string
    createdAt?: DateTimeFilter<"Hino"> | Date | string
    updatedAt?: DateTimeFilter<"Hino"> | Date | string
  }

  export type MensagemUpsertWithWhereUniqueWithoutCultosInput = {
    where: MensagemWhereUniqueInput
    update: XOR<MensagemUpdateWithoutCultosInput, MensagemUncheckedUpdateWithoutCultosInput>
    create: XOR<MensagemCreateWithoutCultosInput, MensagemUncheckedCreateWithoutCultosInput>
  }

  export type MensagemUpdateWithWhereUniqueWithoutCultosInput = {
    where: MensagemWhereUniqueInput
    data: XOR<MensagemUpdateWithoutCultosInput, MensagemUncheckedUpdateWithoutCultosInput>
  }

  export type MensagemUpdateManyWithWhereWithoutCultosInput = {
    where: MensagemScalarWhereInput
    data: XOR<MensagemUpdateManyMutationInput, MensagemUncheckedUpdateManyWithoutCultosInput>
  }

  export type MensagemScalarWhereInput = {
    AND?: MensagemScalarWhereInput | MensagemScalarWhereInput[]
    OR?: MensagemScalarWhereInput[]
    NOT?: MensagemScalarWhereInput | MensagemScalarWhereInput[]
    id?: IntFilter<"Mensagem"> | number
    titulo?: StringFilter<"Mensagem"> | string
    data?: DateTimeFilter<"Mensagem"> | Date | string
    cidade?: StringFilter<"Mensagem"> | string
    estado?: StringFilter<"Mensagem"> | string
    pais?: StringFilter<"Mensagem"> | string
    traduzidoPor?: StringNullableFilter<"Mensagem"> | string | null
    conteudo?: StringFilter<"Mensagem"> | string
    pdfUrl?: StringNullableFilter<"Mensagem"> | string | null
    createdAt?: DateTimeFilter<"Mensagem"> | Date | string
    updatedAt?: DateTimeFilter<"Mensagem"> | Date | string
  }

  export type LeituraBiblicaUpsertWithWhereUniqueWithoutCultosInput = {
    where: LeituraBiblicaWhereUniqueInput
    update: XOR<LeituraBiblicaUpdateWithoutCultosInput, LeituraBiblicaUncheckedUpdateWithoutCultosInput>
    create: XOR<LeituraBiblicaCreateWithoutCultosInput, LeituraBiblicaUncheckedCreateWithoutCultosInput>
  }

  export type LeituraBiblicaUpdateWithWhereUniqueWithoutCultosInput = {
    where: LeituraBiblicaWhereUniqueInput
    data: XOR<LeituraBiblicaUpdateWithoutCultosInput, LeituraBiblicaUncheckedUpdateWithoutCultosInput>
  }

  export type LeituraBiblicaUpdateManyWithWhereWithoutCultosInput = {
    where: LeituraBiblicaScalarWhereInput
    data: XOR<LeituraBiblicaUpdateManyMutationInput, LeituraBiblicaUncheckedUpdateManyWithoutCultosInput>
  }

  export type LeituraBiblicaScalarWhereInput = {
    AND?: LeituraBiblicaScalarWhereInput | LeituraBiblicaScalarWhereInput[]
    OR?: LeituraBiblicaScalarWhereInput[]
    NOT?: LeituraBiblicaScalarWhereInput | LeituraBiblicaScalarWhereInput[]
    id?: IntFilter<"LeituraBiblica"> | number
    livro?: StringFilter<"LeituraBiblica"> | string
    capitulo?: IntFilter<"LeituraBiblica"> | number
    versiculos?: StringFilter<"LeituraBiblica"> | string
    createdAt?: DateTimeFilter<"LeituraBiblica"> | Date | string
    updatedAt?: DateTimeFilter<"LeituraBiblica"> | Date | string
  }

  export type LocalCreateWithoutReunioesInput = {
    nome: string
    latitude: number
    longitude: number
    cultos?: CultoCreateNestedManyWithoutLocalInput
    ensaios?: EnsaioCreateNestedManyWithoutLocalInput
    eventos?: EventoCreateNestedManyWithoutLocalInput
  }

  export type LocalUncheckedCreateWithoutReunioesInput = {
    id?: number
    nome: string
    latitude: number
    longitude: number
    cultos?: CultoUncheckedCreateNestedManyWithoutLocalInput
    ensaios?: EnsaioUncheckedCreateNestedManyWithoutLocalInput
    eventos?: EventoUncheckedCreateNestedManyWithoutLocalInput
  }

  export type LocalCreateOrConnectWithoutReunioesInput = {
    where: LocalWhereUniqueInput
    create: XOR<LocalCreateWithoutReunioesInput, LocalUncheckedCreateWithoutReunioesInput>
  }

  export type UserCreateWithoutReunioesResponsavelInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cargo?: CargoCreateNestedOneWithoutUsersInput
    cultosComoPastor?: CultoCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoCreateNestedManyWithoutVocalInput
    ensaiosResponsavel?: EnsaioCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioCreateNestedManyWithoutParticipantesInput
  }

  export type UserUncheckedCreateWithoutReunioesResponsavelInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    cargoId?: number | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoPastor?: CultoUncheckedCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoUncheckedCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoUncheckedCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoUncheckedCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoUncheckedCreateNestedManyWithoutVocalInput
    ensaiosResponsavel?: EnsaioUncheckedCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioUncheckedCreateNestedManyWithoutParticipantesInput
  }

  export type UserCreateOrConnectWithoutReunioesResponsavelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReunioesResponsavelInput, UserUncheckedCreateWithoutReunioesResponsavelInput>
  }

  export type LocalUpsertWithoutReunioesInput = {
    update: XOR<LocalUpdateWithoutReunioesInput, LocalUncheckedUpdateWithoutReunioesInput>
    create: XOR<LocalCreateWithoutReunioesInput, LocalUncheckedCreateWithoutReunioesInput>
    where?: LocalWhereInput
  }

  export type LocalUpdateToOneWithWhereWithoutReunioesInput = {
    where?: LocalWhereInput
    data: XOR<LocalUpdateWithoutReunioesInput, LocalUncheckedUpdateWithoutReunioesInput>
  }

  export type LocalUpdateWithoutReunioesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    cultos?: CultoUpdateManyWithoutLocalNestedInput
    ensaios?: EnsaioUpdateManyWithoutLocalNestedInput
    eventos?: EventoUpdateManyWithoutLocalNestedInput
  }

  export type LocalUncheckedUpdateWithoutReunioesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    cultos?: CultoUncheckedUpdateManyWithoutLocalNestedInput
    ensaios?: EnsaioUncheckedUpdateManyWithoutLocalNestedInput
    eventos?: EventoUncheckedUpdateManyWithoutLocalNestedInput
  }

  export type UserUpsertWithoutReunioesResponsavelInput = {
    update: XOR<UserUpdateWithoutReunioesResponsavelInput, UserUncheckedUpdateWithoutReunioesResponsavelInput>
    create: XOR<UserCreateWithoutReunioesResponsavelInput, UserUncheckedCreateWithoutReunioesResponsavelInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReunioesResponsavelInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReunioesResponsavelInput, UserUncheckedUpdateWithoutReunioesResponsavelInput>
  }

  export type UserUpdateWithoutReunioesResponsavelInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cargo?: CargoUpdateOneWithoutUsersNestedInput
    cultosComoPastor?: CultoUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUpdateManyWithoutVocalNestedInput
    ensaiosResponsavel?: EnsaioUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateWithoutReunioesResponsavelInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoPastor?: CultoUncheckedUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUncheckedUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUncheckedUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUncheckedUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUncheckedUpdateManyWithoutVocalNestedInput
    ensaiosResponsavel?: EnsaioUncheckedUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUncheckedUpdateManyWithoutParticipantesNestedInput
  }

  export type LocalCreateWithoutEnsaiosInput = {
    nome: string
    latitude: number
    longitude: number
    cultos?: CultoCreateNestedManyWithoutLocalInput
    reunioes?: ReuniaoCreateNestedManyWithoutLocalInput
    eventos?: EventoCreateNestedManyWithoutLocalInput
  }

  export type LocalUncheckedCreateWithoutEnsaiosInput = {
    id?: number
    nome: string
    latitude: number
    longitude: number
    cultos?: CultoUncheckedCreateNestedManyWithoutLocalInput
    reunioes?: ReuniaoUncheckedCreateNestedManyWithoutLocalInput
    eventos?: EventoUncheckedCreateNestedManyWithoutLocalInput
  }

  export type LocalCreateOrConnectWithoutEnsaiosInput = {
    where: LocalWhereUniqueInput
    create: XOR<LocalCreateWithoutEnsaiosInput, LocalUncheckedCreateWithoutEnsaiosInput>
  }

  export type UserCreateWithoutEnsaiosResponsavelInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cargo?: CargoCreateNestedOneWithoutUsersInput
    cultosComoPastor?: CultoCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioCreateNestedManyWithoutParticipantesInput
  }

  export type UserUncheckedCreateWithoutEnsaiosResponsavelInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    cargoId?: number | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoPastor?: CultoUncheckedCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoUncheckedCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoUncheckedCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoUncheckedCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoUncheckedCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoUncheckedCreateNestedManyWithoutResponsavelInput
    participaEnsaios?: EnsaioUncheckedCreateNestedManyWithoutParticipantesInput
  }

  export type UserCreateOrConnectWithoutEnsaiosResponsavelInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnsaiosResponsavelInput, UserUncheckedCreateWithoutEnsaiosResponsavelInput>
  }

  export type UserCreateWithoutParticipaEnsaiosInput = {
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cargo?: CargoCreateNestedOneWithoutUsersInput
    cultosComoPastor?: CultoCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioCreateNestedManyWithoutResponsavelInput
  }

  export type UserUncheckedCreateWithoutParticipaEnsaiosInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    cargoId?: number | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cultosComoPastor?: CultoUncheckedCreateNestedManyWithoutPastorInput
    cultosComoObreiro?: CultoUncheckedCreateNestedManyWithoutObreiroInput
    cultosComoAuxiliar?: CultoUncheckedCreateNestedManyWithoutAuxiliaresInput
    cultosComoLiderCantico?: CultoUncheckedCreateNestedManyWithoutLiderCanticoInput
    cultosComoVocal?: CultoUncheckedCreateNestedManyWithoutVocalInput
    reunioesResponsavel?: ReuniaoUncheckedCreateNestedManyWithoutResponsavelInput
    ensaiosResponsavel?: EnsaioUncheckedCreateNestedManyWithoutResponsavelInput
  }

  export type UserCreateOrConnectWithoutParticipaEnsaiosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParticipaEnsaiosInput, UserUncheckedCreateWithoutParticipaEnsaiosInput>
  }

  export type HinoCreateWithoutEnsaiosInput = {
    titulo: string
    autor: string
    letra: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cultos?: CultoCreateNestedManyWithoutHinosInput
  }

  export type HinoUncheckedCreateWithoutEnsaiosInput = {
    id?: number
    titulo: string
    autor: string
    letra: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cultos?: CultoUncheckedCreateNestedManyWithoutHinosInput
  }

  export type HinoCreateOrConnectWithoutEnsaiosInput = {
    where: HinoWhereUniqueInput
    create: XOR<HinoCreateWithoutEnsaiosInput, HinoUncheckedCreateWithoutEnsaiosInput>
  }

  export type LocalUpsertWithoutEnsaiosInput = {
    update: XOR<LocalUpdateWithoutEnsaiosInput, LocalUncheckedUpdateWithoutEnsaiosInput>
    create: XOR<LocalCreateWithoutEnsaiosInput, LocalUncheckedCreateWithoutEnsaiosInput>
    where?: LocalWhereInput
  }

  export type LocalUpdateToOneWithWhereWithoutEnsaiosInput = {
    where?: LocalWhereInput
    data: XOR<LocalUpdateWithoutEnsaiosInput, LocalUncheckedUpdateWithoutEnsaiosInput>
  }

  export type LocalUpdateWithoutEnsaiosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    cultos?: CultoUpdateManyWithoutLocalNestedInput
    reunioes?: ReuniaoUpdateManyWithoutLocalNestedInput
    eventos?: EventoUpdateManyWithoutLocalNestedInput
  }

  export type LocalUncheckedUpdateWithoutEnsaiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    cultos?: CultoUncheckedUpdateManyWithoutLocalNestedInput
    reunioes?: ReuniaoUncheckedUpdateManyWithoutLocalNestedInput
    eventos?: EventoUncheckedUpdateManyWithoutLocalNestedInput
  }

  export type UserUpsertWithoutEnsaiosResponsavelInput = {
    update: XOR<UserUpdateWithoutEnsaiosResponsavelInput, UserUncheckedUpdateWithoutEnsaiosResponsavelInput>
    create: XOR<UserCreateWithoutEnsaiosResponsavelInput, UserUncheckedCreateWithoutEnsaiosResponsavelInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnsaiosResponsavelInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnsaiosResponsavelInput, UserUncheckedUpdateWithoutEnsaiosResponsavelInput>
  }

  export type UserUpdateWithoutEnsaiosResponsavelInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cargo?: CargoUpdateOneWithoutUsersNestedInput
    cultosComoPastor?: CultoUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateWithoutEnsaiosResponsavelInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoPastor?: CultoUncheckedUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUncheckedUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUncheckedUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUncheckedUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUncheckedUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUncheckedUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUncheckedUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutParticipaEnsaiosInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutParticipaEnsaiosInput, UserUncheckedUpdateWithoutParticipaEnsaiosInput>
    create: XOR<UserCreateWithoutParticipaEnsaiosInput, UserUncheckedCreateWithoutParticipaEnsaiosInput>
  }

  export type UserUpdateWithWhereUniqueWithoutParticipaEnsaiosInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutParticipaEnsaiosInput, UserUncheckedUpdateWithoutParticipaEnsaiosInput>
  }

  export type UserUpdateManyWithWhereWithoutParticipaEnsaiosInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutParticipaEnsaiosInput>
  }

  export type HinoUpsertWithWhereUniqueWithoutEnsaiosInput = {
    where: HinoWhereUniqueInput
    update: XOR<HinoUpdateWithoutEnsaiosInput, HinoUncheckedUpdateWithoutEnsaiosInput>
    create: XOR<HinoCreateWithoutEnsaiosInput, HinoUncheckedCreateWithoutEnsaiosInput>
  }

  export type HinoUpdateWithWhereUniqueWithoutEnsaiosInput = {
    where: HinoWhereUniqueInput
    data: XOR<HinoUpdateWithoutEnsaiosInput, HinoUncheckedUpdateWithoutEnsaiosInput>
  }

  export type HinoUpdateManyWithWhereWithoutEnsaiosInput = {
    where: HinoScalarWhereInput
    data: XOR<HinoUpdateManyMutationInput, HinoUncheckedUpdateManyWithoutEnsaiosInput>
  }

  export type LocalCreateWithoutEventosInput = {
    nome: string
    latitude: number
    longitude: number
    cultos?: CultoCreateNestedManyWithoutLocalInput
    reunioes?: ReuniaoCreateNestedManyWithoutLocalInput
    ensaios?: EnsaioCreateNestedManyWithoutLocalInput
  }

  export type LocalUncheckedCreateWithoutEventosInput = {
    id?: number
    nome: string
    latitude: number
    longitude: number
    cultos?: CultoUncheckedCreateNestedManyWithoutLocalInput
    reunioes?: ReuniaoUncheckedCreateNestedManyWithoutLocalInput
    ensaios?: EnsaioUncheckedCreateNestedManyWithoutLocalInput
  }

  export type LocalCreateOrConnectWithoutEventosInput = {
    where: LocalWhereUniqueInput
    create: XOR<LocalCreateWithoutEventosInput, LocalUncheckedCreateWithoutEventosInput>
  }

  export type LocalUpsertWithoutEventosInput = {
    update: XOR<LocalUpdateWithoutEventosInput, LocalUncheckedUpdateWithoutEventosInput>
    create: XOR<LocalCreateWithoutEventosInput, LocalUncheckedCreateWithoutEventosInput>
    where?: LocalWhereInput
  }

  export type LocalUpdateToOneWithWhereWithoutEventosInput = {
    where?: LocalWhereInput
    data: XOR<LocalUpdateWithoutEventosInput, LocalUncheckedUpdateWithoutEventosInput>
  }

  export type LocalUpdateWithoutEventosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    cultos?: CultoUpdateManyWithoutLocalNestedInput
    reunioes?: ReuniaoUpdateManyWithoutLocalNestedInput
    ensaios?: EnsaioUpdateManyWithoutLocalNestedInput
  }

  export type LocalUncheckedUpdateWithoutEventosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    cultos?: CultoUncheckedUpdateManyWithoutLocalNestedInput
    reunioes?: ReuniaoUncheckedUpdateManyWithoutLocalNestedInput
    ensaios?: EnsaioUncheckedUpdateManyWithoutLocalNestedInput
  }

  export type CultoCreateWithoutMensagensInput = {
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutCultosInput
    pastor: UserCreateNestedOneWithoutCultosComoPastorInput
    obreiro: UserCreateNestedOneWithoutCultosComoObreiroInput
    auxiliares?: UserCreateNestedManyWithoutCultosComoAuxiliarInput
    liderCantico: UserCreateNestedOneWithoutCultosComoLiderCanticoInput
    vocal?: UserCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaCreateNestedManyWithoutCultosInput
  }

  export type CultoUncheckedCreateWithoutMensagensInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auxiliares?: UserUncheckedCreateNestedManyWithoutCultosComoAuxiliarInput
    vocal?: UserUncheckedCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoUncheckedCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaUncheckedCreateNestedManyWithoutCultosInput
  }

  export type CultoCreateOrConnectWithoutMensagensInput = {
    where: CultoWhereUniqueInput
    create: XOR<CultoCreateWithoutMensagensInput, CultoUncheckedCreateWithoutMensagensInput>
  }

  export type CultoUpsertWithWhereUniqueWithoutMensagensInput = {
    where: CultoWhereUniqueInput
    update: XOR<CultoUpdateWithoutMensagensInput, CultoUncheckedUpdateWithoutMensagensInput>
    create: XOR<CultoCreateWithoutMensagensInput, CultoUncheckedCreateWithoutMensagensInput>
  }

  export type CultoUpdateWithWhereUniqueWithoutMensagensInput = {
    where: CultoWhereUniqueInput
    data: XOR<CultoUpdateWithoutMensagensInput, CultoUncheckedUpdateWithoutMensagensInput>
  }

  export type CultoUpdateManyWithWhereWithoutMensagensInput = {
    where: CultoScalarWhereInput
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyWithoutMensagensInput>
  }

  export type CultoCreateWithoutHinosInput = {
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutCultosInput
    pastor: UserCreateNestedOneWithoutCultosComoPastorInput
    obreiro: UserCreateNestedOneWithoutCultosComoObreiroInput
    auxiliares?: UserCreateNestedManyWithoutCultosComoAuxiliarInput
    liderCantico: UserCreateNestedOneWithoutCultosComoLiderCanticoInput
    vocal?: UserCreateNestedManyWithoutCultosComoVocalInput
    mensagens?: MensagemCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaCreateNestedManyWithoutCultosInput
  }

  export type CultoUncheckedCreateWithoutHinosInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auxiliares?: UserUncheckedCreateNestedManyWithoutCultosComoAuxiliarInput
    vocal?: UserUncheckedCreateNestedManyWithoutCultosComoVocalInput
    mensagens?: MensagemUncheckedCreateNestedManyWithoutCultosInput
    leituras?: LeituraBiblicaUncheckedCreateNestedManyWithoutCultosInput
  }

  export type CultoCreateOrConnectWithoutHinosInput = {
    where: CultoWhereUniqueInput
    create: XOR<CultoCreateWithoutHinosInput, CultoUncheckedCreateWithoutHinosInput>
  }

  export type EnsaioCreateWithoutHinosInput = {
    titulo: string
    dataHora: Date | string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutEnsaiosInput
    responsavel: UserCreateNestedOneWithoutEnsaiosResponsavelInput
    participantes?: UserCreateNestedManyWithoutParticipaEnsaiosInput
  }

  export type EnsaioUncheckedCreateWithoutHinosInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    participantes?: UserUncheckedCreateNestedManyWithoutParticipaEnsaiosInput
  }

  export type EnsaioCreateOrConnectWithoutHinosInput = {
    where: EnsaioWhereUniqueInput
    create: XOR<EnsaioCreateWithoutHinosInput, EnsaioUncheckedCreateWithoutHinosInput>
  }

  export type CultoUpsertWithWhereUniqueWithoutHinosInput = {
    where: CultoWhereUniqueInput
    update: XOR<CultoUpdateWithoutHinosInput, CultoUncheckedUpdateWithoutHinosInput>
    create: XOR<CultoCreateWithoutHinosInput, CultoUncheckedCreateWithoutHinosInput>
  }

  export type CultoUpdateWithWhereUniqueWithoutHinosInput = {
    where: CultoWhereUniqueInput
    data: XOR<CultoUpdateWithoutHinosInput, CultoUncheckedUpdateWithoutHinosInput>
  }

  export type CultoUpdateManyWithWhereWithoutHinosInput = {
    where: CultoScalarWhereInput
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyWithoutHinosInput>
  }

  export type EnsaioUpsertWithWhereUniqueWithoutHinosInput = {
    where: EnsaioWhereUniqueInput
    update: XOR<EnsaioUpdateWithoutHinosInput, EnsaioUncheckedUpdateWithoutHinosInput>
    create: XOR<EnsaioCreateWithoutHinosInput, EnsaioUncheckedCreateWithoutHinosInput>
  }

  export type EnsaioUpdateWithWhereUniqueWithoutHinosInput = {
    where: EnsaioWhereUniqueInput
    data: XOR<EnsaioUpdateWithoutHinosInput, EnsaioUncheckedUpdateWithoutHinosInput>
  }

  export type EnsaioUpdateManyWithWhereWithoutHinosInput = {
    where: EnsaioScalarWhereInput
    data: XOR<EnsaioUpdateManyMutationInput, EnsaioUncheckedUpdateManyWithoutHinosInput>
  }

  export type CultoCreateWithoutLeiturasInput = {
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    local: LocalCreateNestedOneWithoutCultosInput
    pastor: UserCreateNestedOneWithoutCultosComoPastorInput
    obreiro: UserCreateNestedOneWithoutCultosComoObreiroInput
    auxiliares?: UserCreateNestedManyWithoutCultosComoAuxiliarInput
    liderCantico: UserCreateNestedOneWithoutCultosComoLiderCanticoInput
    vocal?: UserCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoCreateNestedManyWithoutCultosInput
    mensagens?: MensagemCreateNestedManyWithoutCultosInput
  }

  export type CultoUncheckedCreateWithoutLeiturasInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auxiliares?: UserUncheckedCreateNestedManyWithoutCultosComoAuxiliarInput
    vocal?: UserUncheckedCreateNestedManyWithoutCultosComoVocalInput
    hinos?: HinoUncheckedCreateNestedManyWithoutCultosInput
    mensagens?: MensagemUncheckedCreateNestedManyWithoutCultosInput
  }

  export type CultoCreateOrConnectWithoutLeiturasInput = {
    where: CultoWhereUniqueInput
    create: XOR<CultoCreateWithoutLeiturasInput, CultoUncheckedCreateWithoutLeiturasInput>
  }

  export type CultoUpsertWithWhereUniqueWithoutLeiturasInput = {
    where: CultoWhereUniqueInput
    update: XOR<CultoUpdateWithoutLeiturasInput, CultoUncheckedUpdateWithoutLeiturasInput>
    create: XOR<CultoCreateWithoutLeiturasInput, CultoUncheckedCreateWithoutLeiturasInput>
  }

  export type CultoUpdateWithWhereUniqueWithoutLeiturasInput = {
    where: CultoWhereUniqueInput
    data: XOR<CultoUpdateWithoutLeiturasInput, CultoUncheckedUpdateWithoutLeiturasInput>
  }

  export type CultoUpdateManyWithWhereWithoutLeiturasInput = {
    where: CultoScalarWhereInput
    data: XOR<CultoUpdateManyMutationInput, CultoUncheckedUpdateManyWithoutLeiturasInput>
  }

  export type CultoCreateManyPastorInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CultoCreateManyObreiroInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CultoCreateManyLiderCanticoInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    localId: number
    status: string
    pastorId: number
    obreiroId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReuniaoCreateManyResponsavelInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    materiais: string
    cronograma: string
    informacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnsaioCreateManyResponsavelInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    localId: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CultoUpdateWithoutPastorInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutCultosNestedInput
    obreiro?: UserUpdateOneRequiredWithoutCultosComoObreiroNestedInput
    auxiliares?: UserUpdateManyWithoutCultosComoAuxiliarNestedInput
    liderCantico?: UserUpdateOneRequiredWithoutCultosComoLiderCanticoNestedInput
    vocal?: UserUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateWithoutPastorInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auxiliares?: UserUncheckedUpdateManyWithoutCultosComoAuxiliarNestedInput
    vocal?: UserUncheckedUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUncheckedUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUncheckedUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateManyWithoutPastorInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultoUpdateWithoutObreiroInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutCultosNestedInput
    pastor?: UserUpdateOneRequiredWithoutCultosComoPastorNestedInput
    auxiliares?: UserUpdateManyWithoutCultosComoAuxiliarNestedInput
    liderCantico?: UserUpdateOneRequiredWithoutCultosComoLiderCanticoNestedInput
    vocal?: UserUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateWithoutObreiroInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auxiliares?: UserUncheckedUpdateManyWithoutCultosComoAuxiliarNestedInput
    vocal?: UserUncheckedUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUncheckedUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUncheckedUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateManyWithoutObreiroInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultoUpdateWithoutAuxiliaresInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutCultosNestedInput
    pastor?: UserUpdateOneRequiredWithoutCultosComoPastorNestedInput
    obreiro?: UserUpdateOneRequiredWithoutCultosComoObreiroNestedInput
    liderCantico?: UserUpdateOneRequiredWithoutCultosComoLiderCanticoNestedInput
    vocal?: UserUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateWithoutAuxiliaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vocal?: UserUncheckedUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUncheckedUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUncheckedUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateManyWithoutAuxiliaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultoUpdateWithoutLiderCanticoInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutCultosNestedInput
    pastor?: UserUpdateOneRequiredWithoutCultosComoPastorNestedInput
    obreiro?: UserUpdateOneRequiredWithoutCultosComoObreiroNestedInput
    auxiliares?: UserUpdateManyWithoutCultosComoAuxiliarNestedInput
    vocal?: UserUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateWithoutLiderCanticoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auxiliares?: UserUncheckedUpdateManyWithoutCultosComoAuxiliarNestedInput
    vocal?: UserUncheckedUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUncheckedUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUncheckedUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateManyWithoutLiderCanticoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultoUpdateWithoutVocalInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutCultosNestedInput
    pastor?: UserUpdateOneRequiredWithoutCultosComoPastorNestedInput
    obreiro?: UserUpdateOneRequiredWithoutCultosComoObreiroNestedInput
    auxiliares?: UserUpdateManyWithoutCultosComoAuxiliarNestedInput
    liderCantico?: UserUpdateOneRequiredWithoutCultosComoLiderCanticoNestedInput
    hinos?: HinoUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateWithoutVocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auxiliares?: UserUncheckedUpdateManyWithoutCultosComoAuxiliarNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUncheckedUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUncheckedUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateManyWithoutVocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReuniaoUpdateWithoutResponsavelInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    materiais?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    informacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutReunioesNestedInput
  }

  export type ReuniaoUncheckedUpdateWithoutResponsavelInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    materiais?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    informacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReuniaoUncheckedUpdateManyWithoutResponsavelInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    materiais?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    informacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnsaioUpdateWithoutResponsavelInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutEnsaiosNestedInput
    participantes?: UserUpdateManyWithoutParticipaEnsaiosNestedInput
    hinos?: HinoUpdateManyWithoutEnsaiosNestedInput
  }

  export type EnsaioUncheckedUpdateWithoutResponsavelInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantes?: UserUncheckedUpdateManyWithoutParticipaEnsaiosNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutEnsaiosNestedInput
  }

  export type EnsaioUncheckedUpdateManyWithoutResponsavelInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnsaioUpdateWithoutParticipantesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutEnsaiosNestedInput
    responsavel?: UserUpdateOneRequiredWithoutEnsaiosResponsavelNestedInput
    hinos?: HinoUpdateManyWithoutEnsaiosNestedInput
  }

  export type EnsaioUncheckedUpdateWithoutParticipantesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hinos?: HinoUncheckedUpdateManyWithoutEnsaiosNestedInput
  }

  export type EnsaioUncheckedUpdateManyWithoutParticipantesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraCreateManyLiveInput = {
    id?: number
    texto: string
    minuto: string
    createdAt?: Date | string
  }

  export type PedidoOracaoCreateManyLiveInput = {
    id?: number
    para: string
    motivo: string
    createdAt?: Date | string
  }

  export type ViewerSessionCreateManyLiveInput = {
    id?: number
    sessionId: string
    userName?: string | null
    userImage?: string | null
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type LeituraUpdateWithoutLiveInput = {
    texto?: StringFieldUpdateOperationsInput | string
    minuto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraUncheckedUpdateWithoutLiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    texto?: StringFieldUpdateOperationsInput | string
    minuto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraUncheckedUpdateManyWithoutLiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    texto?: StringFieldUpdateOperationsInput | string
    minuto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoOracaoUpdateWithoutLiveInput = {
    para?: StringFieldUpdateOperationsInput | string
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoOracaoUncheckedUpdateWithoutLiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    para?: StringFieldUpdateOperationsInput | string
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PedidoOracaoUncheckedUpdateManyWithoutLiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    para?: StringFieldUpdateOperationsInput | string
    motivo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewerSessionUpdateWithoutLiveInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ViewerSessionUncheckedUpdateWithoutLiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ViewerSessionUncheckedUpdateManyWithoutLiveInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyCargoInput = {
    id?: number
    username: string
    password: string
    name?: string | null
    email?: string | null
    online?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutCargoInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoPastor?: CultoUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateWithoutCargoInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoPastor?: CultoUncheckedUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUncheckedUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUncheckedUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUncheckedUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUncheckedUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUncheckedUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUncheckedUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUncheckedUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCargoInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultoCreateManyLocalInput = {
    id?: number
    titulo: string
    dataInicio: Date | string
    dataTermino: Date | string
    status: string
    pastorId: number
    obreiroId: number
    liderCanticoId: number
    videoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReuniaoCreateManyLocalInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    status: string
    responsavelId: number
    materiais: string
    cronograma: string
    informacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnsaioCreateManyLocalInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    status: string
    responsavelId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoCreateManyLocalInput = {
    id?: number
    titulo: string
    dataHora: Date | string
    status: string
    cronograma: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CultoUpdateWithoutLocalInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pastor?: UserUpdateOneRequiredWithoutCultosComoPastorNestedInput
    obreiro?: UserUpdateOneRequiredWithoutCultosComoObreiroNestedInput
    auxiliares?: UserUpdateManyWithoutCultosComoAuxiliarNestedInput
    liderCantico?: UserUpdateOneRequiredWithoutCultosComoLiderCanticoNestedInput
    vocal?: UserUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateWithoutLocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auxiliares?: UserUncheckedUpdateManyWithoutCultosComoAuxiliarNestedInput
    vocal?: UserUncheckedUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUncheckedUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUncheckedUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateManyWithoutLocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReuniaoUpdateWithoutLocalInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    materiais?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    informacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsavel?: UserUpdateOneRequiredWithoutReunioesResponsavelNestedInput
  }

  export type ReuniaoUncheckedUpdateWithoutLocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    materiais?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    informacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReuniaoUncheckedUpdateManyWithoutLocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    materiais?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    informacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnsaioUpdateWithoutLocalInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsavel?: UserUpdateOneRequiredWithoutEnsaiosResponsavelNestedInput
    participantes?: UserUpdateManyWithoutParticipaEnsaiosNestedInput
    hinos?: HinoUpdateManyWithoutEnsaiosNestedInput
  }

  export type EnsaioUncheckedUpdateWithoutLocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantes?: UserUncheckedUpdateManyWithoutParticipaEnsaiosNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutEnsaiosNestedInput
  }

  export type EnsaioUncheckedUpdateManyWithoutLocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoUpdateWithoutLocalInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoUncheckedUpdateWithoutLocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoUncheckedUpdateManyWithoutLocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    cronograma?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCultosComoAuxiliarInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cargo?: CargoUpdateOneWithoutUsersNestedInput
    cultosComoPastor?: CultoUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUpdateManyWithoutObreiroNestedInput
    cultosComoLiderCantico?: CultoUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateWithoutCultosComoAuxiliarInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoPastor?: CultoUncheckedUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUncheckedUpdateManyWithoutObreiroNestedInput
    cultosComoLiderCantico?: CultoUncheckedUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUncheckedUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUncheckedUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUncheckedUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUncheckedUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCultosComoAuxiliarInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutCultosComoVocalInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cargo?: CargoUpdateOneWithoutUsersNestedInput
    cultosComoPastor?: CultoUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUpdateManyWithoutLiderCanticoNestedInput
    reunioesResponsavel?: ReuniaoUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateWithoutCultosComoVocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoPastor?: CultoUncheckedUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUncheckedUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUncheckedUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUncheckedUpdateManyWithoutLiderCanticoNestedInput
    reunioesResponsavel?: ReuniaoUncheckedUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUncheckedUpdateManyWithoutResponsavelNestedInput
    participaEnsaios?: EnsaioUncheckedUpdateManyWithoutParticipantesNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCultosComoVocalInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HinoUpdateWithoutCultosInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    autor?: StringFieldUpdateOperationsInput | string
    letra?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ensaios?: EnsaioUpdateManyWithoutHinosNestedInput
  }

  export type HinoUncheckedUpdateWithoutCultosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    autor?: StringFieldUpdateOperationsInput | string
    letra?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ensaios?: EnsaioUncheckedUpdateManyWithoutHinosNestedInput
  }

  export type HinoUncheckedUpdateManyWithoutCultosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    autor?: StringFieldUpdateOperationsInput | string
    letra?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensagemUpdateWithoutCultosInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    traduzidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensagemUncheckedUpdateWithoutCultosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    traduzidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MensagemUncheckedUpdateManyWithoutCultosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    cidade?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    traduzidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    conteudo?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraBiblicaUpdateWithoutCultosInput = {
    livro?: StringFieldUpdateOperationsInput | string
    capitulo?: IntFieldUpdateOperationsInput | number
    versiculos?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraBiblicaUncheckedUpdateWithoutCultosInput = {
    id?: IntFieldUpdateOperationsInput | number
    livro?: StringFieldUpdateOperationsInput | string
    capitulo?: IntFieldUpdateOperationsInput | number
    versiculos?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraBiblicaUncheckedUpdateManyWithoutCultosInput = {
    id?: IntFieldUpdateOperationsInput | number
    livro?: StringFieldUpdateOperationsInput | string
    capitulo?: IntFieldUpdateOperationsInput | number
    versiculos?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutParticipaEnsaiosInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cargo?: CargoUpdateOneWithoutUsersNestedInput
    cultosComoPastor?: CultoUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUpdateManyWithoutResponsavelNestedInput
  }

  export type UserUncheckedUpdateWithoutParticipaEnsaiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultosComoPastor?: CultoUncheckedUpdateManyWithoutPastorNestedInput
    cultosComoObreiro?: CultoUncheckedUpdateManyWithoutObreiroNestedInput
    cultosComoAuxiliar?: CultoUncheckedUpdateManyWithoutAuxiliaresNestedInput
    cultosComoLiderCantico?: CultoUncheckedUpdateManyWithoutLiderCanticoNestedInput
    cultosComoVocal?: CultoUncheckedUpdateManyWithoutVocalNestedInput
    reunioesResponsavel?: ReuniaoUncheckedUpdateManyWithoutResponsavelNestedInput
    ensaiosResponsavel?: EnsaioUncheckedUpdateManyWithoutResponsavelNestedInput
  }

  export type UserUncheckedUpdateManyWithoutParticipaEnsaiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cargoId?: NullableIntFieldUpdateOperationsInput | number | null
    online?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HinoUpdateWithoutEnsaiosInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    autor?: StringFieldUpdateOperationsInput | string
    letra?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultos?: CultoUpdateManyWithoutHinosNestedInput
  }

  export type HinoUncheckedUpdateWithoutEnsaiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    autor?: StringFieldUpdateOperationsInput | string
    letra?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cultos?: CultoUncheckedUpdateManyWithoutHinosNestedInput
  }

  export type HinoUncheckedUpdateManyWithoutEnsaiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    autor?: StringFieldUpdateOperationsInput | string
    letra?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultoUpdateWithoutMensagensInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutCultosNestedInput
    pastor?: UserUpdateOneRequiredWithoutCultosComoPastorNestedInput
    obreiro?: UserUpdateOneRequiredWithoutCultosComoObreiroNestedInput
    auxiliares?: UserUpdateManyWithoutCultosComoAuxiliarNestedInput
    liderCantico?: UserUpdateOneRequiredWithoutCultosComoLiderCanticoNestedInput
    vocal?: UserUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateWithoutMensagensInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auxiliares?: UserUncheckedUpdateManyWithoutCultosComoAuxiliarNestedInput
    vocal?: UserUncheckedUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUncheckedUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateManyWithoutMensagensInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultoUpdateWithoutHinosInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutCultosNestedInput
    pastor?: UserUpdateOneRequiredWithoutCultosComoPastorNestedInput
    obreiro?: UserUpdateOneRequiredWithoutCultosComoObreiroNestedInput
    auxiliares?: UserUpdateManyWithoutCultosComoAuxiliarNestedInput
    liderCantico?: UserUpdateOneRequiredWithoutCultosComoLiderCanticoNestedInput
    vocal?: UserUpdateManyWithoutCultosComoVocalNestedInput
    mensagens?: MensagemUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateWithoutHinosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auxiliares?: UserUncheckedUpdateManyWithoutCultosComoAuxiliarNestedInput
    vocal?: UserUncheckedUpdateManyWithoutCultosComoVocalNestedInput
    mensagens?: MensagemUncheckedUpdateManyWithoutCultosNestedInput
    leituras?: LeituraBiblicaUncheckedUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateManyWithoutHinosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnsaioUpdateWithoutHinosInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutEnsaiosNestedInput
    responsavel?: UserUpdateOneRequiredWithoutEnsaiosResponsavelNestedInput
    participantes?: UserUpdateManyWithoutParticipaEnsaiosNestedInput
  }

  export type EnsaioUncheckedUpdateWithoutHinosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participantes?: UserUncheckedUpdateManyWithoutParticipaEnsaiosNestedInput
  }

  export type EnsaioUncheckedUpdateManyWithoutHinosInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataHora?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    responsavelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CultoUpdateWithoutLeiturasInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    local?: LocalUpdateOneRequiredWithoutCultosNestedInput
    pastor?: UserUpdateOneRequiredWithoutCultosComoPastorNestedInput
    obreiro?: UserUpdateOneRequiredWithoutCultosComoObreiroNestedInput
    auxiliares?: UserUpdateManyWithoutCultosComoAuxiliarNestedInput
    liderCantico?: UserUpdateOneRequiredWithoutCultosComoLiderCanticoNestedInput
    vocal?: UserUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateWithoutLeiturasInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auxiliares?: UserUncheckedUpdateManyWithoutCultosComoAuxiliarNestedInput
    vocal?: UserUncheckedUpdateManyWithoutCultosComoVocalNestedInput
    hinos?: HinoUncheckedUpdateManyWithoutCultosNestedInput
    mensagens?: MensagemUncheckedUpdateManyWithoutCultosNestedInput
  }

  export type CultoUncheckedUpdateManyWithoutLeiturasInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    dataInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    dataTermino?: DateTimeFieldUpdateOperationsInput | Date | string
    localId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    pastorId?: IntFieldUpdateOperationsInput | number
    obreiroId?: IntFieldUpdateOperationsInput | number
    liderCanticoId?: IntFieldUpdateOperationsInput | number
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}